#!/usr/bin/env python3
# See the NOTICE file distributed with this work for additional information
# regarding copyright ownership.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Calculate genomic coverage for one sequence in a HAL alignment file."""

from argparse import ArgumentParser
import json
from pathlib import Path
import re
import subprocess
from tempfile import SpooledTemporaryFile
from typing import Dict, TextIO, Union


def hal_genomic_coverage(hal_path: Union[Path, str], ref_genome: str, ref_sequence: str,
                         hal_alignment_depth_exe: Union[Path, str] = "halAlignmentDepth") -> Dict:
    """Uses halAlignmentDepth to get genomic coverage for the given genome and sequence.

    Args:
        hal_path: Input HAL file.
        ref_genome: Reference genome against which alignment depth is calculated.
        ref_sequence: Sequence in reference genome for which alignment depth is calculated.
        hal_alignment_depth_exe: Path of halAlignmentDepth executable. By default, assumed
            to be available via the PATH environment variable.

    Returns:
        Dictionary of genomic coverage stats for
        the specified reference genome sequence.

    """
    cmd_args = [
        hal_alignment_depth_exe,
        hal_path,
        ref_genome,
        "--noAncestors",
        "--refSequence", ref_sequence
    ]

    rollover_limit = 1_048_576
    with SpooledTemporaryFile(max_size=rollover_limit, mode="w+t") as tmp_file_obj:

        try:
            subprocess.run(cmd_args, stdout=tmp_file_obj, text=True, encoding="ascii", check=True)
        except subprocess.CalledProcessError as exc:
            status_type = "exit code" if exc.returncode > 0 else "signal"
            raise RuntimeError(f"halAlignmentDepth terminated with {status_type} {abs(exc.returncode)}"
                               f" for sequence '{ref_sequence}' of genome 'ref_genome'") from exc

        tmp_file_obj.flush()
        tmp_file_obj.seek(0)
        result_part = load_genomic_coverage_wiggle(tmp_file_obj)

    return result_part[ref_sequence]


def load_genomic_coverage_wiggle(wiggle_file_obj: Union[SpooledTemporaryFile, TextIO]) -> Dict:
    """Load data from wiggle file generated by halAlignmentDepth.

    Args:
        wiggle_file_obj: Input wiggle file object.

    Returns:
        Nested dictionary of coverage stats, with the key being the sequence name,
        and the value being a dictionary of coverage stats for that sequence.

    """
    declaration_line_re = re.compile(
        r"fixedStep chrom=(?P<chrom>\S+) start=(?P<start>[0-9]+) step=(?P<step>[0-9]+)\s*"
    )

    cov_stats = {}
    curr_seq_name = None
    for line in wiggle_file_obj:
        try:
            aligned_genome_count = int(line)
        except ValueError as exc:

            if (match := declaration_line_re.fullmatch(line)):
                curr_seq_name = match["chrom"]
                if curr_seq_name in cov_stats:
                    raise ValueError(
                        f"multiple occurrences of sequence '{curr_seq_name}' found") from exc
                cov_stats[curr_seq_name] = {
                    "num_aligned_positions": 0,
                    "num_positions": 0,
                    "start": int(match["start"]),
                    "step": int(match["step"]),
                }
            elif line.startswith("variableStep"):
                raise ValueError("variableStep blocks not supported") from exc
            else:
                raise ValueError(f"failed to parse wiggle line: {line}") from exc

        else:
            if aligned_genome_count > 0:
                cov_stats[curr_seq_name]["num_aligned_positions"] += 1
            cov_stats[curr_seq_name]["num_positions"] += 1

    return cov_stats


def load_seq_lengths(hal_file: Union[Path, str], genome_name: str,
                     hal_stats_exe: Union[Path, str] = "halStats") -> Dict[str, int]:
    """Load sequence lengths from an input HAL file.

    Args:
        hal_file: Input HAL file.
        genome_name: Name of the HAL genome for which sequence lengths should be obtained.
        hal_stats_exe: Path of halStats executable. By default, assumed
            to be available via the PATH environment variable.

    Returns:
        Dictionary mapping sequence names to their lengths.

    """
    cmd_args = [hal_stats_exe, "--chromSizes", genome_name, hal_file]
    process = subprocess.run(cmd_args, check=True, capture_output=True, text=True, encoding="ascii")

    seq_lengths = {}
    for line in process.stdout.splitlines():
        seq_name, seq_length = line.rstrip("\n").split("\t")
        seq_lengths[seq_name] = int(seq_length)

    return seq_lengths


def main() -> None:
    """Main function of script."""

    parser = ArgumentParser(description=__doc__)
    parser.add_argument("in_hal_path",
                        help="Input HAL file.")
    parser.add_argument("genome_name",
                        help="Name of genome for which genomic coverage is calculated.")
    parser.add_argument("sequence_name",
                        help="Name of sequence for which genomic coverage is calculated.")

    parser.add_argument("--hal_alignment_depth_exe",
                        help="Path of halAlignmentDepth executable. By default, assumed"
                             " to be available via the PATH environment variable.")
    parser.add_argument("--hal_stats_exe",
                        help="Path of halStats executable. By default, assumed"
                             " to be available via the PATH environment variable.")

    args = parser.parse_args()

    hal_genome_seq_lengths = load_seq_lengths(args.in_hal_path, args.genome_name,
                                              hal_stats_exe=args.hal_stats_exe)
    exp_num_positions = hal_genome_seq_lengths[args.sequence_name]

    hal_cov_result = hal_genomic_coverage(args.in_hal_path, args.genome_name, args.sequence_name,
                                          hal_alignment_depth_exe=args.hal_alignment_depth_exe)
    obs_num_positions = hal_cov_result["num_positions"]

    if obs_num_positions != exp_num_positions:
        raise ValueError(f"sequence-length mismatch for '{args.sequence_name}':"
                         f" {obs_num_positions} vs {exp_num_positions}")

    output = {
        "num_positions": obs_num_positions,
        "num_aligned_positions": hal_cov_result["num_aligned_positions"]
    }

    print(json.dumps(output))


if __name__ == "__main__":
    main()
