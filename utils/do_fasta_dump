#!/usr/local/bin/perl

use strict;
use warnings;

package do_fasta_dump;

use Carp;
use FindBin qw($Bin);
use File::Basename qw( dirname );
use Time::localtime;
use Time::HiRes qw(time);
use Getopt::Long;
use Pod::Usage;
use Data::Dumper qw( Dumper );

# Load libraries needed for reading config -----------------------------------
use vars qw( $SERVERROOT );
BEGIN{
  $SERVERROOT = dirname( $Bin );
  unshift @INC, "$SERVERROOT/conf";
  unshift @INC, "$SERVERROOT";
  eval{ require SiteDefs };
  if ($@){ die "Can't use SiteDefs.pm - $@\n"; }
  map{ unshift @INC, $_ } @SiteDefs::ENSEMBL_LIB_DIRS;
}

use Bio::EnsEMBL::DBSQL::DBAdaptor;
use Bio::EnsEMBL::DBLoader;
use Bio::SeqIO;
use utils::Tool;

#$| = 1; # unbuffers STDOUT (issues print commands immediately)

our $DUMPDIR;
our $NODATA;

my $no_compress;
my $no_log;
my $no_indexes;
my $logfile;
my $help;
my $info;
my @SPECIES;
my @DATABASES;
my @TYPES;
our $release;
my $email;
my $minimise_memory;

&GetOptions(
	    'species:s'  => \@SPECIES,
	    'database:s' => \@DATABASES,
	    'type:s'     => \@TYPES,
	    'release:s'  => \$release,
	    'dumpdir:s'  => \$DUMPDIR,
	    'no_compress' => \$no_compress,
            'no_indexes' => \$no_indexes,
	    'no_log'     => \$no_log,
	    'logfile:s'  => \$logfile,
	    'help'       => \$help,
	    'info'       => \$info,
	    'email:s'    => \$email,
	    'no_data'    => \$NODATA,
	    'minimise_memory' => \$minimise_memory,
	   ) || pod2usage(2);

pod2usage(-verbose => 2) if $info;
pod2usage(-verbose => 1) if $help;

my $types = check_types(\@TYPES);
die "\n\n[DIE] You must provide an ensembl release number e.g. --release 30" unless $release;

# Load modules needed for reading config -------------------------------------
#info(1, "Using config in $SERVERROOT/conf" );
require EnsEMBL::Web::SpeciesDefs;      # Loaded at run time
require EnsEMBL::Web::DBSQL::DBConnection;

my $SPECIES_DEFS = EnsEMBL::Web::SpeciesDefs->new(); 
$SPECIES_DEFS || die "$0: SpeciesDefs config not found";

# Check the ENSEMBL_VERSION is up to date and matchs user's request
if ( my $sitedefs_release =  $SiteDefs::ENSEMBL_VERSION ne $release) {
 die "[*DIE] Ensembl release version requested is $release but site defs is configured to use $sitedefs_release";
}

# Times and log file
our $script_start_time = time();
unless ($no_log) {
  (my $time = gmtime(time)) =~ s/\s+/\./g;
  $logfile ||= "logs/fasta$release"."_$time.log";
  print STDERR "Using logfile $logfile\n";
  open(STDERR, "> $logfile") || die "Can't create file:$!\n";
}

# Validate DUMPDIR
$DUMPDIR   ||= "/mysql/dumps/FTP";
utils::Tool::check_dir($DUMPDIR);

my %db_names = ( 'ENSEMBL_DB'      => 'core',
               'ENSEMBL_ESTGENE' => 'estgene',
               'ENSEMBL_VEGA'    => 'vega', );


# Check species if user defined.  Else use all species
if (@SPECIES) {
  @SPECIES = @{ utils::Tool::check_species(\@SPECIES) };
}
else {
  @SPECIES = @{ utils::Tool::all_species()};
}

# For each species ----------------------------------------------------------
for my $sp( sort @SPECIES ){  # users selected spp

  # Work out species folder name and empty if you are dumping --type all
  my $sp_release = $SPECIES_DEFS->get_config($sp,"SPECIES_RELEASE_VERSION");
  $sp_release =~ s/\.//g;
  my $sp_folder = "$DUMPDIR/".(join "_", lc($sp), $release, $sp_release)."/data/fasta";

  if ( -e $sp_folder && $TYPES[0] eq 'all') {
    info( 1, "Removing existing copies of $sp_folder" );
    system("rm -rf $sp_folder") && die "Couldn't delete $sp_folder";
  }

  my $dbConnection = EnsEMBL::Web::DBSQL::DBConnection->new($sp, $SPECIES_DEFS);

  foreach my $db( @DATABASES || "ENSEMBL_DB"){
    my $db_adaptor = $dbConnection->get_DBAdaptor( $db_names{$db} ) ||
      ( warning( 1, "DB $db is not valid for $sp" ) && next );
    warning( 1, "Dumping @TYPES from \n$db $sp - $DUMPDIR" );

    # Create directories and filehandles for dumps
    my ($chr_toplevel, $fhs) = create_dirs_for_dumps($sp, $SPECIES_DEFS, 
						     $sp_folder,
						     $types,  $db_adaptor);

    # Do dumps
    my $created_files = get_data($db_adaptor, $sp, $fhs, $chr_toplevel);
  
    # Make blast indexes and copy to blastsrv machine $BLASTSRV
    blast_indexes( $created_files ) unless $no_indexes;

    # Compress (gzip files)
    compress( $created_files ) unless $no_compress;
  }
}


# Work out timings -----------------------------------------------------------
my $time_taken = time - $script_start_time;
my $hours      = localtime($time_taken)->hour -1;
warning (1, "Used $logfile.") if $logfile;
warning (1, " Time taken: $hours:". localtime($time_taken)->min."mins");
close STDERR;

my $pre_spp = $TYPES[0] eq 'blast_all' ? "This is a PRE species.\n" :"";
my $additional_text = qq(
\n\n-------- Using this data --------------
To: aws\@sanger.ac.uk, ensembl-webteam\@sanger.ac.uk
Subject: ssaha server

Please can you set up ssaha servers for @SPECIES. $pre_spp
The files are here ecs3:$DUMPDIR .

Thanks,

Ensembl-webteam

);

$email ||= 'ensembl-webteam@sanger.ac.uk';
utils::Tool::mail_log( $logfile, $email, $additional_text ) if $logfile;
exit;

######################### END OF PROGRAM ######################################

sub check_types {
  my $types = shift;
  my %valid_types = map{ $_ => 1 }
    qw(
       pre blast
       ncrna  cdna_known-ccds
       cdna_all cdna_known cdna_novel cdna_pseudo cdna_abinitio
       pep_all  pep_known  pep_novel  pep_abinitio pep_known-ccds
       dna_seqlevel    dna_seqlevel_masked
       dna_toplevel    dna_toplevel_masked
      );


  my %compound_types = 
    (
     dna   => [ qw( dna_seqlevel dna_seqlevel_masked 
			dna_toplevel dna_toplevel_masked) ],
     cdna  => [ qw( cdna_all cdna_known cdna_novel cdna_pseudo cdna_abinitio
                        cdna_known-ccds)],
     pep   => [ qw( pep_all pep_known pep_novel pep_abinitio pep_known-ccds) ],
     rna   => [ qw( ncrna ) ],
     blast => [ qw( rna cdna pep dna_seqlevel dna_seqlevel_masked ) ],
     pre       => [ qw( dna_toplevel rna cdna pep dna_seqlevel dna_seqlevel_masked ) ],
     all       => [ qw( cdna pep dna rna) ],
    );


  # Validate types  and return hashref
  return utils::Tool::validate_types(\%valid_types, \%compound_types, $types);
}


#-----------------------------------------------------------------------------

sub create_dirs_for_dumps {
  my ($sp, $SPECIES_DEFS, $sp_folder, $types, $db_adaptor) = @_;

  # Get assembly and check against ini file -------------
  my $cs_adaptor   = $db_adaptor->get_CoordSystemAdaptor;
  my ($highest_cs) = @{$cs_adaptor->fetch_all()};
  my $assembly     = $highest_cs->version();
  my $ini_assembly = $SPECIES_DEFS->get_config($sp,"ENSEMBL_GOLDEN_PATH");
  warning(1, "Error: INI file GOLDEN_PATH is $ini_assembly. Database assembly is $assembly") unless $ini_assembly eq $assembly;
  my $file_details = "$sp.$assembly.$release";


  # Create dirs ------------------------------------------
  my $filehandles;
  foreach my $type ( @$types) {
    my( $master_type ) = split( '_', $type );
    my $thisdir = $sp_folder."/$master_type";

    unless ( -e $thisdir ) {
      utils::Tool::check_dir( $thisdir );
      open(README, '>'."$thisdir/README") or die "Couldn't open file $thisdir/README: $!\n";
      print README readme($master_type);
      close README;
    }

    # Work out types of directories needed ------------------------
    my ($seqtype, $idtype);
    if ($type =~ /toplevel/) {
      $seqtype = "dna";
      $idtype = "nonchromosomal";
      # chromosome directories are added later on per species basis
    }
    elsif ($type =~ /seqlevel/) {  # contig, chunk, chromosome for Scerevisiae
      $seqtype = "dna";
      #$idtype = $cs_adaptor->fetch_sequence_level->name; # seq_level;
      $idtype = "seqlevel"; # seq_level;
    }
    else {
      ($seqtype, $idtype) = split (/_/, $type);
    }
    if ($type =~ /masked/) {
      $seqtype .= "_rm";
    }

    # file name like dna.contig.fa cdna.abinitio.fa
    my $tmp_file = join (".", "$thisdir/$file_details", $seqtype, $idtype || (), "fa");
    $filehandles->{$type} = Bio::SeqIO->new('-format' => 'Fasta', 
					    '-file'   => '>'.$tmp_file);
  }

  my $chr_toplevel = "$sp_folder/dna/$file_details";
  return ( $chr_toplevel, $filehandles );
}

#------------------------------------------------------------------------------
sub get_data {
  my $dbAdaptor    = shift || die( 'Need a DBAdaptor' );
  my $species      = shift || die( 'Need a species' );
  my $fhs          = shift || die( 'Need a hashref of types to dump' );
  my $chr_toplevel = shift;  # for toplevel seq directories
  my $load_exons   = 1;

  # Dump even non-reference region
  my $sliceAdaptor = $dbAdaptor->get_SliceAdaptor;
  my $gene_adaptor = $dbAdaptor->get_GeneAdaptor;
  if(!defined($minimise_memory)){
    $sliceAdaptor->cache_toplevel_seq_mappings();
  }
  else{
    info( 1, "Using minimise memory option. Will use less memory but will be slower" );
  }

  foreach my $slice( @{$sliceAdaptor->fetch_all('toplevel', undef, 1)} ){
    info( 1, "Start toplevel ". $slice->name );
     my $coord_system = $slice->coord_system->name;

    # Toplevel DNA dumps ------------------------------------------------------
    if ($fhs->{'dna_toplevel_masked'} or $fhs->{'dna_toplevel'}) {

      my $seq_name = $slice->seq_region_name;
      #info (1, "M1: $seq_name");
      # If not chr based toplevel, use predefined filehandle
      if ( ($coord_system !~ /^chromosome$/i) or  ( $seq_name =~/random
						 |E\d\d\w*$
						 |_NT_
                                                 |scaffold_
						 /x)  ) {
	if ( my $seqio = $fhs->{'dna_toplevel'} ){
	  dump_dna( $seqio, $slice, 'dna' );
	}
	if ( my $seqio_masked = $fhs->{'dna_toplevel_masked'} ){
	  dump_dna( $seqio_masked, $slice->get_repeatmasked_seq, 'dna_rm' );
	}
      }

      # chromosome based system, need to make new files for each chr
      else  {
	my $file = ">$chr_toplevel.%s.chromosome.$seq_name.fa";
	#info( 1, "M2: Dump into $file");
	
	if($fhs->{'dna_toplevel'} ){
	  #info(1, "M3: DNA");
	  my $seqio = Bio::SeqIO->new('-format' => 'Fasta', 
				   '-file'   =>  sprintf ($file, "dna"));
	  dump_dna( $seqio, $slice, 'dna' );

	  # Need to add these so they are closed and gzipped
	  $fhs->{"$chr_toplevel.dna.chromosome.$seq_name.fa"} = $seqio;
	}

	if($fhs->{'dna_toplevel_masked'} ){
	  #info (1, "M4: DNA");
	  my $seqio_masked = Bio::SeqIO->new('-format' => 'Fasta', 
					  '-file' => sprintf ($file,"dna_rm"));
	  #dump_dna( $seqio_masked, $slice->get_repeatmasked_seq, 'dna_rm' );
	  #dump_dna( $seqio_masked, $slice->get_repeatmasked_seq([('RepeatMask','Dust','TRF','Mono_sup_RepeatMask')]), 'dna_rm' );
	  dump_dna_masked( $seqio_masked, $slice, mask_sequence($slice), 'dna_rm' );

	  # Need to add these so they are closed and gzipped
	  $fhs->{"$chr_toplevel.dna_rm.chromosome.$seq_name.fa"} = $seqio_masked;
	}
      }
    }
    # End dna_toplevel (masked and not masked) ------------------------------
    if(scalar( grep{$_ !~ /^dna|abinitio|\/dna\// } keys %$fhs ))  {
      if(!defined($minimise_memory)){
	foreach my $gene( @{$slice->get_all_Genes(undef,undef,$load_exons)} ){
	  foreach my $transcript( @{$gene->get_all_Transcripts} ){
	    my $logic_name = lc($gene->analysis->logic_name);
	    my $subtype;
	    my $ccds = "";
	    if   ( $logic_name =~/ncrna/)     { $subtype = 'ncrna';}
	    elsif( ! $transcript->translation ){ $subtype = 'pseudogene' }
	    elsif( $transcript->is_known   ){ $subtype = 'known'      }
	    else                            { $subtype = 'novel'      }
	    
	    if ($logic_name eq 'pseudogene' && $subtype ne 'pseudogene') {
	      warning(1, "Logic name is set to pseudogene, but transcript has translation:".$transcript->translation);
	    }
	    # If it is a ccds, $subtype = ccds instead
	    if( $transcript->translation ) {
	      foreach my $xref ( @{$transcript->translation->get_all_DBEntries} ) {
		if ($xref->database eq 'CCDS') {
		  $subtype = "known-ccds";
		  $ccds =   $xref->primary_id . '.' . $xref->version;
		  if( my $seqio = $fhs->{'cdna_known-ccds'} ){
		    dump_cdna_rna($seqio, $transcript, "cdna:$subtype", $gene, $ccds);
		  }
		  if( my $seqio = $fhs->{'pep_known-ccds'} and $subtype eq 'known-ccds' ){
		    dump_pep( $seqio, $transcript, "pep:$subtype", $gene, $ccds);
		  }
		}
	      }
	    }
	    if( ( my $seqio = $fhs->{'cdna'} and $subtype ne 'ncrna') ) {
	      dump_cdna_rna( $seqio, $transcript, "cdna:$subtype", $gene, $ccds);
	    }
	    if( my $seqio = $fhs->{'cdna_known'} and $subtype eq 'known' ){
	      dump_cdna_rna( $seqio, $transcript, 'cdna:known', $gene);
	    }
	    if( my $seqio = $fhs->{'cdna_pseudo'} and $subtype eq 'pseudogene' ){
	      dump_cdna_rna( $seqio, $transcript, 'cdna:pseudogene', $gene);
	    }
	    if( my $seqio = $fhs->{'cdna_novel'} and $subtype eq 'novel' ){
	    dump_cdna_rna( $seqio, $transcript, 'cdna:novel', $gene);
	  }
	    
	    if( my $seqio = $fhs->{'pep'} and $subtype ne 'pseudogene'
		and $subtype ne 'ncrna'){
	      dump_pep( $seqio, $transcript, "pep:$subtype", $gene, $ccds);
	    }
	    if( my $seqio = $fhs->{'pep_known'} and $subtype eq 'known' ){
	      dump_pep( $seqio, $transcript, 'pep:known', $gene);
	    }
	    if( my $seqio = $fhs->{'pep_novel'} and $subtype eq 'novel' ){
	      dump_pep( $seqio, $transcript, 'pep:novel', $gene);
	    }
	    
	    if( ( my $seqio = $fhs->{'rna'} and $subtype eq 'ncrna' ) ) {
	      $subtype = $gene->biotype;
	      dump_cdna_rna( $seqio, $transcript, "$logic_name:$subtype",$gene);
	    }

	  }
	}
      }
    }
    # Abinitio dumps ----------------------------------------------------------
    #info (1, "Abinitio section");
    if ( scalar (grep {$_ =~ /_abinitio/ } keys %$fhs ))  {
      foreach my $transcript( @{$slice->get_all_PredictionTranscripts(undef,$load_exons)} ){
	my $subtype = $transcript->analysis->logic_name;
	if( my $seqio = $fhs->{'cdna_abinitio'} ){
	  dump_cdna_rna( $seqio, $transcript, "cdna:$subtype" );
	}
	if( my $seqio = $fhs->{'pep_abinitio'} ){
	  warning(1, "No translation for transcript:". $transcript->stable_id )
	    && next unless $transcript->translation;
	  dump_pep( $seqio, $transcript, "pep:$subtype" );
	}
      }
    }

    # DNA seqlevel dumps -----------------------------------------------------
    #info (1, "DNA seq level section");
    if ( scalar( grep {$_ =~ /^dna_seqlevel/ } keys %$fhs ) ) {
      foreach my $segment( @{$slice->project('seqlevel')} ){
	my $coord_system = $slice->coord_system;
	my $location = join( ':', 
			     $coord_system->name,
			     $coord_system->version,
			     $slice->seq_region_name,
			     $segment->from_start,
			     $segment->from_end,
			     $segment->to_Slice->strand );
	
	if( my $seqio = $fhs->{'dna_seqlevel'} ){
	  dump_dna( $seqio, $segment->to_Slice, 'dna:seqlevel', $location );
	}
	if( my $seqio = $fhs->{'dna_seqlevel_masked'} ){
	  dump_dna( $seqio, $segment->to_Slice->get_repeatmasked_seq,
		     'dna_rm:seqlevel', $location );
	}
      }
    }
    #info( 1, "End toplevel ". $slice->name );
  }
  if($minimise_memory){
    my @gene_ids = @{$gene_adaptor->list_dbIDs()};
    info( 1, "dumping the data for ".scalar(@gene_ids)." genes" );
    foreach my $gene_id ( @gene_ids ){
      my $gene = $gene_adaptor->fetch_by_dbID($gene_id);
      foreach my $transcript( @{$gene->get_all_Transcripts} ){
	my $logic_name = lc($gene->analysis->logic_name);
	my $subtype;
	my $ccds = "";
	if   ( $logic_name =~/ncrna/)     { $subtype = 'ncrna';}
	elsif( ! $transcript->translation ){ $subtype = 'pseudogene' }
	elsif( $transcript->is_known   ){ $subtype = 'known'      }
	else                            { $subtype = 'novel'      }
	
	if ($logic_name eq 'pseudogene' && $subtype ne 'pseudogene') {
	  warning(1, "Logic name is set to pseudogene, but transcript has translation:".$transcript->translation);
	}
	# If it is a ccds, $subtype = ccds instead
	if( $transcript->translation ) {
	  foreach my $xref ( @{$transcript->translation->get_all_DBEntries} ) {
	    if ($xref->database eq 'CCDS') {
	      $subtype = "known-ccds";
	      $ccds =   $xref->primary_id . '.' . $xref->version;
	      if( my $seqio = $fhs->{'cdna_known-ccds'} ){
		dump_cdna_rna($seqio, $transcript, "cdna:$subtype", $gene, $ccds);
	      }
	      if( my $seqio = $fhs->{'pep_known-ccds'} and $subtype eq 'known-ccds' ){
		dump_pep( $seqio, $transcript, "pep:$subtype", $gene, $ccds);
	      }
	    }
	  }
	}
	if( ( my $seqio = $fhs->{'cdna'} and $subtype ne 'ncrna') ) {
	  dump_cdna_rna( $seqio, $transcript, "cdna:$subtype", $gene, $ccds);
	}
	if( my $seqio = $fhs->{'cdna_known'} and $subtype eq 'known' ){
	  dump_cdna_rna( $seqio, $transcript, 'cdna:known', $gene);
	}
	if( my $seqio = $fhs->{'cdna_pseudo'} and $subtype eq 'pseudogene' ){
	  dump_cdna_rna( $seqio, $transcript, 'cdna:pseudogene', $gene);
	}
	if( my $seqio = $fhs->{'cdna_novel'} and $subtype eq 'novel' ){
	  dump_cdna_rna( $seqio, $transcript, 'cdna:novel', $gene);
	}
	
	if( my $seqio = $fhs->{'pep'} and $subtype ne 'pseudogene'
	    and $subtype ne 'ncrna'){
	  dump_pep( $seqio, $transcript, "pep:$subtype", $gene, $ccds);
	}
	if( my $seqio = $fhs->{'pep_known'} and $subtype eq 'known' ){
	  dump_pep( $seqio, $transcript, 'pep:known', $gene);
	}
	if( my $seqio = $fhs->{'pep_novel'} and $subtype eq 'novel' ){
	  dump_pep( $seqio, $transcript, 'pep:novel', $gene);
	}
	
	if( ( my $seqio = $fhs->{'rna'} and $subtype eq 'ncrna' ) ) {
	  $subtype = $gene->biotype;
	  dump_cdna_rna( $seqio, $transcript, "$logic_name:$subtype",$gene);
	}
	
      }
    }
  }

  # Close all file handles ----------------------------------------------------
  foreach my $type (keys %$fhs) {
    my $seqio = $fhs->{$type};
    my $file = $seqio->file;
    $file =~ s/^>//;
    $file    || ( warning( 1, "Dump type $type has no filename" ) && next );
    -e $file || ( info( 1, "File $file ($type) does not exist" ) && next );
    if( -z $file ){ #Empty file
      unlink $file || warn "Can't delete $file: $!";
      info(1, "Deleting empty file $file");
      undef( $fhs->{$type} );
    }
  }
  return ($fhs);
}


#------------------------------------------------------------------------------
#FORMAT >STABLE_ID TYPE:SUBTYPE TOPLEVEL:SLICE_NAME gene:genename
#>ENST00000289823 cdna:known chromosome:NCBI34:8:21922367:21927699:1
#gene:ENSG00000158815

sub dump_cdna_rna {
  my( $seqio, $transcript, $type, $gene, $ccds_id) = @_;
  return if $NODATA;
  $ccds_id ||= " ";
  my $coord_system = $transcript->slice->coord_system;
  my $location = join( ':', 
                       $coord_system->name,
                       $coord_system->version,
                       $transcript->seq_region_name,
                       $transcript->seq_region_start,
                       $transcript->seq_region_end,
                       $transcript->seq_region_strand );

  my $label = $gene ? "gene:".$gene->stable_id : " ";
  my $seq = $transcript->seq();
  $seq->description( join( " ", $type, $location, $label, $ccds_id) );
  #info( 1, "CDNA>".$seq->display_id );
  $seqio->write_seq($seq);
  return 1;
}

#------------------------------------------------------------------------------
#>ENSP00000328693 pep:novel chromosome:NCBI34:1:904515:910768:1
#>gene:ENSG00000158815:transcript:ENST00000328693
sub dump_pep {
  my ($seqio, $transcript, $type, $gene, $ccds_id) = @_;
  return if $NODATA;
  $ccds_id ||= " ";
  my $translation = $transcript->translation;
  if( ! $translation ){

    # Print if this is pseudogene -> logic of script must be faulty cos shouldnt get here if pseudo
    warning( 1, "Transcript ".$transcript->stable_id." does not translate" );
    return;
  }
  my $coord_system = $transcript->slice->coord_system;
  my $location = join( ':', 
                       $coord_system->name,
                       $coord_system->version,
                       $transcript->seq_region_name,
                       $transcript->seq_region_start,
                       $transcript->seq_region_end,
                       $transcript->seq_region_strand );

  my $display_id = $translation->stable_id || $transcript->stable_id;
  my $label;
  $label = "gene:".$gene->stable_id if $gene;
  $label .=" transcript:".$transcript->stable_id;

  my $seq = $transcript->translate;
  unless ($seq) {
    warning (1, "No seq for Transcript ".$transcript->stable_id);
    return 1;
  }
  $seq->display_id( $display_id );
  $seq->description( join( " ", $type, $location, $label, $ccds_id) );
  #info( 1, "PEP>type:$type ".$seq->display_id );
  $seqio->write_seq($seq);
  return 1;
}

#----------------------------------------------------------------------
sub dump_dna{
  my ($seqio, $slice, $type_str, $location) = @_;
  return if $NODATA;

  # Force slice onto forward strand
  if( $slice->strand < 1 ){ $slice = $slice->invert }

  $location ||= $slice->name;
  my ($type, $subtype) = split(':', $type_str);

  my $pad_start = 'N' x ( $slice->start - 1 );
  my $pad_end   = 'N' x ( $slice->seq_region_length - $slice->end );

  my $seq = new Bio::Seq
    ( -seq         => $pad_start . $slice->seq() . $pad_end,
      -display_id  => $slice->seq_region_name );
  $seq->description( "$type:". $slice->coord_system->name(). " $location" );
  #info( 1, "DNA>".$seq->display_id );

  $seqio->write_seq($seq);
  return 1;
}

sub dump_dna_masked{
  my ($seqio, $slice, $seqstr, $type_str, $location) = @_;
  return if $NODATA;

  # Force slice onto forward strand
  if( $slice->strand < 1 ){ $slice = $slice->invert }

  $location ||= $slice->name;
  my ($type, $subtype) = split(':', $type_str);

  my $pad_start = 'N' x ( $slice->start - 1 );
  my $pad_end   = 'N' x ( $slice->seq_region_length - $slice->end );

  my $seq = new Bio::Seq
    ( -seq         => $pad_start . $seqstr . $pad_end,
      -display_id  => $slice->seq_region_name );
  $seq->description( "$type:". $slice->coord_system->name(). " $location" );
  #info( 1, "DNA>".$seq->display_id );

  $seqio->write_seq($seq);
  return 1;
}

#------------------------------------------------------------------------------
sub blast_indexes {
  my $created_files = shift;
  info (1, "Creating blast indexes");
  
  my $dna_command = "/usr/local/pubseq/bin/pressdb";
  my $pep_command = "/usr/local/pubseq/bin/setdb";
  my $machine = "blastsrv11";
  my $release_dir = "release$release";
  
  foreach my $types (keys %$created_files) {
     next unless $types =~ /^dna_seqlevel|^cdna|^pep|^ncrna/;
     my $seqio = $created_files->{$types};
     next unless $seqio;
     my $fh = $seqio->file;
     $fh =~ s/^>//;
     my $command = $types=~/^pep/ ? $pep_command : $dna_command;
     system("$pep_command $fh");

     foreach my $index (".atb", ".ahd", ".bsq", "" ) {
        my $file = "$fh$index";
        (my $file_name = $file) =~ s#.*/##;
        warning(1, "Error producing file $file") && next unless -s "$file";
        system("scp -i /nfs/WWW/.ssh/blastsrv $file $machine:/data/blastdb/ensembl/$release_dir/$file_name");
        unlink($file) || warn "Can't delete $file: $!" unless $file eq $fh;
     }
  }

}
#-----------------------------------------------------------------------------

sub compress{
  my $created_files = shift;
  info( 1, "Gzipping fasta files");

  foreach my $types (keys %$created_files) {
    my $seqio = $created_files->{$types};
    next unless $seqio;
    my $fh = $seqio->file;
    $fh =~ s/^>//;
    info(1, "zipping $fh");
    next unless (-e "$fh");

    my $size = -s $fh;
    if ($size > 900000000 ){
      split_data($fh);
    }
    else {
      system("gzip $fh") ==0 or warning(1, "Can't gzip file $! $fh");
    }
  }
}

#----------------------------------------------------------------------
sub info{
  my $v   = shift;
  my $msg = shift;
  if( ! defined($msg) ){ $msg = $v; $v = 0 }
  $msg || ( carp("Need a warning message" ) && return );

  warn( sprintf "[INFO] %s [%0.3fs]\n", $msg, time()- $script_start_time );
  # warn( sprintf "[INFO] %s [%0.3fs %d]\n", $msg, time()- $script_start_time, &process_size );
  return 1;
}

#----------------------------------------------------------------------
sub warning{
  my $v   = shift;
  my $msg = shift;
  if( ! defined($msg) ){ $msg = $v; $v = 0 }
  $msg || ( carp("Need a warning message" ) && return );

  warn( sprintf "[WARN] %s [%0.3fs]\n", $msg, time()- $script_start_time );
  # warn( sprintf "[WARN] %s [%0.3fs %d]\n", $msg, time()- $script_start_time, &process_size );
  return 1;
}

#----------------------------------------------------------------------
# # Quick+dirty method of trapping STDERR
# sub TIEHANDLE{
#   my $class = shift;
#   bless {}, $class;
# }
# sub PRINT {
#   my $self = shift;
#   # Do nothing!;
# }
#----------------------------------------------------------------------

sub split_data {
  my ($file) = @_;
  my $chunk = 0;
  my $bytes = 0;
  my $name = $file;
  $name =~ s/\.(.*)//;
  my $ext = $1;

  open (IN, "$file") or die "Can't open infile $file: $!\n";
  open (OUT, ">$name.$chunk.$ext") 
    or die "Can't create ${name}.${chunk}.$ext: $!\n";

  # Core dna file compression ~66%, RefSNP table = 75%
  # Feature dna compression = 88 %
  info("Creating ${name}.${chunk}.$ext"); 
  while(<IN>){
    $bytes += length $_;
    if ($bytes > 3500000000){
      print OUT $_;
      close (OUT);
      system ("gzip $name.$chunk.$ext"); # gzip file

      # Prepare and open next file
      $chunk++;
      open (OUT, ">$name.$chunk.$ext") or die "Can't create ${name}.${chunk}.txt.table: $!\n";

      info ("Creating  ${name}.${chunk}.$ext"); 
      $bytes = 0;
    }
    else{
      print OUT $_;
    }
  }
  system ("gzip $name.$chunk.$ext"); # gzip file
  close(IN);
  close OUT;
  unlink $file;
}

#------------------------------------------------------------------------
sub readme {
  my $key = shift;

  # Text for readme files

my %text = (
dna => "
#######################
Fasta DNA dumps
#######################

-----------
FILE NAMES
------------
The files are consistently named following this pattern:
   <species>.<assembly>.<release>.<sequence type>.<id type>.<id>.fa.gz

<species>: The systematic name of the species. 
<assembly>: The assembly build name.
<release>: The release number. 
<sequence type>
    * 'dna' - unmasked genomic DNA sequences.
    * 'dna_rm' - masked genomic DNA.  Interspersed repeats and low 
       complexity regions are detected with the RepeatMasker tool and masked
       by replacing repeats with 'N's.
<id type> One of the following:
    * 'chromosome' - The top-level coordinate system in most species in Ensembl
    * 'nonchromosomal' - Contains DNA that has not been assigned a chromosome
    * 'seqlevel' - This is usually sequence scaffolds, chunks or clones. 
     -- 'scaffold'  - Larger sequence contigs from the assembly of shorter
      sequencing reads (often from whole genome shotgun, WGS) which could 
      not yet be assembled into chromosomes. Often more genome sequencing 
      is needed to narrow gaps and establish a tiling path.
     -- 'chunk' -  While contig sequences can be assembled into large entities, 
      they sometimes have to be artificially broken down into smaller entities 
      called 'chunks'. This is due to limitations in the annotation
      pipeline and the finite record size imposed by MySQL which stores the
      sequence and annotation information.
    -- 'clone' - In general this is the smallest sequence entity.  It is often
       identical to the sequence of one BAC clone, or sequence region 
       of one BAC clone which forms the tiling path. 
<id>: The actual sequence identifier. Depending on the <id type> the <id>
    could represent the name of a chromosome, a scaffold, a contig, a clone ..
     Field is empty for seqlevel files
fa : All files in these directories represent FASTA database files
gz : All files are compacted with GNU Zip for storage efficiency.

-----------
TOPLEVEL
----------
These files contain the full sequence of the assembly in fasta format.  
They contain one chromosome per file. 

EXAMPLES
     The genomic sequence of human chromosome 1:
       Homo_sapiens.NCBI36.40.dna.chromosome.1.fa.gz

     The masked version of the genome sequence on human chromosome 1 
     (contains '_rm' in the name):
        Homo_sapiens.NCBI36.40.dna_rm.chromosome.1.fa.gz

     Non-chromosomal assembly sequences:
     e.g. mitochondrial genome, sequence contigs not yet mapped on chromosomes
       Homo_sapiens.NCBI36.40.dna.nonchromosomal.fa.gz
       Homo_sapiens.NCBI36.40.dna_rm.nonchromosomal.fa.gz


-----------------
SEQUENCE LEVEL
------------------
These files are fasta file dumps of the assembly at the sequence level.

EXAMPLES
   Format:   <species>.<assembly>.<release>.<sequence type>.seqlevel.fa.gz

Unmasked sequence file name example (until release 39):
       Homo_sapiens.NCBI34.dna.contig.fa.gz
       Anopheles_gambiae.MOZ2a.dna.chunk.fa.gz
       Fugu_rubripes.FUGU2.dna.scaffold.fa.gz
       Saccharomyces_cerevisiae.SGD1.oct.dna.chromosome.fa.gz

Repeat masked file example (contain '_rm' in the file name) (until release 39);
      Homo_sapiens.NCBI34.dna_rm.contig.fa.gz
      Anopheles_gambiae.MOZ2a.dna_rm.chunk.fa.gz
      Fugu_rubripes.FUGU2.dna_rm.scaffold.fa.gz
      Saccharomyces_cerevisiae.SGD1.oct.dna_rm.chromosome.fa.gz

Now all of these contain 'seqlevel' in the file names e.g. 
       Homo_sapiens.NCBI36.40.dna.seqlevel.fa.gz
       Anopheles_gambiae.MOZ2a.40.dna_rm.seqlevel.fa.gz
       Fugu_rubripes.FUGU2.40.dna.seqlevel.fa.gz
       Saccharomyces_cerevisiae.SGD1.40.dna_rm.seqlevel.fa.gz

Note that the type of sequence container varies in different species: 
contigs in human, chunks in Anopheles, scaffolds in Fugu.\n\n",



pep => "
####################
Fasta Peptide dumps
####################

These files hold the protein translations of Ensembl gene predictions.

-----------
FILE NAMES
------------
The files are consistently named following this pattern:
   <species>.<assembly>.<release>.<sequence type>.<status>.fa.gz

<species>: The systematic name of the species. 
<assembly>: The assembly build name.
<release>: The release number. 
<sequence type>: pep for peptide sequences
<status>
    * 'pep.all' - the super-set of all translations resulting from Ensembl known
       or novel gene predictions.
    * 'pep.known' - translations of Ensembl known gene predictions 
       (see more below).  Any ccds_known peptides are in 'pep.known-ccds'.
    * 'pep.novel' - translations of Ensembl novel gene predictions 
       (see more below)
    * 'pep.abinitio' translations resulting from 'ab initio' gene 
       prediction algorithms such as SNAP and GENSCAN. In general, all
      'ab initio' predictions are based solely on the genomic sequence and 
       not any other experimental evidence. Therefore, not all GENSCAN
       or SNAP predictions represent biologically real proteins. 
    * 'pep.known-ccds' -  not present in all species (see more below)
fa : All files in these directories represent FASTA database files
gz : All files are compacted with GNU Zip for storage efficiency.

EXAMPLES (Note: Most species do not sequences for each different <status>)
 for Human:
      Homo_sapiens.NCBI36.40.pep.all.fa.gz
            contains all known, ccds and novel peptides
      Homo_sapiens.NCBI36.40.pep.known-ccds.fa.gz
            contains all 'ccds' peptide sequences (see below).
      Homo_sapiens.NCBI36.40.pep.known.fa.gz
            contains all known peptides (excluding the ccds peptides)
      Homo_sapiens.NCBI36.40.pep.novel.fa.gz
            contains all novel peptides
      Homo_sapiens.NCBI36.40.pep.abinitio.fa.gz
            contains all abinitio predicted peptide


CCDS sequences
--------------
'ccds' - The Consensus Coding Sequence (CCDS) project is a collaborative 
effort to identify a core set of human protein coding regions that are 
consistently annotated and of high quality. Initial results from the 
CCDS project are now available through the appropriate Ensembl gene 
pages and from the CCDS project page at NCBI. More information is 
available from the Ensembl CCDS page (www.ensembl.org/Homo_sapiens/ccds.html).


Difference between known and novel
----------------------------------
Protein models that can be mapped to species-specific entries in
Swiss-Prot, RefSeq or SPTrEMBL are referred to in Ensembl as
known genes.  Those that cannot be mapped are called novel 
(e.g. genes predicted on the basis of evidence from closely related species).



-------------------------------
FASTA Sequence Header Lines
------------------------------
The FASTA sequence header lines are designed to be consistent across 
all types of Ensembl FASTA sequences.  This gives enough information 
for the sequence to be identified outside the context of the FASTA 
database file. 

General format:

>ID SEQTYPE:STATUS LOCATION GENE TRANSCRIPT

Example of Ensembl Peptide header:

>ENSP00000328693 pep:novel chromosome:NCBI35:1:904515:910768:1 gene:ENSG00000158815:transcript:ENST00000328693
   ^               ^    ^      ^                                 ^                    ^
   ID              |    |      LOCATION                          GENE:stable gene ID  |
                   |    STATUS                                                        TRANSCRIPT: stable transcript ID
                   SEQTYPE
\n",



cdna => "
##################
Fasta cDNA dumps
#################

These files hold the cDNA sequences corresponding to Ensembl gene predictions.

------------
FILE NAMES
------------
The files are consistently named following this pattern:
<species>.<assembly>.<release>.<sequence type>.<status>.fa.gz

<species>: The systematic name of the species. 
<assembly>: The assembly build name.
<release>: The release number. 
<sequence type>: cdna for cDNA sequences
<status>
    * 'cdna.all' - the super-set of all transcripts resulting from 
       Ensembl known, novel and pseudo gene predictions (see more below).
    * 'cdna.known'    - transcripts from Ensembl known gene predictions only 
      (see more below).  This set does not include ccds cDNAs.
    * 'cdna.novel'    - transcripts from Ensembl novel gene predictions only 
      (see more below).
    * 'cdna.pseudo'   - transcripts from Ensembl pseudogene predictions.
    * 'cdna.abinitio' - transcripts resulting from 'ab initio' gene prediction 
       algorithms such as SNAP and GENSCAN. In general all 'ab initio' 
       predictions are solely based on the genomic sequence and do not 
       use other experimental evidence. Therefore, not all GENSCAN or SNAP 
       cDNA predictions represent biologically real cDNAs. 
       Consequently, these predictions should be used with care.
    * 'cdna.known-ccds' -  not present in all species (see more below)


EXAMPLES  (Note: Most species do not sequences for each different <status>)
  for Human:
      Homo_sapiens.NCBI36.40.cdna.all.fa.gz
            cDNA sequences for all transcripts: known, ccds, novel and pseudo
      Homo_sapiens.NCBI36.40.cdna.known-ccds.fa.gz
            cDNA sequences for 'ccds' sequences (see below).
      Homo_sapiens.NCBI36.40.cdna.known.fa.gz
            cDNA sequences for transcripts flagged as 'known' (excluding ccds transcripts).
      Homo_sapiens.NCBI36.40.cdna.novel.fa.gz
            cDNA sequences for transcripts flagged as 'novel'.
      Homo_sapiens.NCBI36.40.cdna.pseudo.fa.gz
            cDNA sequences for transcripts flagged as 'pseudogene'.
      Homo_sapiens.NCBI36.40.cdna.abinitio.fa.gz
            cDNA sequences for 'ab-initio' prediction transcripts.



CCDS sequences
--------------
'ccds' - The Consensus Coding Sequence (CCDS) project is a collaborative 
effort to identify a core set of human protein coding regions that are 
consistently annotated and of high quality. Initial results from the 
CCDS project are now available through the appropriate Ensembl gene 
pages and from the CCDS project page at NCBI. More information is 
available from the Ensembl CCDS page (www.ensembl.org/Homo_sapiens/ccds.html).


Difference between known and novel transcripts
-----------------------------------------------
Transcript or protein models that can be mapped to species-specific entries 
in Swiss-Prot, RefSeq or SPTrEMBL are referred to as known genes in Ensembl.  
Those that cannot be mapped are called novel genes (e.g. genes predicted on 
the basis of evidence from closely related species).


-------------------------------
FASTA Sequence Header Lines
------------------------------
The FASTA sequence header lines are designed to be consistent across 
all types of Ensembl FASTA sequences.  This gives enough information 
for the sequence to be identified outside the context of the FASTA file. 

General format:

>ID SEQTYPE:STATUS LOCATION GENE

Example of an Ensembl cDNA header:

>ENST00000289823 cdna:known chromosome:NCBI35:8:21922367:21927699:1 gene:ENSG00000158815
 ^               ^    ^      ^                                        ^
 ID              |    |      LOCATION                                 GENE: gene stable ID
                 |    STATUS
                 SEQTYPE

\n", 




ncrna => "
##################
Fasta RNA dumps
#################

These files hold the transcript sequences corresponding to non-coding RNA genes (ncRNA).

------------
FILE NAMES
------------
The files are consistently named following this pattern:
<species>.<assembly>.<release>.<sequence type>.<status>.fa.gz

<species>: The systematic name of the species. 
<assembly>: The assembly build name.
<release>: The release number. 
<sequence type>: ncrna for non-coding RNA sequences
<status>
    * 'ncrna' - all non-coding RNA genes

EXAMPLES
  for Human:
      Homo_sapiens.NCBI36.40.rna.nc.fa.gz
          Transcript sequences for all ncRNA gene types.


-------------------------------
FASTA Sequence Header Lines
------------------------------
The FASTA sequence header lines are designed to be consistent across 
all types of Ensembl FASTA sequences.  This gives enough information 
for the sequence to be identified outside the context of the FASTA file. 

General format:

>ID SEQTYPE:STATUS LOCATION GENE

Example of an Ensembl RNA header:

>ENST00000347977 ncrna:miRNA chromosome:NCBI35:1:217347790:217347874:-1 gene:ENSG00000195671
   ^               ^    ^      ^                                        ^
   ID              |    |      LOCATION                                 GENE: gene stable ID
                 |    STATUS
                 SEQTYPE

\n",  );

my $warning = "#### README ####

IMPORTANT: Please note you can download correlation data tables, 
supported by Ensembl, via the highly customisable BioMart and 
EnsMart data mining tools. See http://www.ensembl.org/multi/martview or
http://www.ebi.ac.uk/biomart/ for more information.

";
return ($warning .$text{$key});
}

sub process_size {
  my $size = `ps $$ -o vsz |tail -1`;
  chomp $size;
  my $unit = chop $size;
  #if ($unit eq "K") do nothing, we want size in Kb
  if ($unit eq "M"){
    $size *= 1024;
  } elsif ($unit eq "G"){
    $size *= 1048576;   # 1024*1024
  }
  return $size;
}

sub mask_sequence {
  my ($slice,$logic_names) = (@_);


  my $seq_region = $slice->seq_region_name;

  my $chunk_start = $slice->start;
  my $chunk_size  = 10000000;
  my $chunk_end   = $chunk_start + $chunk_size-1;

  if ($chunk_end > $slice->end) {
    $chunk_end = $slice->end;
  }

  my $slice_seq;

  while ($chunk_start <= $slice->end) {
    my $chunk_slice_name = $slice->coord_system->name . ":" .$slice->coord_system->version . ":" .$slice->seq_region_name . ":" . $chunk_start . ":" . $chunk_end . ":1";

    #print STDERR " Chunk slice name = $chunk_slice_name\n";

    my $chunk_slice = $slice->adaptor->fetch_by_name($chunk_slice_name);
    
#    foreach my $lname (@$logic_names) {
#      my $rfs = $chunk_slice->get_all_RepeatFeatures($lname);
#      foreach my $old_f (@$rfs) {
#        my $f = $old_f->transfer( $slice );
#        $padstr = 'N' x $length;
#        
#      }
#
#    }

    my $chunk_seq =  $chunk_slice->get_repeatmasked_seq($logic_names)->seq;

    $slice_seq .= $chunk_seq;

    $chunk_start += $chunk_size;
    $chunk_end   += $chunk_size;
    if ($chunk_end > $slice->end) {
      $chunk_end = $slice->end;
    }
  }

 # if (CORE::length($slice_seq) != $slice->length) {
 #   print STDERR "Length difference for slice sequence\n";
 # }

  return $slice_seq;
}

1;


__END__

# date 10.5.05

=head1 NAME

do_fasta_dumps - Dump Ensembl databases to text files and gzip them

=head1 SYNOPSIS

do_fasta_dumps [options]

Options:
  --help, --info, --verbose, --dumpdir, --no_log, --email
  --species, --database, --type --no_data --logfile --minimise_memory 

Example:
 nohup time ./do_fasta_dump --type all --release 23 --email ek3@sanger.ac.uk


=head1 REQUIRED ARGUMENTS

B<--type>
  One or more feature type to dump. See --info for more details

B<--release>
  The current Ensembl release number.  This is used to check the species ini file configufation.


=head1 OPTIONS

B<-h,--help>
  Prints a brief help message and exits.

B<-i,--info>
  Prints man page and exits.

B<--no_data>
  Runs the script without dumping the data (i.e. goes through each top level, creates and zips the files but with no data in them)

B<--email>
   Sends an email to this address if you use a log file

B<-v,--verbose>
  Set verbosity level for debug output to stdout or no_log. Default 1

B<--dumpdir>
  Specifies directory to dump into (def /mysql/dumps/FTP)

b<--logfile>
  Choose the name of your logfile. The default is "fasta<release_number>timestamp.log".

B<--no_log>
  Output to standard out (STDOUT). Default is to use a log file.

B<-s, --species>
  One or more species to dump.  Default: All species

B<-d, --database>
  One or more databases to dump (ENSEMBL_DB, ENSEMBL_VEGA etc.). 
  Defaults to ENSEMBL_DB.

B<--no_compress>
  Specify no gzip compression of dumped files.

B<--no_indexes>
  Turns off generation of blast database index files

B<--minimise_memory>
  Reduces the memory usage but the dump time will increase.

=head1 DESCRIPTION

B<This program:>

Dumps Ensembl databases to flatfiles.

Output may include the following:

B<  [DIE*]:> Program critical error, dumps have halted.

B<  [WARN]:> Program has encountered an error but is still running, 
          dumps may have been affected.

B<  [INFO]>: Non-critical message, dumping should continue as normal.

More on --type: Valid options are:

B<  all:> dna, cdna, pep and rna

B<  rna>; DNA sequences that give non-coding RNA (ncRNA) in the specified DB.

B<  blast>; dna_seqlevel, dna_seqlevel_masked, cdna_all, rna_all and pep_all

B<  pre>; dna_toplevel, dna_seqlevel, dna_seqlevel_masked, cdna_all, rna_all and pep_all

B<  dna:> dna_seqlevel, dna_seqlevel_masked, dna_toplevel and dna_toplevel__masked.

B<  dna_seqlevel:> All DNA sequences at the 'seqlevel' coordinate system.

B<  dna_seqlevel_masked:> The above, but repeatmasked.

B<  dna_toplevel:> All DNA sequences at the 'toplevel' coordinate system.

B<  dna_toplevel_masked:> The above, but repeatmasked.

B<  cdna>; cdna, cdna_known, cdna_novel, cdna_psuedogenes, cdna_abinitio.

B<  cdna_all>; All cDNA sequences for Transcripts in the specified DB.

B<  cdna_known>; cDNA sequences for Transcripts flagged as 'known'.

B<  cdna_novel>; cDNA sequences for Transcripts flagged as 'novel'.

B<  cdna_pseudo>; cDNA sequences for Transcripts flagged as 'pseudogene'.

B<  cdna_known-ccds>; known cDNA sequences for Transcripts with an xref of 'CCDS'

B<  cdna_abinitio>;  cDNA sequences for 'ab-initio' PredictionTranscripts.

B<  pep>; pep_known, pep_novel and pep_abinitio

B<  pep_all>; All Peptide sequences for Transcripts in the specified DB.

B<  pep_known>; Peptide sequences for Transcripts flagged as 'known'.

B<  pep_novel>; Peptide sequences for Transcripts flagged as 'novel'.

B<  pep_known-ccds>; Known peptide sequences for Transcripts with an xref of 'CCDS'

B<  pep_abinitio>; Peptide sequences for 'ab-initio' PredictionTranscripts.



Maintained by Fiona Cunningham, Ensembl web team <webmaster@ensembl.org>

=cut

