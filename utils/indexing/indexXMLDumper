#! /usr/bin/env perl

# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
# Copyright [2016-2018] EMBL-European Bioinformatics Institute
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#      http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

use strict;

package indexXMLDumper;

use FindBin qw($Bin);
use Storable qw(retrieve);

use DBI;
use XML::Parser;
use Data::Dumper;
use Getopt::Long;
use POSIX qw(strftime);
use HTML::TreeBuilder;
use Digest::MD5 qw(md5_hex);
use Fcntl;
use DB_File;
use SDBM_File;
use Encode qw(decode encode);

my $CONF = retrieve("$Bin/dumper.sconf");

my $SD = $CONF->{'SiteDefs'};
my $PD = $CONF->{'packed'};

# Make species also available by production name, build datasets
my $ENSEMBL_DATASETS = [];
foreach my $url (keys %$PD) {
  next unless ref($PD->{$url}) eq 'HASH';
  next unless $PD->{$url}{'SPECIES_PRODUCTION_NAME'};
  next unless grep { $_ eq $PD->{$url}{'SPECIES_PRODUCTION_NAME'} } @{$SD->{'PRODUCTION_NAMES'}};
  push @$ENSEMBL_DATASETS,$url;
  $PD->{$PD->{$url}{'SPECIES_PRODUCTION_NAME'}} = $PD->{$url};
}
print "There are ".scalar(@$ENSEMBL_DATASETS)." species\n";

$| = 1;

my $tmpdir = '.';

my ($species_list,$ignore_species_list,$indexes_list,$ignore_indexes_list,$create_elevate,$do_private,$debug,$log,$dir,$check_xml,$help,$array);
GetOptions('species=s'        => \$species_list,
           'ignore_species=s' => \$ignore_species_list,
           'index|indices=s'  => \$indexes_list,
           'ignore_index=s'   => \$ignore_indexes_list,
           'create_elevate'   => \$create_elevate,
           'do_private'       => \$do_private,
           'debug'            => \$debug,
           'log=s'            => \$log,
           'dir=s'            => \$dir,
           'check_xml'        => \$check_xml,
     'help'             => \$help,
     'tmpdir=s'         => \$tmpdir,
     'array'        => \$array,
         );

if ($help){
  &about;
  exit;
}

my @species        = split ',',$species_list;
my @ignore_species = split ',',$ignore_species_list;
my @indexes        = split ',',$indexes_list;
my @ignore_indexes = split ',',$ignore_indexes_list;

my $release     = $SD->{'ENSEMBL_VERSION'};
my $parser      = new XML::Parser( 'ErrorContext' => 3 ); #used to check xml is well formed
my $sitetype    = $SD->{'ENSEMBL_SITETYPE'} || 'Ensembl';
my $website_url = $sitetype eq 'Vega' ? 'http://vega.sanger.ac.uk/'
                : $sitetype eq 'Pre'  ? 'http://pre.ensembl.org/'
                : 'http://www.ensembl.org';

# used to boost certain records
my $boosts = {
        'GeneTrans' => {
          'core'    => 40,
          'is_ref'  => 10,
          'non_ref' => 0,
        },
        'Family' => {
          'species' => 50,
          'ms'      => 10,
        },
        'GeneTree' => {
          'All' => 50,
        },
        'PhenotypeOntlogy' => {
          'All' => 50,
        }, 
      };

# redirect STDOUT and STDERR to a file if not in debug mode
if ($debug) {
  $log = '>-';
}
elsif(!$log) {
  my $counter = 1;
  $log =  "dumping_${release}.log";
  my $l =  $log."_".sprintf("%03d", $counter);
  while ( -e $l ) {
    $counter++;
    $l = $log."_".sprintf("%03d", $counter);
  }
  $log = $l;
}

if($array and not $debug) {
  $log .= "-$ENV{'LSB_JOBINDEX'}";
}

open (LOG, ">$log") or die "Can't open $log: $!";
LOG->autoflush(1); #normally file output is buffered but better to see output after every print
unless ($debug) {
  open (STDERR, ">&LOG") or die "Can't open $log: $!";
}

my $conf = {};

# grab all dumper methods
my @available_indexes;
foreach my $method (sort keys %indexXMLDumper::) {
  if ($method =~ s/dump(\w+)/$1/) {
    push @available_indexes, $method;
  }
}

if ($do_private) {
   print LOG "Dumping just private data\n";
  @indexes = qw(StructuralVariation Variation );
}
elsif ($indexes_list eq 'ALL'){
  @indexes = ();
  my %ignored;
  @ignored{@ignore_indexes} = ();
  foreach my $index (@available_indexes) {
    push @indexes, $index unless exists $ignored{$index};
  }
}
else {
  my @incorrect_indexes;
  foreach my $asked_for_index (@indexes) {
    unless (grep {$_ eq $asked_for_index} @available_indexes) {
      push @incorrect_indexes, $asked_for_index;
    }
  }
  if (@incorrect_indexes) {
    print LOG "WARNING - one or more of your indexes is not recognised, please check your spelling. Available ones are are:\n";
    print LOG join "\n", @available_indexes;
    exit;
  }
}

# where are xml files put on the filesystem ?
my %shards = (
  Domain              => 'ensembl_core',  
  Family              => 'ensembl_core',
  Gene                => 'ensembl_core',
  GeneTree            => 'ensembl_core',
  Marker              => 'ensembl_core',
  OligoProbe          => 'ensembl_core',
  Phenotype           => 'ensembl_core',
  RegulatoryFeature   => 'ensembl_core',
  Sequence            => 'ensembl_core',
  SomaticMutation     => 'ensembl_core',
  StructuralVariation => 'ensembl_core',
  Transcript          => 'ensembl_core',
  GenomicAlignment    => 'ensembl_ga',
  Help                => 'ensembl_core',
  Variation           => 'ensembl_variation',
);
if ($sitetype ne 'Ensembl') {
  foreach my $feature_type (keys %shards) {
    $shards{$feature_type} = lc($sitetype).'_core';
  }
}
foreach (@indexes) {
  unless ($shards{$_}) {
    print LOG "WARNING - the location of files for the $_ index is not defined, please add:\n";
    exit;
  }
}

# if the SPECIES is set to ALL grab them all from the config...
my $input_c = @species;
if( $species_list eq 'ALL' ) {
  @species = ();
  my %ignored;
  foreach my $ig (@ignore_species) {
    my $val = 0;
    $val = -1  if($ig =~ s!^<!!);
    $val = 1 if($ig =~ s!^>!!);
    @ignored{grep { ($_ cmp $ig) == $val } @{$SD->{'PRODUCTION_NAMES'}}} = ();
  }
  foreach my $sp (@{$SD->{'PRODUCTION_NAMES'}}) {
    push @species,$sp unless exists $ignored{$sp};
  }
}
else {
  if (@species ne $input_c) {
    print LOG "WARNING - one or more of your species names is not recognised, please check your spelling. Available species are:\n";
    print LOG join "\n", @{$SD->{'PRODUCTION_NAMES'}};
    print LOG "\n";
    exit;
  }
}

if($array) {
  my $index = $ENV{'LSB_JOBINDEX'}-1;
  if($index >= @species) {
    print LOG "Not that many species ($index)!\n";
    exit 0;
  }
  @species = ( $species[$index] );
  print LOG "Specialising to species $index ($species[0])\n";
}

# path to files
my $dir = $dir ? $dir : 'input';
print LOG "Dumping xml files to $dir\n";
mkdir $dir, 0777 unless -e "$dir";

my $start_time = time;
my $total_c;
my $elevate;
foreach my $index (@indexes) {
  my $loc = $do_private ? "$dir/ensembl_private/" : "$dir/".$shards{$index}."/";
  my $start = time;
  $conf->{'directory'} = $loc . lc($sitetype)."_$index";
  system( "mkdir -p $conf->{'directory'}") unless -e $conf->{'directory'};

  if ($index eq 'Variation' && ! $do_private) {
    $conf->{'directory_somatic_mutations'} = "$dir/".$shards{'SomaticMutation'}."/".lc($sitetype).'_SomaticMutation';
    system("mkdir -p $conf->{'directory_somatic_mutations'}") unless -e  $conf->{'directory_somatic_mutations'};
  }
  foreach my $species ( @species ) {
 #    next unless ($species =~ /^mus/);
    my $single_species = 0;
    my %dbs = %{$PD->{$species}{'databases'}||{}};
    $conf->{'dbs'}                     = { map { ($_,$dbs{$_}{NAME}) } keys %dbs };
    $conf->{'dbs'}{'DATABASE_COMPARA'} = 'ensembl_compara_'.$SD->{'ENSEMBL_VERSION'};
    $conf->{'dbs'}{'DATABASE_GO'}      = 'ensembl_ontology_'.$SD->{'ENSEMBL_VERSION'};

    my $core = $dbs{'DATABASE_CORE'};
    $conf->{'core_details'}            = $core;

    my $variation = $do_private ? $dbs{'DATABASE_VARIATION_PRIVATE'} : $dbs{'DATABASE_VARIATION'};
    if ($variation) {
      $conf->{'variation_dbh'} = DBI->connect( "dbi:mysql:$variation->{'NAME'};host=$variation->{'HOST'};port=$variation->{'PORT'}",
                                               $variation->{'USER'},
                                               $variation->{'PASS'},
                  { PrintError => 1, RaiseError => 0} );
      $conf->{'variation_details'} = $variation;
      $conf->{'variation_dbname'}  = $variation->{'NAME'};
    }
    else {
      $conf->{'variation_details'} = undef;
      $conf->{'variation_dbname'}  = undef;
    }

    if ($index eq 'Help') {
      $single_species = 1;
      my $website = $PD->{'MULTI'}{'databases'}{'DATABASE_WEBSITE'};
      $conf->{'website'}{'name'} = $website->{'NAME'};
      $conf->{'website'}{'dbh'}  = DBI->connect("dbi:mysql:$website->{'NAME'};host=$website->{'HOST'};port=$website->{'PORT'}",
                                                $website->{'USER'},
                                                $website->{'PASS'},
             { PrintError => 1, RaiseError => 0} );
    }
    else {
      $conf->{'species'}             = $species;
      $conf->{'species_sci_name'}    = $species;
      $conf->{'authority'}           = $PD->{$species}{'AUTHORITY'};
      $conf->{'species_common_name'} = $PD->{$species}{'SPECIES_COMMON_NAME'};
      $conf->{'species_common_name'} = $PD->{$species}{'SPECIES_COMMON_NAME'};
      $conf->{'strain_details'}{'parent_common_name'} = ucfirst($PD->{$species}{'STRAIN_COLLECTION'});
      $conf->{'strain_details'}{'parent_latin_name'}  = ucfirst($PD->{$species}{'SPECIES_SCIENTIFIC_NAME'});
      $conf->{'strain_details'}{'strain_name'}        = ucfirst($PD->{$species}{'STRAIN_COLLECTION'}) . ' ' . $PD->{$species}{'SPECIES_STRAIN'};
      $conf->{'strain_details'}{'reference_strain'} = 1;
      if ( ucfirst($PD->{$species}{'STRAIN_COLLECTION'}) && ucfirst($PD->{$species}{'SPECIES_COMMON_NAME'}) ne  ucfirst($PD->{$species}{'STRAIN_COLLECTION'})) {
        $conf->{'strain_details'}{'reference_strain'} = 0;
      }
    }

    if ($create_elevate) {
      &create_elevate($conf);
    }
    else {
      my $no_success = 1;
      my $c;
      print LOG "Starting: $index $species\n";
      while ($no_success) {
        $c++;
        $conf->{'dbh'} = DBI->connect("dbi:mysql:$core->{'NAME'};host=$core->{'HOST'};port=$core->{'PORT'}",
                                      $core->{'USER'},
                                      $core->{'PASS'},
                {PrintError => 1, RaiseError => 0}
                                    );
        if ( ! $conf->{'dbh'}) {
          print LOG "WARNING: Unable to get database connection for ".$core->{'NAME'}."\n";
          exit;
        }
        if ($index =~ /Family|GeneTree|Gene/) {
          my $compara = $PD->{'MULTI'}{'databases'}{'DATABASE_COMPARA'};
          $conf->{'dbh_compara'} = DBI->connect("dbi:mysql:$compara->{'NAME'};host=$compara->{'HOST'};port=$compara->{'PORT'}",
            $compara->{'USER'},
            $compara->{'PASS'},
            {PrintError => 1, RaiseError => 0}
            );
        }
        my $function = "dump$index";
        no strict "refs";

        #do the dumping!
        eval {
          $total_c += &$function( $conf );
        };
        if ($@) {
          unless ($debug) {
            #if the query dumping fails try four more times in case it's just a db connection issue
            if ( $conf->{'dbh'}->errstr()) {
              if ($c < 6) {
                print LOG "WARNING: Error when dumping, will retry in 5 minutes (mysql error is ".$conf->{'dbh'}->errstr().", other errors are $@)\n";
                sleep (5*60);}
              else {
                print LOG "WARNING: Error when dumping. you'll need to retry this later (error is ".$conf->{'dbh'}->errstr().")\n";
                $no_success = 0;
              }
            }
            else {
              print LOG "WARNING: Error when dumping, you'll need to retry this one later (error is $@)\n";
              $no_success = 0;
            }
          }
          else {
            print LOG "WARNING: Error when dumping. Exiting since in debug mode (mysql error is ".$conf->{'dbh'}->errstr().", other errors are $@)\n";
            exit;
          }
        }
        else {
          $no_success = 0;
        }
      }
      eval { $conf->{'dbh'}->disconnect; };
      if ($@) { print LOG "WARNING: Problems disconnecting database handle, don't understand this!"; }
      last if $single_species;
    }
    print LOG "  Time for $index is " . &elapsed_time($start) . "\n\n";
  }
}

if ($create_elevate) {
  if ($elevate) {
    print LOG $elevate;
  }
}


#prune empty directories
foreach my $subdir (<$dir/*>) {
  if (rmdir $subdir) {
    print LOG "\nRemoved empty directory $subdir\n";
  }
}

print LOG "\nDumped $total_c records in total\n";
print LOG "\nTotal time for dumping " . &elapsed_time($start_time) . "\n";
exit;


sub create_elevate {
  my ($conf) = @_;
  my $species     = $conf->{'species'};
  my $url = $website_url . "/$species/Info/Index";
  my $common_name = $conf->{'species_common_name'};
  my $variant1 = lc($common_name);
  my %names;
  foreach my $name ($common_name, $variant1, $species) {
    foreach (split ' ', $name) {
      $names{$_}++;
    }
  }
  my $text = join ' ', keys %names;

  $elevate .= qq(
  <query text="$text">
    <doc id="$url" />
  </query>);
}

## Now for all the dump functions...............................


########################################################################## Help

sub dumpHelp {
  my $conf = shift;
  my $start_time = time;
  my $total_c;
  my @types = $sitetype eq 'Vega' ? qw(Glossary) : qw(View FAQ);
  foreach my $type (@types) {
    my $counter   = make_counter(0);
    my $file = $conf->{'directory'}.'/'.$conf->{'website'}{'name'}.'_'.$type.'.xml';
    my $dbname    = $conf->{'website'}{'name'};
    my $db_type   = $type;
    my $fh;
    open( $fh, ">$file" ) or die "Can't open $file: $!";
    print LOG "  Dumping $dbname Help to $file ".&date_and_mem()."\n";
    header($fh);

    if ($type eq 'View') {
      my $sth = $conf->{'website'}{'dbh'}->prepare(qq(
       SELECT hr.help_record_id, keyword, data, page_url
         FROM help_record hr, help_link hl
        WHERE status = 'live'
          AND type = lower('$type')
          AND hl.page_url NOT LIKE 'Mobile%'
          AND hr.help_record_id = hl.help_record_id
      ));
      $sth->execute;

      my ($id, $keywords, $content, $page_url);

      while (($id, $keywords, $content, $page_url) = $sth->fetchrow_array) {
        my $data        = eval($content);
        my $description = $data->{'content'};
        my $title        = "$page_url View";
           $title        =~ s/\// /g;

        &p(helpLine($id, $title, $keywords, $description, undef, $type, $counter), $fh); #### need to parse it
      }
    } else {
      my $sth = $conf->{'website'}{'dbh'}->prepare(qq(
       SELECT help_record_id, keyword, data
         FROM help_record
        WHERE status = 'live'
          AND type = lower('$type')
      ));
      $sth->execute;

      my ($id, $keywords, $content);
      while (($id, $keywords, $content) = $sth->fetchrow_array) {
        my ($extra, $description, $title);
        my $data = eval($content);
        if ($type eq 'Glossary') {
          $description = $data->{'meaning'};
          $title        = $data->{'word'};
          push @$extra, $data->{'expanded'} if $data->{'expanded'};
        } elsif ($type eq 'FAQ') {
          $description = $data->{'answer'};
          $title        = $data->{'question'};
        }

        &p(helpLine($id, $title, $keywords, $description, $extra, $type, $counter), $fh); #### need to parse it
      }
    }
    $total_c += footer($counter->(), $fh, $type);
  }
  return $total_c;
}

sub helpLine {
  my ($id, $title, $keywords, $desc, $extra,  $type, $counter) = @_;
  my @keywords = map { s/^ //; $_; } split ',', $keywords if $keywords;

  #remove all HTML markup, extra whitespace and extra lines. Escape any characters that might have slipped through
  my $hs = HTML::TreeBuilder->new;
  $hs->no_expand_entities(1);
  $hs->parse($desc);
  $hs->eof;
  my $description = $hs->as_text;
  $description =~ s/\s{1,}/ /g;
  $description = clean($description);

  #remove markup from headers and escape just to be sure
  $title =~ s/<\/?\w+>//g;
  $title = &clean($title);

  my $url = $type eq 'FAQ'      ? "Help/Faq#faq$id"
    : $type eq 'Glossary' ? "Help/Glossary?id=$id"
    : $type eq 'View'     ? "Help/View?id=$id"
    : '';
  print LOG "NO URL available for feature type $type, please check\n" unless $url;

  my $xml = qq(
<doc>
  <field name="id">$id</field>
  <field name="description">$description</field>
  <field name="article_title">$title</field>);
  foreach my $kw (@keywords) {
    $xml .= qq(
  <field name="keyword">$kw</field>);
  }
  $xml .= &common_fields('','Documentation','');
  $xml .= qq(
  <field name="feature_subtype">$type</field>);
  $xml .= qq(
  <field name="domain_url">$url</field>
</doc>);
  $counter->();
  return $xml;
}

########################################################################## Markers

sub dumpMarker {
  my $conf = shift;
  my $dbname    = $conf->{'dbs'}{'DATABASE_CORE'};
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/${dbname}_Marker.xml";
  my $start_time = time;
  my $db = 'core';
  my $fh;
  my ($marker_present) = $conf->{'dbh'}->selectrow_array(qq(SELECT count(*) from marker_feature));
  return unless $marker_present;
  open( $fh, ">$file" ) or die "Can't open $file: $!";
  print LOG "  Dumping $dbname to $file ".&date_and_mem()."\n";
  header($fh);
  my $sth = $conf->{'dbh'}->prepare("
   SELECT m.marker_id, ms2.name, ms1.name
     FROM marker_synonym as ms1, marker as m
LEFT JOIN marker_synonym as ms2 on ms2.marker_synonym_id = m.display_marker_synonym_id
    WHERE ms1.marker_id = m.marker_id
 ORDER BY m.marker_id
  ");

  $sth->execute( );
  my $names  = [];
  my $old_ID = 0;
  my ($ID,$marker,$synonym);
  my $params = { contigviewbottom => 'marker_core_marker=normal'}; #used to switch on track by default
  while( ($ID,$marker,$synonym) = $sth->fetchrow_array()){
    $marker = $synonym unless $marker;
    if($ID == $old_ID) {
      push @$names, $synonym;
    } else {
      if ($old_ID) {
        &p( markerLine( $dbspecies, $names, $params, $counter ), $fh);
      }
      $names    = [ $synonym ];
      $old_ID  = $ID;
    }
  }
  &p( markerLine( $dbspecies, $names, $params, $counter ), $fh);
  return footer( $counter->(), $fh);
}

sub markerLine {
  my( $species, $IDS, $params, $counter ) = @_;
  my @synonyms = sort @$IDS;
  my $key = pop @synonyms;
  my $url = sprintf(qq(%s/Marker/Details?m=%s),
                    $species,
                    $key);
  $species =~ s/_/ /;
  my $desc = 'A marker with '.@synonyms.' synonym';
  $desc .= 's' if (@synonyms > 1);
  $desc .= 's' unless (@synonyms);
  return '' unless $key;
  my $xml = qq(
<doc>
  <field name="id">$key</field>);
  foreach my $syn (@synonyms) {
    $xml .= qq(
  <field name="synonym">$syn</field>);
  }
  while (my ($param,$value) = each %$params) {
    $xml .= qq(
  <field name="$param">$value</field>);
  }
  $xml .= &common_fields($species,'Marker','core');
  $xml .= qq(
  <field name="domain_url">$url</field>
</doc>);
  $counter->();
  return $xml;
}


########################################################################## Variations

sub dumpVariation {
  my $conf = shift;
  my $VariationDB = $conf->{'variation_dbname'};
  return unless $VariationDB;

  my $counter   = make_counter(0);
  my $sql_batch = 250000000; #how much do we split the heavy sql query into
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/${VariationDB}_Variation.xml";
  my $start_time = time;
  my $db = 'variation';
  my $fh;
  open( $fh,  ">$file"  ) or die "Can't open $file: $!";
  print LOG "  Dumping $VariationDB Variations to $file... ".&date_and_mem()."\n";
  header($fh);
  my ($counter2,$file2,$fh2);

  my $somatic = { map { @$_ } @{$conf->{'variation_dbh'}->selectall_arrayref( "select source_id, somatic_status from source" )} };
  my $somatic_present =  $do_private ? 0 : ( grep { $somatic->{$_} } keys %$somatic ) ? 1 : 0;
  if ($somatic_present) {
    $counter2 = make_counter(0);
    $file2 = $conf->{'directory_somatic_mutations'}."/${VariationDB}_SomaticMutation.xml";
    open( $fh2, ">$file2" ) or die "Can't open $file2: $!";
    print LOG "  Dumping $VariationDB SomaticMutations to $file2 ... ".&date_and_mem()."\n";
    header($fh2);
  }

  my $sources = { map { @$_ } @{$conf->{'variation_dbh'}->selectall_arrayref( "select source_id, name from source" )} };

  my $sth;
  my ($hgvs_sth);
  my $all_hgvs_names = on_disk_set('all_hgvs_names');
  if ($dbspecies ne 'omo_sapiens') {
    print LOG "    Preparing to get HGVS data ".&date_and_mem()."\n";
    my $i = 0;
    my $continue = 1; #variable to check if there is more data, if query returns 0 then do not carry on
    #split query
    while($continue) {
      $sth = $conf->{'variation_dbh'}->prepare(qq(
        SELECT variation_id, hgvs_name
          FROM variation_hgvs limit $sql_batch offset $i));
      $sth->execute;
      #$continue++;
      if($sth->rows) {
        $i += $sql_batch;
        print LOG "    Got HGVS data set ".&date_and_mem()."\n";
        while ( my ($variation_id,$hgvs_name) = $sth->fetchrow_array ) {
          set_add($all_hgvs_names,$variation_id,$hgvs_name);      
        }
      } else {
        $continue = 0;
      }
    }
  }
  else {
    print LOG "    Will get HGVS data as we go along\n";
    my $sql = qq(SELECT hgvs_name FROM variation_hgvs where variation_id = ?);
    $hgvs_sth = $conf->{'variation_dbh'}->prepare($sql);
  }
  print LOG "    Preparing to get HGNC data ".&date_and_mem()."\n";
  my $all_hgnc_names = on_disk_set('all_hgnc_names');
  $sth = $conf->{'variation_dbh'}->prepare(qq(
     SELECT variation_id, gene_name
       FROM variation_genename));
  $sth->execute;
  while ( my ($variation_id,$hgnc_name) = $sth->fetchrow_array ) {
    set_add($all_hgnc_names,$variation_id,$hgnc_name);
  }

  print LOG "    Preparing to identify GWAS variations ".&date_and_mem()."\n";
  my $gwas_variations;
  $sth = $conf->{'variation_dbh'}->prepare(qq(
     SELECT distinct pf.object_id, s.name
       FROM phenotype_feature pf, source s
      WHERE pf.source_id = s.source_id
        AND pf.is_significant = 1
        AND s.name like "%NHGRI_GWAS%"));
  $sth->execute;
  while ( my ($variation_name,$gwas_study) = $sth->fetchrow_array ) {
    $gwas_study =~ s/_/ /g;
    $gwas_variations->{$variation_name}{$gwas_study}++;
  }

  print LOG "    Preparing to get extra SNP info (phenotypes etc) ".&date_and_mem()."\n";
  my %snp_extra = map { ($_->[0] => $_) }
    @{$conf->{'variation_dbh'}->selectall_arrayref(
     "SELECT v.variation_id,
           group_concat( distinct sta.name SEPARATOR '; ') AS lsi,
           group_concat( distinct st.external_reference SEPARATOR ';') AS st,
           group_concat( distinct pfa1.value SEPARATOR ';') AS gn,
           group_concat( distinct pfa2.value SEPARATOR ';') AS vars,
           group_concat( distinct
             if(
               isnull(p.name),
               p.description,
               concat( p.description,' (',p.name,')' )
             )
             SEPARATOR ';'
           ) AS phen
      FROM phenotype_feature AS pf left join
           variation AS v ON v.name = pf.object_id left join
           phenotype AS p ON p.phenotype_id = pf.phenotype_id left join
           study AS st ON st.study_id=pf.study_id left join
           associate_study AS sa ON sa.study1_id=st.study_id left join
           study AS sta ON sta.study_id=sa.study2_id left join
           ( phenotype_feature_attrib AS pfa1
             join attrib_type AS at1 on pfa1.attrib_type_id = at1.attrib_type_id and at1.code = 'associated_gene' )
           on pfa1.phenotype_feature_id = pf.phenotype_feature_id left join 
           ( phenotype_feature_attrib AS pfa2
             join attrib_type AS at2 on pfa2.attrib_type_id = at2.attrib_type_id and at2.code = 'variation_names' )
           on pfa2.phenotype_feature_id = pf.phenotype_feature_id
     WHERE pf.type = 'Variation'
       AND pf.is_significant = 1
  GROUP BY v.variation_id
  ORDER BY v.variation_id"
   )};
  print LOG "     Retrieved extra SNP info ".&date_and_mem()."\n";

  print LOG "    Preparing to phenotype ontologies ".&date_and_mem()."\n";
  my $ont_db  = $conf->{'dbs'}{'DATABASE_GO'};
  my $phenotype_ontologies = {};
  my $sql = qq(
     SELECT pf.object_id, term.name as phen_ontology, poa.accession, synonym.name as synonym
       FROM $ont_db.term term, $ont_db.synonym synonym, phenotype_ontology_accession poa, phenotype_feature pf
      WHERE pf.type ='Variation'
        AND pf.phenotype_id = poa.phenotype_id
        AND term.accession = poa.accession
        AND synonym.term_id = term.term_id);
  $sth = $conf->{'variation_dbh'}->prepare($sql);
  $sth->execute;
  while ( my ($id,$ont,$accession,$syn) = $sth->fetchrow_array ) {
     $phenotype_ontologies->{$id}{$ont}{'accession'} = $accession;
     push @{$phenotype_ontologies->{$id}{$ont}{'syns'}}, $syn;
   }
  print LOG "     Retrieved phenotype ontologies ".&date_and_mem()."\n";

  my $quick_links;
  my $locations = {};
  if ($do_private) {
    # only needed for private data
    print LOG "    Preparing to get SNP location info ", &date_and_mem, "\n";
    my $query = qq(
     SELECT vf.variation_id, concat(sr.name, ':', vf.seq_region_start-50, '-',  vf.seq_region_end+50, ':', vf.seq_region_strand ) as location
     FROM variation_feature vf, seq_region sr
     WHERE vf.seq_region_id = sr.seq_region_id);
    $sth = $conf->{'variation_dbh'}->prepare($query);
    $sth->execute;
    while ( my $rows = $sth->fetchrow_arrayref() ) {
      push @{$locations->{$rows->[0]}},$rows->[1];
    }
    print LOG "     Retrieved SNP location info ".&date_and_mem()."\n";

    #disable all links from these hits
    $quick_links = 'all:0';
  }

  ## get synonym info
  print LOG "    Preparing to get all synonyms ".&date_and_mem()."\n";
  my $synonyms = on_disk_set('synonyms');
  $sth = $conf->{'variation_dbh'}->prepare(qq(
      SELECT v.variation_id, vs.name
       FROM variation v, variation_synonym vs
      WHERE v.variation_id = vs.variation_id));
  $sth->execute;
  while ( my ($variation_id,$syn_name) = $sth->fetchrow_array ) {
    set_add($synonyms,$variation_id,$syn_name);
  }
  print LOG "      Got all general synonyms ".&date_and_mem()."\n";

  ## get CLINGEN alleles
  print LOG "    Preparing to get CLINGEN alleles ".&date_and_mem()."\n";
  my $clinvar_alleles = on_disk_set('clinvar_alleles');
  ## get CLINVAR allele_synonyms
  $sth = $conf->{'variation_dbh'}->prepare(qq(
      SELECT variation_id, name
       FROM allele_synonym));
  $sth->execute;
  while ( my ($variation_id,$syn_name) = $sth->fetchrow_array ) {
    set_add($clinvar_alleles,$variation_id,$syn_name);
  }
  print LOG "      Got all CLINGEN alleles ".&date_and_mem()."\n";

  ## get failed mappings
  print LOG "    Preparing to get details of failed mappings ".&date_and_mem()."\n";
  my $failures;
  $sth = $conf->{'variation_dbh'}->prepare(qq(
      SELECT v.variation_id, fd.description
       FROM variation v, failed_variation fv, failed_description fd
      WHERE v.variation_id = fv.variation_id
        AND fv.failed_description_id = fd.failed_description_id));
  $sth->execute;
  while ( my ($variation_id,$desc) = $sth->fetchrow_array ) {
    $failures->{$variation_id} = $desc;
  }

  # Process all variations in batches, both mapped, failed and the precious non-mapped, non-failed
  my $batch_size = 50_000_000;
  my $offset = 0;

  print LOG "    Processing SNPs in batches of $batch_size ".&date_and_mem()."\n";

  my $new_syn_c = 0;
  while (1) {
    print LOG "      Fetching from offset $offset.... " . &date_and_mem() . "\n";

    my $rowcache = $conf->{'variation_dbh'}->selectall_arrayref(qq(
      SELECT v.variation_id, v.name, v.source_id, v.somatic
        FROM variation v LIMIT $batch_size OFFSET $offset));

    last unless @$rowcache;

    $offset += $batch_size;
   
    while ( my $row = shift( @{$rowcache} ) ) {
      my $variation_id       = $row->[0];
      my $variation_name     = $row->[1];
      my $source_id          = $row->[2];
      my $failed_desc        = $failures->{$variation_id};
      my $somatic_var        = $row->[3];
      my $syn_c = 0;
      my (@syns, %genes, @phenotypes, @studies, @hgvs_names, @ontologies, %phen_ont);
      if ($synonyms) {
        if ($synonyms->{$variation_id}) {
          foreach my $synonym_name (set_get($synonyms,$variation_id)) {
            push @syns, $synonym_name;
            $syn_c++; 
          }
        }
      }
      if ($clinvar_alleles) {
        if ($clinvar_alleles->{$variation_id}) {
          foreach my $clinvar_name (set_get($clinvar_alleles,$variation_id)) {
            push @syns, $clinvar_name;
            $syn_c++; 
          }
        } 
      }

      my $somatic_mutation = $somatic_var;
      my $type             = $somatic_mutation ? 'Somatic Mutation' : 'Variant';
      my $snp_source       = $sources->{ $source_id };
      my $desc;
      my $x = $snp_extra{$variation_id};
      if( $x ) {
        foreach my $g ($x->[3]) {
          foreach (split ';', $g) {
            $genes{$_}++ if $_;
          }
        }
        push @syns,       split ';', $x->[1];
        push @syns,       split ';', $x->[4];
        push @phenotypes, $x->[5] if $x->[5];
        push @studies,    split ';', $x->[2];
      }
      # ok
      my $hgvs_names;
      if ($all_hgvs_names) {
        if ($all_hgvs_names->{$variation_id}) {
          foreach my $hgvs_name (set_get($all_hgvs_names,$variation_id)) {
            push @hgvs_names, $hgvs_name;
          }
        }
      }
      else {
        $hgvs_sth->execute($variation_id);
        while (my ($hgvs_name) = $hgvs_sth->fetchrow_array) {
          push  @hgvs_names, $hgvs_name;
        }
      }
      if ($phenotype_ontologies->{$variation_name}) {
        while (my ($ontology_name, $values) = each %{$phenotype_ontologies->{$variation_name}}) {
          push @ontologies, $ontology_name;
          $phen_ont{'names'}{$ontology_name}++;
          $phen_ont{'accession'} = $values->{'accession'};
          foreach my $syn (@{$values->{'syns'}}){
            $phen_ont{'synonyms'}{$syn}++;
          }
        }
      }
      # ok
      if ($all_hgnc_names->{$variation_id}) {
        foreach my $hgnc_name (set_get($all_hgnc_names,$variation_id)) {
          $genes{$hgnc_name}++;
        }
      }
      # ok
      my $loc;
      if(exists $locations->{$variation_id}) {
        $loc = $locations->{$variation_id}[0];
      }
      # bad
      my $gwas_studies;
      if(exists $gwas_variations->{$variation_name}) {
        $gwas_studies = join ', ', keys %{$gwas_variations->{$variation_name}};
      }
      $desc = sprintf( "A $snp_source $type.%s%s%s%s%s%s",
                       @phenotypes   ? ' Phenotype(s): '        . (join ', ', @phenotypes)         . '.' : '',
                       @ontologies   ? ' Phenotype ontologies: '. (join ', ', @ontologies)         . '.' : '',
                       %genes          ? ' Gene Association(s): ' . (join ', ', keys %genes)           . '.' : '',
                       @hgvs_names   ? ' HGVS Name(s): '        . &clean((join ', ', @hgvs_names)) . '.' : '',
                       $gwas_studies ? " GWAS studies: $gwas_studies"                              . '.' : '',
                       $failed_desc  ? " $failed_desc."                                                  : '');
      if ($somatic_mutation){
        &p( VariationLine( $dbspecies, $variation_name, \@syns, \%genes, \@phenotypes, \%phen_ont, \@studies, \@hgvs_names, $type, $snp_source, $loc, $quick_links, $desc, $counter2 ), $fh2);
      }
      else {
        &p( VariationLine( $dbspecies, $variation_name, \@syns, \%genes, \@phenotypes, \%phen_ont, \@studies, \@hgvs_names, $type, $snp_source, $loc, $quick_links, $desc, $counter ), $fh);
      }
    }
  }

  print LOG "    All SNPs dumped to file ".&date_and_mem()."\n";

  my $c = footer( $counter->(), $fh, 'Variation');
  if ($somatic_present) {
    $c += footer( $counter2->(), $fh2, 'Somatic Mutation');
  }
  print LOG "  $new_syn_c synonyms added from the subsnp_map table\n";

  %snp_extra    = undef;

  off_disk('all_hgvs_names',$all_hgvs_names);
  off_disk('all_hgnc_names',$all_hgnc_names);
  return $c;
}

sub VariationLine {
  my ($species, $name, $synonyms, $genes, $phenotypes, $ontologies, $studys, $hgvs_names, $type, $source, $loc, $quick_links, $desc, $counter ) = @_;
  my $url = sprintf(qq(%s/Variation/Summary?v=%s),
                    $species,
                    $name);
  #if we have a location then use this in the URL
  if ($loc) {
    $url = sprintf(qq(%s/Location/View?r=%s),
                    $species,
                    $loc);
  }
  $species =~ s/_/ /;
  $desc = &clean($desc,'phenotype description');
  my $xml = qq(
<doc>
  <field name="id">$name</field>
  <field name="description">$desc</field>);
  if ($quick_links) {
    $xml .= qq(
  <field name="quick_links">$quick_links</field>);
  }
  foreach (@$synonyms) {
    $xml .= qq(
  <field name="synonym">$_</field>);
  }
  if (%$ontologies){
    my $acc = $ontologies->{'accession'};
    $xml .= qq(
  <field name="ont_acc">$acc</field>);
    foreach my $name (keys %{$ontologies->{'names'}}) {
      my $name = clean($name,'ontology_name');
      $xml .= qq(
  <field name="ont_name">$name</field>);
    }
    foreach my $syn (keys %{$ontologies->{'synonyms'}}) {
      $syn = clean($syn,'ontology_synonym');
      $xml .= qq(
  <field name="ont_syn">$syn</field>);
    }
  }
  foreach (@$studys ) {
    $xml .= qq(
  <field name="study">$_</field>);
  }
  foreach my $hgvs_name (@$hgvs_names) {
    $hgvs_name = &clean($hgvs_name,'hgvs_name');
    $xml .= qq(
  <field name="hgvs_name">$hgvs_name</field>);
  }

## These records are in the description so no need to be in as seperate fields as well. Leaving commented out though
## in case we do need to raise the priority of these records
#  foreach (keys %$genes) {
#    $xml .= qq(
#  <field name="assoc_gene">$_</field>);
#  }
#  foreach (@$phenotypes) {
#    $xml .= qq(
#  <field name="phenotype">$_</field>);
#  }
#  foreach my $hgvs_name (@$hgvs_names) {
#    $hgvs_name = &clean($hgvs_name,'hgvs_name');
#    $xml .= qq(
#  <field name="hgvs_name">$hgvs_name</field>);
#  }
  $xml .= qq(
  <field name="variation_source">$source</field>);
  $xml .= &common_fields($species,$type,'variation');
  $xml .= qq(
  <field name="domain_url">$url</field>
</doc>);
  $counter->();
  return $xml;
}

########################################################################## Variation Phenotypes

sub dumpPhenotype {
  my $conf = shift;
  my $VariationDB = $conf->{'dbs'}->{'DATABASE_VARIATION'};
  return unless $VariationDB;
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/${VariationDB}_Phenotype.xml";
  my $start_time = time;
  my $db = 'variation';
  my $fh;
  open $fh, '>', $file  or die "Can't open $file: $!";
  print LOG "  Dumping $VariationDB Phenotype info to $file ... ".&date_and_mem()."\n";
  header($fh);

  my %synonyms = ();
  my $phenotype_info = $conf->{'variation_dbh'}->selectall_hashref(qq(
     SELECT p.description, p.phenotype_id
       FROM phenotype p, phenotype_feature pf
      WHERE p.phenotype_id = pf.phenotype_id
        AND pf.is_significant = 1
      GROUP BY p.phenotype_id),'description');
  foreach my $phen (keys %$phenotype_info) {
    my $syns = $synonyms{$phenotype_info->{$phen}{'phenotype_id'}} || [];
    &p( PhenLine( $dbspecies, $phen, $phenotype_info->{$phen}{'phenotype_id'}, $syns, '', $counter ), $fh);
  }

  my $ont_db  = $conf->{'dbs'}{'DATABASE_GO'};
  my $phenotype_ont_info = $conf->{'variation_dbh'}->selectall_hashref(qq(
     SELECT distinct t.accession, t.name
       FROM $ont_db.term t, phenotype_ontology_accession poa
      WHERE t.accession = poa.accession),'accession');
  foreach my $phenotype_ont (keys %$phenotype_ont_info) {
    &p( PhenLine( $dbspecies, $phenotype_ont_info->{$phenotype_ont}{'name'}, $phenotype_ont, [], 1, $counter ), $fh);
  }
  return footer( $counter->(), $fh);
}

sub PhenLine {
  my ($species, $name, $id, $synonyms, $is_ont, $counter ) = @_;
  my $url = sprintf(qq(%s/Phenotype/Locations?%s=%s),
                    $species,
                    $is_ont ? 'oa' : 'ph',
                    $id);
  $species =~ s/_/ /;
  $name = &clean($name,'name');
  my $boost = $is_ont ? $boosts->{'PhenotypeOntlogy'}{'All'} : '';
  my $doc = $boost ? qq(doc boost="$boost") : 'doc';
  my $xml = qq(
<$doc>
  <field name="id">$id</field>
  <field name="name">$name</field>);
  foreach my $syn (@$synonyms) {
    $xml .= qq(
  <field name="synonym">$syn</field>);
  }
  $xml .= &common_fields($species,'Phenotype','variation');
  $xml .= qq(
  <field name="domain_url">$url</field>
</doc>);
  $counter->();
  return $xml;
}

########################################################################## StructuralVariations

sub dumpStructuralVariation {
  my $conf = shift;
  my $VariationDB = $conf->{'variation_dbname'};

  return unless $VariationDB;
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/${VariationDB}_StructuralVariations.xml";
  my $start_time = time;
  my $db = 'variation';
  my $fh;
  open( $fh, ">$file" ) or die "Can't open $file: $!";
  print LOG "  Dumping $VariationDB to $file ... ".&date_and_mem()."\n";
  header($fh);

  my $quick_links;
  my $locations = {};
  if ($do_private) {
    # only needed for private data
    print LOG "    Preparing to get StructuralVariation location info ", &date_and_mem, "\n";
    my $query = qq(
    SELECT svf.structural_variation_id, concat(sr.name, ':', svf.seq_region_start, '-', svf.seq_region_end, ':', svf.seq_region_strand ) as location
      FROM structural_variation sv, structural_variation_feature svf, seq_region sr
     WHERE sv.structural_variation_id = svf.structural_variation_id
       AND svf.seq_region_id = sr.seq_region_id);
    my $sth = $conf->{'variation_dbh'}->prepare($query);
    $sth->execute;
    while ( my $rows = $sth->fetchrow_arrayref() ) {
      push @{$locations->{$rows->[0]}},$rows->[1];
    }
    print LOG "     Retrieved StructuralVariation location info ".&date_and_mem()."\n";

    #disable all links from these hits
    $quick_links = 'all:0';
  }

  my $scale           = $PD->{'species'}{'ENSEMBL_GENOME_SIZE'} || 1;
  my $max_length      = $scale *= 1e6;
  my $T = $conf->{'variation_dbh'}->selectall_arrayref(qq(
    SELECT v.structural_variation_id,
           v.variation_name,
           s.name as source,
           s.description,
           st.name as study,
           r.name as seq_region,
           vf.seq_region_start,
           vf.seq_region_end,
           group_concat(ssv.variation_name) as ssv
      FROM structural_variation as v LEFT JOIN study as st ON st.study_id=v.study_id
        LEFT JOIN structural_variation_association as sva ON v.structural_variation_id = sva.structural_variation_id
        LEFT JOIN structural_variation as ssv ON ssv.structural_variation_id = sva.supporting_structural_variation_id,
           source as s,
           seq_region as r,
           structural_variation_feature as vf
     WHERE s.source_id = v.source_id
       AND v.structural_variation_id = vf.structural_variation_id
       AND vf.seq_region_id = r.seq_region_id
       AND v.is_evidence = 0
  GROUP BY v.structural_variation_id));

  foreach my $row ( @$T ) {
    my $id = $row->[1];
    my $location = $row->[5] .":" . $row->[6] ."-". $row->[7];
    my $length = $row->[7] - $row->[6] + 1;
    my $evidence =  $row->[8];
    my $study  = $row->[4];
 #   my $loc = $locations->{$row->[0][0]};
 #   warn $loc; exit;
    my $action = ($length >> $max_length) ? 'Overview' : 'View';
    my $params = ($length >> $max_length) ? { 'cytoview' => 'variation_feature_structural=normal' }
       : { 'contigviewbottom' => 'variation_feature_structural=normal' };
    my $desc;
    if ($study) {
      $desc = qq(A structural variation from $row->[2], identified by $row->[3] (study $study).);
      }
    else {
      $desc = qq(A structural variation from $row->[2], identified by $row->[3].);
    }
    &p( StrucVarLine( $dbspecies, $id, $evidence, $study, $location, $quick_links, $desc, $action, $params, $counter ), $fh);
  }
  return footer( $counter->(), $fh);
}

sub StrucVarLine {
  my ($species, $id, $evidence, $study, $location, $quick_links, $desc, $action, $params, $counter ) = @_;
# $location, $action and $params contain info for location view, no point in adding it until we can pass this info from StructuralVariation/Summary

  my $url = sprintf(qq(%s/StructuralVariation/Explore?sv=%s),
                    $species,
                    $id);
  if ($do_private) {
    my ($chr,$coords) = split ':', $location;
    my ($start,$stop) = split '-', $coords;
#    my $view = ($stop-$start+1 > 1e6) ? 'Overview' : 'View'; #use this when we have Structural Variations on Genoverse
    my $view = 'View';
    $url = sprintf(qq(%s/Location/View?r=%s),
                    $species,
                    $location);
  }
  $species =~ s/_/ /;
  my $xml = qq(
<doc>
  <field name="id">$id</field>
  <field name="description">$desc</field>);
  if ($quick_links) {
    $xml .= qq(
  <field name="quick_links">$quick_links</field>);
  }
  foreach (split ',', $evidence) {
    $xml .= qq(
  <field name="supporting_evidence">$_</field>);
  }
  if ($study) {
    $xml .= qq(
  <field name="study">$study</field>);
  }
  $xml .= &common_fields($species,'StructuralVariation','variation');
  $xml .= qq(
  <field name="domain_url">$url</field>
</doc>);
  $counter->();
  return $xml;
}


########################################################################## Similarity features

sub dumpGenomicAlignment {
  my $conf    = shift;
  my $dbspecies = $conf->{'species'};
  my $COREDB  = $conf->{'dbs'}->{'DATABASE_CORE'};
  my $ESTDB   = $conf->{'dbs'}->{'DATABASE_OTHERFEATURES'};
  my $CDNADB  = $conf->{'dbs'}->{'DATABASE_CDNA'};
  my $RNASEQDB = $conf->{'dbs'}->{'DATABASE_RNASEQ'};
  my %dbs      = ( 'core' => $COREDB );
  $dbs{'otherfeatures'} = $ESTDB  if $ESTDB;
  $dbs{'cdna'}          = $CDNADB if $CDNADB;
  my %tables = (
    'dna_align_feature'     => [ 'DnaAlignFeature',     'DNA alignment feature' ],
    'protein_align_feature' => [ 'ProteinAlignFeature', 'Protein alignment feature' ]
  );
  my $total_af_c;
  foreach my $db ( sort { $a cmp $b } keys %dbs) {
    my $counter    = make_counter(0);
    my $dbname     = $dbs{$db};
    my $file       = $conf->{'directory'}."/${dbname}_GenomicAlignment.xml";
    my $start_time = time;
    my $fh;
    open( $fh, ">$file" ) or die "Can't open $file: $!";
    print LOG "  Dumping $dbname to $file ... ".&date_and_mem()."\n";
    header($fh);

    foreach my $table ( keys %tables ) {
      my $disp_sth = $conf->{'dbh'}->prepare(qq(
        select ad.analysis_id, ad.web_data
          from $dbname.analysis_description ad
        where ad.displayable = 1
      ));
      $disp_sth->execute();
      my @disp_ids;
      while(my ($id,$webdata) = $disp_sth->fetchrow_array) {
        my $wd = eval($webdata);
        next if $wd->{$table}{'do_not_display'}; 
        push @disp_ids,$id;
      }
      next unless @disp_ids;
      my $disp_ids = join(',',@disp_ids);
      my $source = $tables{ $table }[0];
      $source .= ";db=$db" unless $db eq 'core';
      my $type   = $tables{ $table }[1];
      my $sth    = $conf->{'dbh'}->prepare(
        "select ad.display_label, a.logic_name, t.hit_name, edb.db_name, count(*) as hits
                from (($dbname.analysis as a, $dbname.$table as t) left join
                     $dbname.analysis_description ad on a.analysis_id = ad.analysis_id) 
           left join $dbname.external_db edb on t.external_db_id = edb.external_db_id
               where a.analysis_id = t.analysis_id
                 and ad.analysis_id in ($disp_ids)
                 and ad.displayable = 1
               group by ad.display_label, t.hit_name");
      $sth->execute();
      my $c = 0;
      while( my( $label, $logic_name, $hid, $db_name, $count  ) = $sth->fetchrow_array ) {
        $c++;
        $label ||= '';
        my $desc = "$label $hid hits the genome in $count locations.";
        (my $track_name = $table) =~ s/feature//;
        my $renderer = $track_name . $db . '_' . lc($logic_name) . '=stack' ;
        my $params = { 'contigviewbottom' => $renderer };
        &p( GenomicAlignmentLine( $dbspecies, $hid, $desc, $db_name, $db, $tables{$table}->[0], $params, $counter ), $fh);
      }
      print LOG "  ...Dumped $c $table entries\n";
    }
    if ($db eq 'cdna') {
      my $sth    = $conf->{'dbh'}->prepare(
        "select ad.display_label, uo.identifier,  ur.summary_description, 'Unmapped feature'
           from $dbname.unmapped_object uo, $dbname.unmapped_reason ur, $dbname.analysis a
                left join $dbname.analysis_description ad on a.analysis_id = ad.analysis_id
          where a.analysis_id = uo.analysis_id
            and uo.unmapped_reason_id = ur.unmapped_reason_id");
      $sth->execute();
      my $c++;
      while (my ($label, $hid, $reason, $type) = $sth->fetchrow_array ) {
        $c++;
        $label ||= '';
        my $desc = "$label $hid fails to map to the genome. Reason: $reason.";
        &p( GenomicAlignmentLine( $dbspecies, $hid, $desc, undef, $db, 'Unmapped feature', {}, $counter ), $fh);
      }
      print LOG "  ...Dumped $c Unmapped features\n";
    }
    $total_af_c += footer( $counter->(), $fh);
  }
  return $total_af_c;
}

sub GenomicAlignmentLine {
  my ($species, $id, $desc, $db_name, $db, $ftype, $params, $counter ) = @_;
# $params contains what's needed to switch the track on region in detail but there's no point in using it since we get to this via Location/Genome

  my $url = sprintf(qq(%s/Location/Genome?ftype=%s;id=%s%s),
                    $species,
                    $ftype,
                    $id,
                    $db ne 'core' ? ";db=$db" : '');
  $species =~ s/_/ /;
  my $xml = qq(
<doc>
  <field name="id">$id</field>
  <field name="description">$desc</field>);
  $xml .= &common_fields($species,'GenomicAlignment',$db);
  if ($db_name) {
    $xml .= qq(
  <field name="external_source">$db_name</field>);
  }
  $xml .= qq(
  <field name="domain_url">$url</field>
</doc>);
  $counter->();
  return $xml;
}


########################################################################## OligoProbes

sub dumpOligoProbe {
  my $conf = shift;
  my $FUNCDB = $conf->{'dbs'}->{'DATABASE_FUNCGEN'};
  return unless $FUNCDB;
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/${FUNCDB}_OligoProbe.xml";
  my $start_time = time;
  my $db = 'funcgen';
  my $fh;
  open( $fh, ">$file" ) or die "Can't open $file: $!";
  print LOG "  Dumping $FUNCDB to $file ... ".&date_and_mem()."\n";
  header($fh);

  #gene details
  my $gene_dets;
  my $sql = qq(
    SELECT t.stable_id, g.stable_id, x.display_label
      FROM transcript t, gene g, xref x
     WHERE t.gene_id = g.gene_id
       AND g.display_xref_id = x.xref_id);
  my $sth = $conf->{'dbh'}->prepare($sql);
  $sth->execute;
  while( my( $tsi, $gsi, $gname) = $sth->fetchrow_array ) {
    $gene_dets->{$tsi} = {
      'gene_id'   => $gsi,
      'gene_name' => $gname
    };
  }

  my $probe_set_trans_dets;
  $sql = qq(
      SELECT probe_set_id, stable_id, stable_id
        FROM $FUNCDB.probe_set_transcript
    ORDER BY probe_set_id);
  $sth = $conf->{'dbh'}->prepare($sql);
  $sth->execute;
  while( my( $probe_set_id, $tsi, $display_label) = $sth->fetchrow_array ) {
    my $gene_label = $gene_dets->{$tsi}{'gene_name'};
    push @{$probe_set_trans_dets->{$probe_set_id}{$gene_label}}, {
      'stable_id'     => $tsi,
      'display_label' => $display_label,
    };
  };

  $sth    = $conf->{'dbh'}->prepare(qq(
    SELECT
      probe_set.name,
      probe_set.probe_set_id,
      count(distinct probe_feature.probe_feature_id) as hits,
      array.name
    FROM
      $FUNCDB.probe_set
      join $FUNCDB.probe using (probe_set_id)
      join $FUNCDB.probe_feature using (probe_id)
      join $FUNCDB.array_chip on (probe.array_chip_id=array_chip.array_chip_id)
      join $FUNCDB.array using (array_id)
    GROUP BY
      probe_set.name,
      array.name
));
  $sth->execute();
  print LOG "    Retrieved probe_set features; dumping to xml...".&date_and_mem()."\n";
  while( my( $probe_name, $pset_id, $count, $type ) = $sth->fetchrow_array ) {
    next unless $probe_name;
    my $locations_c = $count > 1 ? 'locations' : 'location';
    my $desc =  qq($type probeset $probe_name has probes which hit the genome in $count $locations_c.);
    if (my @gname = keys %{$probe_set_trans_dets->{$pset_id} || {}}) {
      my $gene_c = scalar(@gname) > 1 ? 'genes' : 'gene';
      $desc .= " They hit transcripts in the following $gene_c:";
      foreach my $gene (@gname) {
        $desc .= " $gene (";
        foreach my $trans (@{$probe_set_trans_dets->{$pset_id}{$gene}}) {
          $desc .= $trans->{'stable_id'}.', ';
        }
        $desc =~ s/, $//;
        $desc .= '),';
      }
      $desc =~ s/,$/\./;
    }
    &p( OligoProbeLine($dbspecies,$probe_name,$desc,'','pset',$db,$counter ), $fh);
  }

  my $probe_trans_dets;
  $sql = qq(
        SELECT probe_id, stable_id, stable_id
          FROM $FUNCDB.probe_transcript
      ORDER BY probe_id
  );
  $sth = $conf->{'dbh'}->prepare($sql);
  $sth->execute;
  while( my( $probe_id, $tsi, $display_label) = $sth->fetchrow_array ) {
    my $gene_label = $gene_dets->{$tsi}{'gene_name'};
    push @{$probe_trans_dets->{$probe_id}{$gene_label}}, {
      'stable_id' => $tsi,
      'display_label' => $display_label,
    };
  };

  $sth    = $conf->{'dbh'}->prepare(qq(
    select
      probe.probe_id,
      probe.name,
      array.vendor,
      array.name,
      count(distinct probe_feature.probe_feature_id) as hits
    from
      $FUNCDB.probe_feature
      join $FUNCDB.probe using (probe_id)
      join $FUNCDB.array_chip using (array_chip_id)
      join $FUNCDB.array using (array_id)
    where
      probe.probe_set_id is null
    group by
      probe.name
  ));
  $sth->execute();
  print LOG "    Retrieved probe features; dumping to xml...".&date_and_mem()."\n";
  my $old;
  while( my( $pid, $pname, $vendor, $aname, $count ) = $sth->fetchrow_array ) {
    if( $old->{'pid'} != $pid ) {
      if( $old->{'pid'}) {
        my ($p_probe_name,$desc) = &get_oligo_terms($old);
        if (my @gname = keys %{$probe_trans_dets->{$pid} || {}}) {
          my $gene_c = scalar(@gname) > 1 ? 'genes' : 'gene';
          $desc .= " It hits transcripts in the following $gene_c:";
          foreach my $gene (@gname) {
            $desc .= " $gene (";
            foreach my $trans (@{$probe_trans_dets->{$pid}{$gene}}) {
              $desc .= $trans->{'stable_id'}. ', ';
            }
            $desc =~ s/, $//;
            $desc .= '),';
          }
          $desc =~ s/,$/\./;
        }
        &p( OligoProbeLine($dbspecies,$p_probe_name,$desc,$old->{'array_dets'},'probe',$db,$counter ), $fh);
      }
      $old = {
        'pid'        => $pid,
        'array_dets' => [ [ $aname, $pname] ],
        'vendor'     => $vendor,
        'count'      => $count,
      };
    }
    else {
      push @{$old->{'array_dets'}}, [ $aname, $pname ];
    }
  }
  if( $old->{'pid'} ) {
    my ($p_probe_name,$desc) = &get_oligo_terms($old);
    &p( OligoProbeLine($dbspecies,$p_probe_name,$desc,$old->{'array_dets'},'probe',$db,$counter ), $fh);
  }
  return footer( $counter->(), $fh);
}

sub get_oligo_terms {
  my $old = shift;
  my $primary_probe  = shift @{$old->{'array_dets'}};
  my ($p_array_name,$p_probe_name) = @$primary_probe;
  my $type  = $old->{'vendor'};
  my $count = $old->{'count'};
  my $locations_c = $count > 1 ? 'locations' : 'location';
  my $desc = "$type probe $p_probe_name ($p_array_name array) hits the genome in $count $locations_c.";
  if ($old->{'array_dets'}) {
    my $c = scalar(@{$old->{'array_dets'}});
    if ($c) {
      my $synonyms_c = $c > 1 ? 'synonyms' : 'synonym';
      $desc .= " It has $c $synonyms_c:";
      foreach (@{$old->{'array_dets'}}) {
        my ($array_name,$probe_name) = @$_;
        $desc .= " $probe_name ($array_name array),";
      }
      $desc =~ s/,$//;
      $desc .= '.';
    }
  }
  return $p_probe_name,$desc;
}

sub OligoProbeLine {
  my ($species,$hid,$desc,$syns,$pset,$db,$counter) = @_; 
  my $url = sprintf(qq(%s/Location/Genome?fdb=%s;ftype=ProbeFeature;id=%s),
                   $species,
                   $db,
                   $hid);
  $url .= ";ptype=$pset" if $pset eq 'pset';
  $species =~ s/_/ /;
  my $xml = qq(
<doc>
  <field name="id">$hid</field>
  <field name="description">$desc</field>);

  #not used but could be if we ever need the client to distinguish between probes and probe sets
#  $xml .= qq(
#  <field name="ptype">$pset</field>);

  foreach my $syn (@{$syns||[]}) {
    my ($array_name,$probe_name) = @$syn;
    $xml .= qq(
  <field name="synonym">$probe_name</field>);
  }

  $xml .= &common_fields($species,'ProbeFeature',$db);
  $xml .= qq(
  <field name="domain_url">$url</field>
</doc>);
  $counter->();
  return $xml;
}


########################################################################## Domains

sub dumpDomain {
  my $conf = shift;
  my $dbname    = $conf->{'dbs'}{'DATABASE_CORE'};
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $common_name = $conf->{'species_common_name'};
  my $file = $conf->{'directory'}."/${dbname}_Domain.xml";
  my $start_time = time;
  my $db = 'core';
  my $fh;
  open( $fh, ">$file" ) or die "Can't open $file: $!";
  print LOG "  Dumping $dbname to $file ... ".&date_and_mem()."\n";
  header($fh);

  my $gene_counts = $conf->{'dbh'}->selectall_hashref(qq(
     select x.dbprimary_acc, count(*) as c
      from xref x,
                 (select x.dbprimary_acc, g.stable_id
                   from xref as x, interpro as i, protein_feature pf, translation tl, transcript t, gene g
                  where x.dbprimary_acc = i.interpro_ac
                    and i.id = pf.hit_name
                    and pf.translation_id = tl.translation_id
                    and tl.transcript_id = t.transcript_id
                    and t.gene_id = g.gene_id
               group by x.dbprimary_acc, g.stable_id
               order by x.dbprimary_acc, g.stable_id) as y
      where x.dbprimary_acc = y.dbprimary_acc
   group by x.dbprimary_acc),'dbprimary_acc');

  my $sth = $conf->{'dbh'}->prepare(
    "select x.dbprimary_acc, i.id, x.description
       from xref as x, interpro as i, protein_feature pf
      where x.dbprimary_acc = i.interpro_ac
        and i.id = pf.hit_name
      group by i.id
      order by x.dbprimary_acc");
  $sth->execute();
  my $old_acc     = '';
  my $IDS         = [];
  my $description = '';
  my $count       = 0;
  my ($acc, $id, $desc, $old_desc );
  while( ($acc, $id, $desc ) = $sth->fetchrow_array()){
    if($acc eq $old_acc) {
      push @$IDS, $id;
      $count++;
    }
    else {
      if ($old_acc) {
        my $gene_c = $gene_counts->{$old_acc}{'c'};
        my $gene_text = $gene_c > 1 ? 'genes' : 'gene';
        $description = "Interpro domain $old_acc [$old_desc] is found in $gene_c $gene_text in $common_name and has";
        &p( DomainLine($dbspecies,$old_acc,$description,$IDS,$count,$counter ), $fh);
      }

      $IDS      = [ $id ];
      $old_acc  = $acc;
      $old_desc = $desc;
      $count    = 1;
    }
  }
  $description = "Interpro domain $old_acc [$old_desc] has";
  &p( DomainLine($dbspecies,$old_acc,$description,$IDS,$count,$counter ), $fh);
  return footer( $counter->(), $fh);
}

sub DomainLine {
  my($species, $acc, $desc, $IDS, $count, $counter) = @_;
  my $url = sprintf(qq(%s/Location/Genome?ftype=Domain;id=%s),
                    $species,
                    $acc);
  $species =~ s/_/ /;
  my $ids = join ', ', @$IDS;
  my $identifier_text = $count > 1 ? 'records' : 'record';
  my $description = &clean($desc)." $count $identifier_text from signature databases: $ids";
  my $xml = qq(
<doc>
  <field name="id">$acc</field>
  <field name="description">$description</field>);
  foreach my $id (@$IDS) {
    $xml .= qq(
  <field name="synonym">$id</field>);
  }
  $xml .= &common_fields($species,'Protein Domain','core');
  $xml .= qq(
  <field name="domain_url">$url</field>
</doc>);
  $counter->();
  return $xml;
}


########################################################################## GeneTrees

sub dumpGeneTree {
  my $conf   = shift;
  my ($gt_present) = $conf->{'dbh_compara'}->selectrow_array(qq(SELECT count(*) FROM gene_tree_root WHERE stable_id IS NOT null));
  if (! $gt_present) {
    print LOG "  Error - can't find any gene trees to dump".&date_and_mem()."\n";
  }
  my $dbspecies = $conf->{'species'};
  my ($multi_species,$counter,$start_time,$fh);
  my $compara_dbname = $conf->{'dbs'}->{'DATABASE_COMPARA'};
  my $compara_file = $conf->{'directory'}."/${compara_dbname}_GeneTree.xml";
  unless (-e $compara_file) {
    $multi_species = 1;
    $counter   = make_counter(0);
    $start_time = time;
    $dbspecies = 'Multi';
    $fh;
    open( $fh, ">$compara_file" ) or die "Can't open $compara_file: $!";
    print LOG "  Dumping $compara_dbname to $compara_file ... ".&date_and_mem()."\n";
    header($fh);
    my $sth = $conf->{'dbh_compara'}->prepare(qq(
        SELECT gtr.stable_id
          FROM gene_tree_root gtr
         WHERE gtr.clusterset_id = "default"
           AND gtr.tree_type = "tree"
           AND gtr.stable_id IS NOT NULL));
    $sth->execute();
    while( my( $gt_id,$mlss_name) = $sth->fetchrow_array()) {
      &p( GeneTreeLine($dbspecies,$gt_id,$mlss_name,$counter,$multi_species), $fh);
    }
    my $c = footer( $counter->(), $fh);
  }
  $multi_species = 0;
  $dbspecies = $conf->{'species'};
  $counter   = make_counter(0);
  $start_time = time;
  my $dbname = $conf->{'dbs'}->{'DATABASE_CORE'};
  my $file = $conf->{'directory'}."/${dbname}_GeneTree.xml";
  my $fh;
  open( $fh, ">$file" ) or die "Can't open $file: $!";
  print LOG "  Dumping $dbname gene trees to $file ... ".&date_and_mem()."\n";
  header($fh);
  my $gene_names = { map { @$_ } @{$conf->{'dbh'}->selectall_arrayref( "select g.stable_id, x.display_label from gene g, xref x where g.display_xref_id = x.xref_id" )} };
  my $sql = qq(
        SELECT gtr.stable_id, gm.stable_id, mlss.name
         FROM gene_tree_root gtr
         JOIN gene_tree_node USING (root_id)
         JOIN seq_member sm USING (seq_member_id)
         JOIN gene_member gm ON sm.gene_member_id = gm.gene_member_id
         JOIN genome_db gdb ON gm.genome_db_id = gdb.genome_db_id
         JOIN method_link_species_set mlss ON gtr.method_link_species_set_id = mlss.method_link_species_set_id
        WHERE clusterset_id = "default"
          AND tree_type = "tree"
          AND gdb.name = '$dbspecies');
  my $sth =  $conf->{'dbh_compara'}->prepare($sql);
  $sth->execute;
  while (my ($gt_id, $gid, $mlss_name) = $sth->fetchrow_array() ) {
    next unless $gt_id;
    my $name = $gene_names->{$gid};
    &p( GeneTreeLine($dbspecies,$gt_id,$mlss_name,$counter,$multi_species,$gid,$name), $fh);
  }
  return footer( $counter->(), $fh);
}

sub GeneTreeLine {
  my($species,$gt_id,$mlss_name,$counter,$ms,$gid,$name) = @_;
  my ($url,$xml,$desc);
  my $is_strain = ($mlss_name =~ /^default/) ? 0 : 1;
  $xml = qq(
<doc>
  <field name="id">$gt_id</field>);
  if ($ms) {
    $desc = "GeneTree $gt_id contains genes from multiple species";
    $xml .= qq(
  <field name="name">$gt_id</field>
  <field name="description">$desc</field>);
    $xml .= &common_fields($species,'GeneTree','compara');
    $url = sprintf(qq(Multi/GeneTree/Image?gt=%s),$gt_id);
    $xml .= qq(
  <field name="domain_url">$url</field>);
  }
  else {
    if ($name && ($name ne $gid)) {
      $desc = "Gene $name ($gid) is a member of GeneTree $gt_id";
      $xml .= qq(
  <field name="name">$gt_id</field>
  <field name="assoc_gene">$gid</field>
  <field name="assoc_gene_name">$name</field>
  <field name="description">$desc</field>);
    }
    else {
      $desc = "Gene $gid is a member of GeneTree $gt_id";
      $xml .= qq(
  <field name="name">$gt_id</field>
  <field name="assoc_gene">$gid</field>
  <field name="description">$desc</field>);
    }
    $xml .= &common_fields($species,'GeneTree','core');
    my $url_root = $is_strain ? 'Strain_Compara_Tree' : 'Compara_Tree';
    $url = sprintf(qq($species/Gene/%s?g=%s),$url_root,$gid);
    $xml .= qq(
  <field name="domain_url">$url</field>);
  }
  $xml .= qq(
</doc>);
  $counter->();
  return $xml;
}

########################################################################## Families

sub dumpFamily {
  my $conf   = shift;
  my ($multi_species,$counter,$start_time,$fh);
  my $compara_dbname = $conf->{'dbs'}->{'DATABASE_COMPARA'};
  my $dbname = $conf->{'dbs'}->{'DATABASE_CORE'};
  my $dbspecies;
  my ($family_present) = $conf->{'dbh_compara'}->selectrow_array(qq(SELECT count(*) from family));
  return unless $family_present;
  my $compara_file = $conf->{'directory'}."/${compara_dbname}_Family.xml";
  unless (-e $compara_file) {
    $multi_species = 1;
    $counter   = make_counter(0);
    $start_time = time;
    $dbspecies = 'Multi';
    $fh;
    open( $fh, ">$compara_file" ) or die "Can't open $compara_file: $!";
    print LOG "  Dumping $compara_dbname to $compara_file ... ".&date_and_mem()."\n";
    header($fh);

    # uniprot records linked to families do not have a species to filter on so link them to the cross species view
    my $uniprot_members;
    my $sth = $conf->{'dbh_compara'}->prepare(qq(
        SELECT f.stable_id as family_id, sm.stable_id as uniprot_id
          FROM family f, family_member fm, seq_member sm
         WHERE f.family_id = fm.family_id
           AND fm.seq_member_id = sm.seq_member_id
           AND sm.source_name like 'Uniprot%'));
    $sth->execute;
    while( my( $fid, $uniprot_id ) = $sth->fetchrow_array()) {
      push @{$uniprot_members->{$fid}}, $uniprot_id;
    }

    my $sth = $conf->{'dbh_compara'}->prepare(qq(SELECT stable_id, description FROM family));
    $sth->execute();
    while( my( $fid,$desc) = $sth->fetchrow_array()) {
      my @uniprots;
      foreach my $uniprot_id (@{$uniprot_members->{$fid}}) {
        push @uniprots,$uniprot_id;
      }
      &p( FamilyLine($dbspecies,$fid,$desc,$multi_species,'','','',\@uniprots,$counter ), $fh);
    }
    my $c = footer( $counter->(), $fh);
  }
  $multi_species = 0;
  my $t_sth  = $conf->{'dbh'}->prepare("select meta_value from $dbname.meta where meta_key='species.taxonomy_id'");
  $t_sth->execute;
  my $taxon_id = ($t_sth->fetchrow);
  return unless $taxon_id;

  $counter   = make_counter(0);
  $start_time = time;
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/${dbname}_Family.xml";
  my $db = 'core';
  my $fh;
  open( $fh, ">$file" ) or die "Can't open $file: $!";
  print LOG "  Dumping $dbname to $file ... ".&date_and_mem()."\n";
  header($fh);

  ( my $species = $conf->{'species'} ) =~ s/_/ /g;

  # get details of genes and proteins that make up the families for this species
  my $gene_names = { map { @$_ } @{$conf->{'dbh'}->selectall_arrayref(qq(
        SELECT g.stable_id, x.display_label
          FROM gene g, xref x
         WHERE g.display_xref_id = x.xref_id))}};
  my $transl = $conf->{'dbh'}->selectall_hashref(qq(
        SELECT tl.stable_id as transl, t.stable_id as trans
          FROM translation tl, transcript t
         WHERE tl.transcript_id = t.transcript_id),'transl');
#  warn
  my $gene_members = $conf->{'dbh_compara'}->selectall_hashref(qq(
        SELECT gm.gene_member_id, gm.stable_id
          FROM gene_member gm, genome_db gdb
         WHERE gm.genome_db_id = gdb.genome_db_id
           AND gm.source_name = 'ENSEMBLGENE'
           AND gdb.name = '$dbspecies'),'gene_member_id');
  my $protein_members = $conf->{'dbh_compara'}->selectall_hashref(qq(
        SELECT sm.seq_member_id, sm.stable_id
          FROM seq_member sm, genome_db gdb
         WHERE sm.genome_db_id = gdb.genome_db_id
           AND sm.source_name = 'ENSEMBLPEP'
           AND gdb.name = '$dbspecies'),'seq_member_id');
  #get all families
  $conf->{'dbh_compara'}->do('SET SESSION group_concat_max_len = 200000');
  my $sth = $conf->{'dbh_compara'}->prepare(qq(
    select f.stable_id,
           f.description,
           group_concat(fm.seq_member_id),
           group_concat(gm.gene_member_id)
      from family as f, family_member as fm, seq_member sm, gene_member gm
     where f.family_id = fm.family_id
       and fm.seq_member_id = sm.seq_member_id
       and sm.gene_member_id = gm.gene_member_id
       and sm.source_name not like 'Uniprot%'
     group by f.stable_id ));
  $sth->execute();
  my $X = $conf->{'authority'} || 'Ensembl';
  while( my( $fid, $desc, $seq_member_ids,$gene_member_ids ) = $sth->fetchrow_array()) {
    $desc =~ s/(\S+)\/(\S+)/$1 \/ $2/g;
    my (%genes,%proteins,%transcripts);
    foreach my $gene_id (split ',',$gene_member_ids) {
      if ($gene_members->{$gene_id}) {
        my $stable_id = $gene_members->{$gene_id}{'stable_id'};
        my $display_label = $gene_names->{$stable_id} || 'none';
        $genes{$stable_id}{display_label} = $display_label;
      }
    }
    foreach my $tl_id (split ',', $seq_member_ids) {
      if ($protein_members->{$tl_id}) {
        my $tl_sid = $protein_members->{$tl_id}{'stable_id'};
        $proteins{$tl_sid}++;
        my $t_sid = $transl->{$tl_sid}{'trans'};
        $transcripts{$t_sid}++;
      }
    }
    if (%genes) {
      my $ensembl_genes_species    = scalar (keys %genes);
      my $ensembl_peptides_species = scalar (keys %proteins);
      my $genes   = $ensembl_genes_species == 1 ? 'gene' : 'genes';
      my $peptide = $ensembl_peptides_species == 1 ? 'protein' : 'proteins';
      my $full_desc = qq($X protein family $fid [$desc]: $ensembl_genes_species $genes / $ensembl_peptides_species $peptide in $species);
      &p( FamilyLine($dbspecies,$fid,$full_desc,$multi_species,\%genes,\%proteins,\%transcripts,'',$counter ), $fh);
    }
  }
  return footer( $counter->(), $fh);
}

sub FamilyLine {
  my($species,$fid,$desc,$ms,$genes,$proteins,$transcripts,$uniprots,$counter) = @_;
  my ($url,$xml);
  my $boost = $ms ? $boosts->{'Family'}{'ms'} : $boosts->{'Family'}{'species'};
  my $doc = $boost ? qq(doc boost="$boost") : 'doc';
  $desc = &clean($desc,'desc');
  $xml = qq(
<$doc>
  <field name="id">$fid</field>
  <field name="name">$fid</field>);
  if ($ms) {
    my $full_desc = "Gene family $fid ($desc) contains genes from multiple species";
    $xml .= qq(
  <field name="description">$full_desc</field>);
    foreach my $up (@$uniprots){
      $xml .= qq(
  <field name="assoc_protein">$up</field>);
    }
    $url = sprintf(qq(Multi/Family/Details?fm=%s),$fid);
    $xml .= &common_fields($species,'Protein Family','compara');
    $xml .= qq(
  <field name="domain_url">$url</field>);
  }
  else {
    $xml .= qq(
  <field name="description">$desc</field>);
    my $sample_g;
    my %seen_names;
    foreach my $gsi (keys %$genes){
      unless ($sample_g) {
        $sample_g = $gsi;
        $url = sprintf(qq(%s/Gene/Family?family=%s;g=%s),
                       $species,
                       $fid,
                       $sample_g,
                     );
        $species =~ s/_/ /;
      }
      $xml .= qq(
  <field name="assoc_gene">$gsi</field>);
      my $name = $genes->{$gsi}{'display_label'};
      unless ($seen_names{$name}) {
        unless ($name eq 'none') {
          $seen_names{$name}++;
          $xml .= qq(
  <field name="assoc_gene_name">$name</field>);
        }
      }
    }
    foreach my $id (keys %$proteins){
      $xml .= qq(
  <field name="assoc_protein">$id</field>);
    }
    foreach my $id (keys %$transcripts){
      $xml .= qq(
  <field name="assoc_transcript">$id</field>);
    }
    $xml .= &common_fields($species,'Protein Family','core');
    $xml .= qq(
  <field name="domain_url">$url</field>);
  }
  $xml .= qq(
</doc>);
  $counter->();
  return $xml;
}


########################################################################## Sequences

sub dumpSequence {
  my $conf = shift;
  my $sanger = {};
  my @misc_feat_disallowed = (); #features that we know we don't want to dump if we ever decide to do this (not implemented)
  my @name_order = (qw(name well_name clone_name sanger_project synonym embl_acc)); #defines the order of attribute_type we use to get the name for misc_features (comes from B::E::G::_clone.pm)
  my $dbname    = $conf->{'dbs'}{'DATABASE_CORE'};
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/${dbname}_Sequence.xml";
  my $start_time = time;
  my $db = 'core';
  my $fh;
  open( $fh, ">$file" ) or die "Can't open $file: $!";
  print LOG "  Dumping $dbname to $file ... ".&date_and_mem()."\n";
  header($fh);

  my $lrgs = &findLRGs($conf);
  if (@$lrgs) {
    &sort_lrgs($dbspecies,'Sequence',$fh,$lrgs);
  }

  #get all types of misc features - used for 'type' label
  my $feat_types = $conf->{'dbh'}->selectall_hashref(qq(
                  SELECT ms.code, ms.misc_set_id, ma.value as type
                    FROM $dbname.attrib_type at, $dbname.misc_attrib ma, $dbname.misc_feature_misc_set mfms, $dbname.misc_set ms
                   WHERE at.attrib_type_id = ma.attrib_type_id
                     AND ma.misc_feature_id = mfms.misc_feature_id
                     AND mfms.misc_set_id = ms.misc_set_id
                     AND at.code = 'type'
                   GROUP by ms.code, ma.value), 'misc_set_id');
  if (%$feat_types) {
    my $mapsets = join ',', keys %$feat_types;
    #get all misc_features
    my $sth = $conf->{'dbh'}->prepare(qq(
       SELECT mf.misc_feature_id, sr.name, cs.name, mf.seq_region_start, mf.seq_region_end,
              mf.seq_region_end-mf.seq_region_start+1 as len, ms.misc_set_id, at.code, ma.value
         FROM $dbname.misc_feature_misc_set as ms,
              $dbname.misc_feature as mf,
              seq_region as sr,
              coord_system as cs,
              $dbname.misc_attrib as ma,
              $dbname.attrib_type as at
        WHERE cs.coord_system_id = sr.coord_system_id
          AND sr.seq_region_id = mf.seq_region_id 
          AND mf.misc_feature_id = ms.misc_feature_id
          AND ms.misc_set_id in ($mapsets)
          AND mf.misc_feature_id = ma.misc_feature_id
          AND ma.attrib_type_id = at.attrib_type_id
        ORDER by mf.misc_feature_id, at.code));
    $sth->execute();
    my ($old_ID,$old_sr,$old_sr_type,$old_start,$old_end,$old_len,$NAMES,$ftype);
    while( my($ID,$sr,$sr_type,$start,$end,$len,$ms_id,$code,$val) = $sth->fetchrow_array() ) {
      if($ID == $old_ID) {
        if (! $ftype && $code eq 'type') {
          $ftype = $feat_types->{$ms_id}{'type'};
          #some hacks for the display of the type
          $ftype =~ s/_/ /;
          $ftype =~ s/arrayclone/clone/;
          $ftype = ucfirst($ftype);
        }
        if (grep {$code eq $_} @name_order) {
          push @$NAMES, [$code,$val];
        }
      }
      else {
        if ($old_ID) {
          my ($name, $synonyms) = &sort_mf_names($NAMES,\@name_order);
          &p( SeqLine($dbspecies,$old_sr,$old_sr_type,$old_start,$old_end,$old_len,$name,$synonyms,[],$ftype,$sanger,$counter), $fh);
          $NAMES = undef;
          $ftype = undef;
        }
        if (! $ftype && $code eq 'type') {
          $ftype = $feat_types->{$ms_id}{'type'};
          $ftype =~ s/_/ /;
          $ftype =~ s/arrayclone/clone/;
          $ftype = ucfirst($ftype);
        }
        if (grep {$code eq $_} @name_order) {
          push @$NAMES, [$code,$val];
        }
        ($old_ID,$old_sr,$old_sr_type,$old_start,$old_end,$old_len) = ($ID,$sr,$sr_type,$start,$end,$len);
      }
    }
    my ( $name, $synonyms) = sort_mf_names($NAMES,\@name_order);
    &p( SeqLine($dbspecies,$old_sr,$old_sr_type,$old_start,$old_end,$old_len,$name,$synonyms,[],$ftype,$sanger,$counter), $fh);
  }

  #identify current default top level
  (my $current_cs_id) = $conf->{'dbh'}->selectrow_array(qq(
       SELECT cs.coord_system_id
         FROM coord_system cs, meta m
        WHERE cs.version = m.meta_value
          AND cs.name = 'chromosome'
          AND m.meta_key = 'assembly.default'));

  my %patch_hap_dets = ();
  # get seq_region_synonyms and start / stop positions for patches (ensembl)
  #  - requires the supercontig (which has the seq_region_synonym) and the chromosome to have the same name
  #  - positions come from assembly_exception table
  my $sth = $conf->{'dbh'}->prepare(qq(
       SELECT sr2.name, srs.synonym, ae.seq_region_start, ae.seq_region_end
         FROM coord_system cs, seq_region sr2, assembly_exception ae, seq_region sr1
            LEFT JOIN seq_region_synonym srs ON sr1.seq_region_id = srs.seq_region_id
       WHERE sr1.name = sr2.name
         AND sr1.coord_system_id != sr2.coord_system_id
         AND sr1.coord_system_id = cs.coord_system_id
         AND sr2.seq_region_id = ae.seq_region_id));
  $sth->execute;
  while (my ($name, $grc_name, $start, $end) = $sth->fetchrow_array() ) {
    $patch_hap_dets{$name} = {
      'name' => $name,
      'syn'  => $grc_name,
      'start'=> $start,
      'end'   => $end,
    };
  }


  #for Vega - get Ensembl chromosome names if they're different from the vega names
  my %enames = ();
  if ($sitetype eq 'Vega') {
    $sth = $conf->{'dbh'}->prepare(qq(
       SELECT sr.name, sra.value
         FROM seq_region sr, seq_region_attrib sra, attrib_type at
        WHERE sr.seq_region_id = sra.seq_region_id
          AND sra.attrib_type_id = at.attrib_type_id
          AND sr.name != sra.value
          AND at.code = 'ensembl_name'));
    $sth->execute;
    while (my ($v_name, $e_name) = $sth->fetchrow_array() ) {
      $enames{$v_name} = $e_name;
    }
    #get seq_region_synonyms and start / stop positions for patches (vega)
    %patch_hap_dets = ();
    $sth = $conf->{'dbh'}->prepare(qq(
              SELECT sr.name, concat(sra1.value,'.',sra2.value) as synonym,  ae.seq_region_start, ae.seq_region_end
                FROM assembly_exception ae, seq_region sr, seq_region_attrib sra1, attrib_type at1, seq_region_attrib sra2, attrib_type at2
               WHERE sr.seq_region_id    = ae.seq_region_id
                 AND sr.seq_region_id    = sra1.seq_region_id
                 AND sra1.attrib_type_id = at1.attrib_type_id
                 AND at1.code            = 'embl_acc'
                 AND sr.seq_region_id    = sra2.seq_region_id
                 AND sra2.attrib_type_id = at2.attrib_type_id
                 AND at2.code            = 'embl_version'));
    $sth->execute;
    while (my ($name, $grc_name, $start, $end) = $sth->fetchrow_array() ) {
      $patch_hap_dets{$name} = {
        'name' => $name,
        'syn'  => $grc_name,
        'start'=> $start,
        'end'   => $end,
      };
    }
  }

  #haplotypes
  $sth = $conf->{'dbh'}->prepare(qq(
       SELECT sr.name, ae.seq_region_start, ae.seq_region_end
         FROM assembly_exception ae, seq_region sr
        WHERE ae.seq_region_id = sr.seq_region_id
          AND ae.exc_type = 'HAP'));
  $sth->execute;
  while (my ($name, $start, $end) = $sth->fetchrow_array() ) {
    $patch_hap_dets{$name} = {
      'name' => $name,
      'start'=> $start,
      'end'   => $end,
    };
  }

  #get all seq_regions
  $sth = $conf->{'dbh'}->prepare(qq(
       SELECT sr.name, sr.length, cs.name, cs.coord_system_id, srs.synonym
         FROM coord_system as cs, seq_region as sr
         LEFT JOIN seq_region_synonym as srs on sr.seq_region_id = srs.seq_region_id
        WHERE sr.coord_system_id = cs.coord_system_id));
  $sth->execute();
  my ($old_name,$old_type,$old_length,$old_start,$old_end);
  my $synonyms = [];
  my $other_names = [];
  while( my($name,$length,$type,$cs_id,$syn) = $sth->fetchrow_array() ) {
    my ($prev_name,$prev_length,$mapping_text);
    next if $type eq 'lrg'; #we've done LRGs already
    next if $type eq 'supercontig' && $patch_hap_dets{$name}; #don't index the supercontig with PATCH name
    next if ($type eq 'chromosome') && ($cs_id != $current_cs_id); #don't index chromosomes from previous assemblies
    if ($old_name eq $name) {
      push @$synonyms, $syn if $syn;
    }
    else {
      if ($old_name) {
        &p( SeqLine($dbspecies,$old_name,$old_type,$old_start,$old_end,$old_length,$old_name,$synonyms,$other_names,$old_type,$sanger,$counter), $fh);
      }
      $old_name = $name;
      $old_type = $type;
      $old_length = $length;
      $synonyms = [];
      $other_names = [];
      if (my $ename = $enames{$name}) {
        push @$other_names, $ename;
      }
      push @$synonyms, $syn if $syn;

      #set different seq_region start and stop, add a synonym, for Patches
      if ($patch_hap_dets{$old_name}) {
        $old_end = $patch_hap_dets{$old_name}{'end'};
        $old_start = $patch_hap_dets{$old_name}{'start'};
        if ($patch_hap_dets{$old_name}{'syn'}) {
          push @$synonyms, $patch_hap_dets{$old_name}{'syn'} unless (grep {$syn eq $_} @$synonyms);
        }
      }
      else {
        $old_end = $length;
        $old_start = 1;
      }
    }
  }
  &p( SeqLine($dbspecies,$old_name,$old_type,$old_start,$old_end,$old_length,$old_name,$synonyms,$other_names,$old_type,$sanger,$counter), $fh);
  return footer( $counter->(), $fh);
}

#decide which of the possible many name entries we should be using, the rest will be synonyms
sub sort_mf_names {
  my ($all_names, $name_order) = @_;
  my $name_to_use;
  foreach my $name_type ( @$name_order ) {
    unless ($name_to_use) {
      foreach my $name (@$all_names) {
        if ($name->[0] eq $name_type) {
          $name_to_use = $name->[1];
        }
      }
    }
  }
  my @synonyms = map {$_->[1]} grep { $_->[1] ne $name_to_use } @$all_names;
  return $name_to_use, \@synonyms ;
}

sub SeqLine {
  my($species,$sr,$sr_type,$start,$end,$len,$name,$synonyms,$other_names,$type,$sanger,$counter) = @_;
  print LOG "WARNING: no type set for $name" unless $type;
  my $action = $len > 0.5e6 ? 'Overview' : 'View';
  my $r = "$sr:$start-$end";
  my $url = sprintf(qq(%s/Location/%s?r=%s),
                    $species,
                    $action,
                    $r);
  $species =~ s/_/ /;

  my $desc = ($name eq $sr) ? "$type $name has a length of $len bp." : "$type $name (length $len bp) is mapped to $sr_type $sr.";
  #deal with any synonyms
  if (@$synonyms) {
    $desc .= " It has synonyms of " . join(',',@$synonyms) . ".";
  }

  my $xml = qq(
<doc>
  <field name="id">$name</field>
  <field name="description">$desc</field>);
  foreach my $syn (@$synonyms, @$other_names) {
    $xml .= qq(
  <field name="synonym">$syn</field>);
  }
  $xml .= &common_fields($species,'Sequence','core');
  $xml .= qq(
  <field name="domain_url">$url</field>
</doc>);
  $counter->();
  return $xml;
}

########################################################################## Genes

#contains hacks to exclude rnaseq, refseq and ccds_import

sub dumpGene {
  my $conf      = shift;
  my $dbspecies = $conf->{'species'};
  my $COREDB    = $conf->{'dbs'}->{'DATABASE_CORE'};
  my $ESTGENEDB = $conf->{'dbs'}->{'DATABASE_OTHERFEATURES'};
  my $RNASEQDB = $conf->{'dbs'}->{'DATABASE_RNASEQ'};
  my %dbs = ( 'core' => $COREDB );
#  $dbs{'rnaseq'} = $RNASEQDB if $RNASEQDB; #don't add these until the IDs mean something and the gene pages are usefull!
  my $total_c;

# lookup orthologs for later
  my $has_orthologues = ();
  my $sql = qq(
       SELECT stable_id
         FROM gene_member gm, gene_member_hom_stats gmhs
        WHERE gm.gene_member_id = gmhs.gene_member_id
          AND gmhs.collection = 'default'
          AND gmhs.orthologues);
  my $sth = $conf->{'dbh_compara'}->prepare($sql);
  $sth->execute;
  while (my $r = $sth->fetchrow_arrayref()) {
      $has_orthologues->{$r->[0]}=1;
   }

 DB:
  foreach my $db ( sort { $b cmp $a } keys %dbs) {
    my $dbname    = $dbs{$db};
    my $counter   = make_counter(0);
    my $file = $conf->{'directory'}."/${dbname}_Gene.xml";
    my $start_time = time;
    my $fh;
    open( $fh, ">$file" ) or die "Can't open $file: $!";
    print LOG "  Dumping $dbname to $file ... ".&date_and_mem()."\n";
    header($fh);

    #does this species have PATCHES
    (my $has_patches) = $conf->{'dbh'}->selectrow_array(qq(select count(*) from assembly_exception where exc_type != 'PAR'));

    my $external_dbs = $conf->{'dbh'}->selectall_hashref(
      'select external_db_id, db_display_name, db_name
         from external_db', 'external_db_id'
       );
    my $external_synonyms;
    my $es = $conf->{'dbh'}->selectall_arrayref(qq(select xref_id, synonym from external_synonym));
    foreach (@$es) {
      $external_synonyms->{$_->[0]}{$_->[1]} = 1;
    }

    my @xrefs_to_skip = qw(goslim_goa);
    my %xrefs = ();
    foreach my $type( qw(Gene Transcript Translation) ) {
      my $t = lc($type);
      my $sql = qq(
         SELECT f.stable_id, x.external_db_id, x.display_label, x.description, x.xref_id
           FROM $dbname.$t as f, $dbname.object_xref as ox, $dbname.xref as x
          WHERE f.${t}_id = ox.ensembl_id
            AND ox.xref_id = x.xref_id 
            AND ox.ensembl_object_type = '$type');
      my $T = $conf->{'dbh'}->selectall_arrayref($sql);
      foreach (@$T) {
        my $stable_id         = $_->[0];
        my $external_db_label = $_->[2];
        my $external_db_desc  = $_->[3];
        my $xref_id           = $_->[4];
        my $external_db = $external_dbs->{$_->[1]}{'db_display_name'};
        my $db_name = $external_dbs->{$_->[1]}{'db_name'};
        next if (grep {$db_name eq $_} @xrefs_to_skip);
        my $desc        = "$external_db_label ($external_db";
        my $search_term = "$external_db_label";
        if ($external_db_desc) {
          $external_db_desc =~ s/ $//;
          $desc .= " record; description: $external_db_desc')";
          $search_term .= " $external_db_desc";
        }
        else {
          $desc .= ')'; 
        }
        my $ext_syns;
        if ($external_synonyms->{$xref_id}) {
          my $syn_c = keys(%{$external_synonyms->{$xref_id}});
          $desc .= $syn_c > 1 ? ', with synonyms of' : ', with a synonym of';
          foreach my $syn (keys %{$external_synonyms->{$xref_id}}) {
            $search_term .= " $syn";
            $desc .= " $syn,";
            $ext_syns->{$syn}++,
          };

        }
        $desc .= " is an external reference matched to $type $stable_id";
        push @{$xrefs{$type}{$stable_id}},{
          id          => $external_db_label,
          search_term => $search_term,
          desc        => $desc,
          external_syns => $ext_syns,
        };
      }
      print LOG "    $type xref query done ".&date_and_mem()."\n";
    }
#        warn Dumper(\%xrefs); exit;

    my %gene_trans_syns = ();
    if ($sitetype eq 'Vega') {
      print LOG "    Getting gene and transcript synonyms ".&date_and_mem()."\n";
      my ($gc,$tc) = (0,0);
      my $sql = qq(
         SELECT g.stable_id, ga.value
           FROM $dbname.gene g, $dbname.gene_attrib ga, $dbname.attrib_type at
          WHERE g.gene_id = ga.gene_id
            AND ga.attrib_type_id = at.attrib_type_id
            AND at.code = 'synonym');
      my $G = $conf->{'dbh'}->selectall_arrayref($sql);
      foreach (@$G) {
        $gc++;
        push @{$gene_trans_syns{$_->[0]}},$_->[1];
      }
      $sql = qq(
         SELECT t.stable_id, ta.value
           FROM $dbname.transcript t, $dbname.transcript_attrib ta, $dbname.attrib_type at
          WHERE t.transcript_id = ta.transcript_id
            AND ta.attrib_type_id = at.attrib_type_id
            AND at.code = 'synonym');
      my $T = $conf->{'dbh'}->selectall_arrayref($sql);
      foreach (@$T) {
        $tc++;
        push @{$gene_trans_syns{$_->[0]}},$_->[1];
      }
      print LOG "    Got $gc gene and $tc transcript synonyms ".&date_and_mem()."\n";
    }

    my %exons = ();
    my $sql = qq(
       SELECT distinct t.gene_id, e.stable_id
         FROM $dbname.transcript as t, $dbname.exon_transcript as et, $dbname.exon as e
        WHERE t.transcript_id = et.transcript_id
          AND et.exon_id = e.exon_id);
    my $sth = $conf->{'dbh'}->prepare($sql);
    $sth->execute;
    while (my $r = $sth->fetchrow_arrayref()) {
      $exons{$r->[0]}{$r->[1]}=1;
    }
    $sth->finish;
    print LOG "    Exon query done ".&date_and_mem()."\n";

    $sql = qq(
      SELECT g.stable_id, sr.name as sr_name, g.seq_region_start, g.seq_region_end, g.seq_region_strand, cs.name as sr_type, cs.version,
             (SELECT sra.value 
                FROM $dbname.seq_region_attrib sra, $dbname.attrib_type at
               WHERE sr.seq_region_id = sra.seq_region_id
                 AND sra.attrib_type_id = at.attrib_type_id
                 AND at.code = 'non_ref') as non_ref
        FROM $dbname.gene g, $dbname.coord_system cs, $dbname.seq_region sr
       WHERE g.seq_region_id = sr.seq_region_id 
         AND sr.coord_system_id = cs.coord_system_id);
    my $gene_locations = $conf->{'dbh'}->selectall_hashref($sql,'stable_id');
    $sql = qq(
      SELECT g.gene_id, t.transcript_id, tr.translation_id,
             g.stable_id as gsid, g.version as gversion, t.stable_id as tsid, t.version as tversion, tr.stable_id as trsid, tr.version as trversion,
             g.description, x.display_label, ad.display_label, ad.web_data, ad.displayable, g.biotype, a.logic_name
        FROM (( $dbname.gene as g,
             $dbname.analysis as a,
             $dbname.analysis_description as ad,
             $dbname.transcript as t) left join
             $dbname.translation as tr on t.transcript_id = tr.transcript_id) left join
             $dbname.xref as x on g.display_xref_id = x.xref_id
       WHERE t.gene_id = g.gene_id
         AND g.analysis_id = a.analysis_id
         AND g.analysis_id = ad.analysis_id
         AND a.logic_name != 'LRG_import'
       ORDER by g.stable_id, t.stable_id);
    $sth = $conf->{'dbh'}->prepare($sql);
    $sth->execute();

    my $old;
    my $c;
    my ($gid,$tid,$tlid,$gsid,$gver,$tsid,$tver,$tlsid,$tlver,$desc,$disp_xref,$ad_dl,$webdata,$displayable,$biotype,$ln);
    while (my $r = $sth->fetchrow_arrayref()) {
      ($gid,$tid,$tlid,$gsid,$gver,$tsid,$tver,$tlsid,$tlver,$desc,$disp_xref,$ad_dl,$webdata,$displayable,$biotype,$ln) = @$r;
      my $wd = eval($webdata);
      next if $wd->{'gene'}{'do_not_display'};
      next if ($ln =~ /rnaseq/);
      if( $old->{'gid'} != $gid ) {
        if( $old->{'gid'} ) {
          my $type = $old->{'biotype'}.' '.$old->{'ad_dl'};
         (my $old_gsi) = keys %{$old->{'gsid'}};
          &p( GeneTransLine('Gene',
                       $dbspecies,
                       $old->{'gsid'},
                       $old->{'tsids'},
                       $old->{'tlsids'},
                       $old->{'exons'},
                       $old->{'biotype'},
                       $old->{'ad_dl'},
                       $old->{'disp_xref'},
                       $old->{'desc'},
                       $old->{'xrefs'},
                       $old->{'synonyms'},
                       '',
                       '',
                       $gene_locations->{$old_gsi},
                       $has_patches,
                       $has_orthologues->{$gsid} ? 1 : 0,
                       $db,
                       $counter),
              $fh);
          $c++;
        }

        $old = {
          'gid'       => $gid,
          'gsid'      => { $gsid => $gver },
          'tlsids'    => { $tlsid ? ($tlsid => $tlver)  :()},
          'tsids'     => { $tsid  ? ($tsid  => $tver) :()},
          'desc'      => $desc,
          'exons'     => {},
          'biotype'   => $biotype,
          'ad_dl'     => $ad_dl,
          'xrefs'     => [],
          'synonyms'  => [ @{$gene_trans_syns{$gsid}||[]}, @{$gene_trans_syns{$tsid}||[]} ],
          'disp_xref' => $disp_xref ? "$disp_xref" : "novel gene",
          'biotype'   => $biotype,
          'ad_dl'     => $ad_dl,
        };

        $old->{'exons'}  = $exons{$gid};

        #add xref details
        foreach my $type (qw(Gene Transcript Translation)) {
          my $id = ($type eq 'Gene')        ? $gsid
                 : ($type eq 'Transcript')  ? $tsid
                 : ($type eq 'Translation') ? $tlsid
                 : '';
          foreach my $xref (@{$xrefs{$type}{$id}}) {
            push @{$old->{'xrefs'}}, $xref;
          }
        }
      }
      else {
        $old->{'tsids' }{$tsid }= ($tsid  => $tver);
        $old->{'tlsids'}{$tlsid}= ($tlsid => $tlver) if $tlsid;
        push @{$old->{'synonyms'}}, @{$gene_trans_syns{$tsid}||[]};

        #add xref details
        foreach my $type (qw(Gene Transcript Translation)) {
          my $id = ($type eq 'Gene')        ? $gsid
                 : ($type eq 'Transcript')  ? $tsid
                 : ($type eq 'Translation') ? $tlsid
                 : '';
          foreach my $xref (@{$xrefs{$type}{$id}}) {
            push @{$old->{'xrefs'}}, $xref;
          }
        }
      }
    }
    if ($old->{'gsid'}) {
      (my $old_gsi) = keys %{$old->{'gsid'}};
      &p( GeneTransLine('Gene',
                        $dbspecies,
                        $old->{'gsid'},
                        $old->{'tsids'},
                        $old->{'tlsids'},
                        $old->{'exons'},
                        $old->{'biotype'},
                        $old->{'ad_dl'},
                        $old->{'disp_xref'},
                        $old->{'desc'},
                        $old->{'xrefs'},
                        $old->{'synonyms'},
                        '',
                        '',
                        $gene_locations->{$old_gsi},
                        $has_patches,
                        $has_orthologues->{$old->{'gsid'}} ? 1 : 0,
                        $db,
                        $counter),
          $fh);
      $c++;
    }
    print LOG "    Querying done, added $c entries ".&date_and_mem()."\n";

    #archive Stable IDs
    my $other_count = &do_archive_stable_ids( [ 'gene' ], $dbname, $db, $fh, $counter );

    print LOG "    Stable_id mapping querying done, added $other_count entries ".&date_and_mem()."\n";
    $total_c += footer( $counter->(), $fh);

    #this code for unmapped entries has not been used for a long time and will not work
    while (0) {
      $other_count = 0;
      my %unmapped_queries = (
        'None' => qq(
      select a.logic_name, e.db_display_name,
             uo.identifier, ur.summary_description,
             'Not mapped'
        from $dbname.analysis as a, $dbname.external_db as e, $dbname.unmapped_object as uo,
             $dbname.unmapped_reason as ur
       where a.analysis_id = uo.analysis_id and
             uo.external_db_id = e.external_db_id and
             uo.unmapped_reason_id = ur.unmapped_reason_id and
               uo.ensembl_id = 0
       ),
       'Transcript' => qq(
      select a.logic_name, e.db_display_name,
             uo.identifier, ur.summary_description,
             concat( 'Transcript: ', t.stable_id, '; Gene: ',g.stable_id )
        from $dbname.analysis as a, $dbname.external_db as e, $dbname.unmapped_object as uo,
             $dbname.unmapped_reason as ur, $dbname.transcript as t, $dbname.gene as g
       where a.analysis_id = uo.analysis_id and
             uo.external_db_id = e.external_db_id and
             uo.unmapped_reason_id = ur.unmapped_reason_id and
             uo.ensembl_id = t.transcript_id and
             uo.ensembl_object_type = 'Transcript' and
             t.gene_id       = g.gene_id
       ),
        'Translation' => qq(
      select a.logic_name, e.db_display_name, uo.identifier, ur.summary_description,
             concat( 'Protein: ',tr.stable_id,'; Transcript: ', t.stable_id, '; Gene: ',g.stable_id )
        from $dbname.analysis as a, $dbname.external_db as e, $dbname.unmapped_object as uo,
             $dbname.unmapped_reason as ur, $dbname.translation as tr, $dbname.transcript as t, $dbname.gene as g
       where a.analysis_id = uo.analysis_id and
             uo.external_db_id = e.external_db_id and
             uo.unmapped_reason_id = ur.unmapped_reason_id and
             uo.ensembl_id = tr.translation_id and
             tr.transcript_id = t.transcript_id and
             uo.ensembl_object_type = 'Translation' and
             t.gene_id = gsi.gene_id
       ),
      );
      foreach my $FLAG (keys %unmapped_queries) {
        my $SQL = $unmapped_queries{$FLAG};
        my $sth = $conf->{'dbh'}->prepare($SQL);
        $sth->execute;
        while( my $T = $sth->fetchrow_arrayref() ) {
          print O join "\t",
            qq(Unmapped feature),
              "$T->[1] $T->[2]",
                "/$conf->{'species'}/Location/Genome?ftype=Gene;id=$T->[2]",
                  "$T->[2] $T->[4]",
                    "$T->[3]; $T->[4]\n";
        }
      }
    }
    close O;
  }
  return $total_c;
}


########################################################################## Transcripts

sub dumpTranscript {
  my $conf      = shift;
  my $dbspecies = $conf->{'species'};
  my $COREDB    = $conf->{'dbs'}->{'DATABASE_CORE'};
  my $ESTGENEDB = $conf->{'dbs'}->{'DATABASE_OTHERFEATURES'};
  my $RNASEQDB  = $conf->{'dbs'}->{'DATABASE_RNASEQ'};
  my %dbs = ( 'core' => $COREDB );
#  $dbs{'rnaseq'} = $RNASEQDB if $RNASEQDB; #don't add these until the IDs mean something and the transcript pages are usefull
  my $total_c;

 DB:
  foreach my $db ( sort { $b cmp $a } keys %dbs) {
    my $dbname    = $dbs{$db};
    my $counter   = make_counter(0);
    my $file = $conf->{'directory'}."/${dbname}_Transcript.xml";
    my $start_time = time;
    my $fh;
    open( $fh, ">$file" ) or die "Can't open $file: $!";
    print LOG "  Dumping $dbname to $file ... ".&date_and_mem()."\n";
    header($fh);

    #does this species have PATCHES
    (my $has_patches) = $conf->{'dbh'}->selectrow_array(qq(select count(*) from assembly_exception where exc_type != 'PAR'));

    my $external_dbs = $conf->{'dbh'}->selectall_hashref(
      'select external_db_id, db_name, db_display_name, description
         from external_db', 'external_db_id'
       );
    my $external_synonyms;
    my $es = $conf->{'dbh'}->selectall_arrayref(qq(select xref_id, synonym from external_synonym));
    foreach (@$es) {
      $external_synonyms->{$_->[0]}{$_->[1]} = 1;
    }

    #get protein_feature domains
    my $protein_domains = {};
    my $sql = qq(
       SELECT t.transcript_id, x.dbprimary_acc, i.id
         FROM xref x, interpro i, protein_feature pf, translation tl, transcript t
        WHERE x.dbprimary_acc = i.interpro_ac
          AND i.id = pf.hit_name
          AND pf.translation_id = tl.translation_id
          AND tl.transcript_id = t.transcript_id);
    my $sth = $conf->{'dbh'}->prepare($sql);
    $sth->execute();
    while (my ($tsi,$hit,$syn) = $sth->fetchrow_array()) {
      $protein_domains->{$tsi}{$hit}{$syn}++;
    }

    my %xrefs = ();
    my @xrefs_to_skip = qw(GO goslim_goa);
    foreach my $type( qw(Transcript Translation) ) {
      my $t = lc($type);
      my $sql = qq(
         SELECT f.stable_id, x.external_db_id, x.display_label, x.description, x.xref_id
           FROM $dbname.$t as f, $dbname.object_xref as ox, $dbname.xref as x
          WHERE f.${t}_id = ox.ensembl_id
            AND ox.xref_id = x.xref_id
            AND ox.ensembl_object_type = '$type');
      my $T = $conf->{'dbh'}->selectall_arrayref($sql);
      foreach (@$T) {
        my $stable_id         = $_->[0];
        my $external_db_label = $_->[2];
        my $external_db_desc  = $_->[3];
        my $xref_id           = $_->[4];
        my $external_db = $external_dbs->{$_->[1]}{'db_display_name'};
        my $db_name =  $external_dbs->{$_->[1]}{'db_name'};
        next if (grep {$db_name eq $_} @xrefs_to_skip);
        my $desc        = "$external_db_label ($external_db";
        my $search_term = "$external_db_label";
        if ($external_db_desc) {
          $external_db_desc =~ s/ $//;
          $desc .= " record; description: $external_db_desc)";
          $search_term .= " $external_db_desc";
        }
        else {
          $desc .= ')'; 
        }
        my $ext_syns;
        if ($external_synonyms->{$xref_id}) {
          my $syn_c = keys(%{$external_synonyms->{$xref_id}});
          $desc .= $syn_c > 1 ? ', with synonyms of' : ', with a synonym of';
          foreach my $syn (keys %{$external_synonyms->{$xref_id}}) {
            $search_term .= " $syn";
            $desc .= " $syn,";
            $ext_syns->{$syn}++,
           }
        }
        $desc .= " is an external reference matched to $type $stable_id";
        push @{$xrefs{$type}{$stable_id}},{
          id          => $external_db_label,
          search_term => $search_term,
          desc        => $desc,
          external_syns => $ext_syns,
        };
      }
      print LOG "    $type xref query done ".&date_and_mem()."\n";
    }

    my $supporting_evidence;
    foreach my $t ('dna_align_feature','protein_align_feature') {
      my $sql = qq(
        SELECT t.stable_id, f.hit_name, edb.db_display_name
          FROM transcript t, transcript_supporting_feature tsf, $t f
          LEFT JOIN external_db edb ON f.external_db_id = edb.external_db_id
         WHERE t.transcript_id = tsf.transcript_id
           AND tsf.feature_id = f.${t}_id and tsf.feature_type = '$t');
      my $sth = $conf->{'dbh'}->prepare($sql);
      $sth->execute();
      while (my ($tsi,$hit,$db) = $sth->fetchrow_array()) {
        $supporting_evidence->{$tsi}{$db}{$hit}++;
      }
      $sql = qq(
        SELECT t.stable_id, f.hit_name, edb.db_display_name
          FROM transcript t, exon_transcript et, supporting_feature sf, $t f
          LEFT JOIN external_db edb ON f.external_db_id = edb.external_db_id
         WHERE t.transcript_id = et.transcript_id
           AND et.exon_id = sf.exon_id
           AND sf.feature_id = f.${t}_id
           AND sf.feature_type = '$t');
      $sth = $conf->{'dbh'}->prepare($sql);
      $sth->execute();
      while (my ($tsi,$hit,$db) = $sth->fetchrow_array()) {
        $supporting_evidence->{$tsi}{$db}{$hit}++;
      }
    }

    print LOG "    Supporting evidence query done... ".&date_and_mem()."\n";

#    warn Data::Dumper::Dumper($supporting_evidence); exit;

    my %trans_syns = ();
    if ($sitetype eq 'Vega') {
      print LOG "    Getting transcript synonyms ".&date_and_mem()."\n";
      my $sql = qq(
         SELECT t.stable_id, ta.value
           FROM $dbname.transcript t, $dbname.transcript_attrib ta, $dbname.attrib_type at
          WHERE t.transcript_id = ta.transcript_id
            AND ta.attrib_type_id = at.attrib_type_id
            AND at.code = 'synonym');
      my $T = $conf->{'dbh'}->selectall_arrayref($sql);
      foreach (@$T) {
        push @{$trans_syns{$_->[0]}},$_->[1];
      }
      print LOG "    Got transcript synonyms ".&date_and_mem()."\n";
    }

    my %exons = ();
    my $sql = qq(
       SELECT t.transcript_id, e.stable_id
         FROM $dbname.transcript as t, $dbname.exon_transcript as et, $dbname.exon as e
        WHERE t.transcript_id = et.transcript_id
          AND et.exon_id = e.exon_id);
    my $sth = $conf->{'dbh'}->prepare($sql);
    $sth->execute;
    while (my $r = $sth->fetchrow_arrayref()) {
      $exons{$r->[0]}{$r->[1]}=1;
    }
    $sth->finish;
    print LOG "    Exon query done ".&date_and_mem()."\n";

    #get descriptions for the genes to use if none have been assigned to the transcript
    my $gene_desc = $conf->{'dbh'}->selectall_hashref(qq(
      SELECT t.transcript_id, g.description
        FROM transcript t, gene g
       WHERE t.gene_id = g.gene_id),
     'transcript_id');

    $sql = qq(
      SELECT t.stable_id, sr.name as sr_name, t.seq_region_start, t.seq_region_end, t.seq_region_strand, cs.name as sr_type, cs.version,
            (SELECT sra.value
                FROM $dbname.seq_region_attrib sra, $dbname.attrib_type at
               WHERE sr.seq_region_id = sra.seq_region_id
                 AND sra.attrib_type_id = at.attrib_type_id
                 AND at.code = 'non_ref') as non_ref
        FROM $dbname.transcript t, $dbname.seq_region sr, $dbname.coord_system cs
       WHERE t.seq_region_id = sr.seq_region_id
         AND sr.coord_system_id = cs.coord_system_id);
    my $trans_locations = $conf->{'dbh'}->selectall_hashref($sql,'stable_id');
    $trans_locations->{'has_patches'} = $has_patches;
    $sql = qq(
      SELECT t.transcript_id, tr.translation_id, t.stable_id as tsid, t.version as tversion, tr.stable_id as trsid, tr.version as trversion,
             t.description, x.display_label, ad.display_label, ad.web_data, ad.displayable, t.biotype, a.logic_name
        FROM (( $dbname.analysis_description as ad,
             $dbname.analysis as a,
             $dbname.transcript as t) left join
             $dbname.translation as tr on t.transcript_id = tr.transcript_id) left join
             $dbname.xref as x on t.display_xref_id = x.xref_id
       WHERE t.analysis_id = a.analysis_id
         AND a.analysis_id = ad.analysis_id
         AND a.logic_name != 'LRG_import'
       ORDER by t.stable_id);
    $sth = $conf->{'dbh'}->prepare($sql);
    $sth->execute();

    my $old;
    my $c = 0;
    my ($tid,$tlid,$tsid,$tver,$tlsid,$tlver,$desc,$disp_xref,$ad_dl,$webdata,$displayable,$biotype,$ln);
    while (my $r = $sth->fetchrow_arrayref()) {
      ($tid,$tlid,$tsid,$tver,$tlsid,$tlver,$desc,$disp_xref,$ad_dl,$webdata,$displayable,$biotype,$ln) = @$r;
      $desc = $desc ? $desc : $gene_desc->{$tid}{'description'} ? $gene_desc->{$tid}{'description'} : '';
      my $wd = eval($webdata);
      next if $wd->{'gene'}{'do_not_display'};
      next if ($ln =~ /rnaseq/);
      if( $old->{'tid'} != $tid ) {
        if( $old->{'tid'} ) {
          my $type = $old->{'biotype'}.' '.$old->{'ad_dl'};
    (my $old_tsi) = keys %{$old->{'tsid'}};
          &p( GeneTransLine('Transcript',
                        $dbspecies,
                        $old->{'tsid'},
                        {},
                        $old->{'tlsids'},
                        $old->{'exons'},
                        $old->{'biotype'},
                        $old->{'ad_dl'},
                        $old->{'disp_xref'},
                        $old->{'desc'},
                        $old->{'xrefs'},
                        $old->{'synonyms'},
                        $old->{'supporting_evidence'},
                        $old->{'domains'},
                        $trans_locations->{$old_tsi},
                        $has_patches,
                        '',
                        $db,
                        $counter),
              $fh);
          $c++;
        }

        $old = {
          'tid'       => $tid,
          'tsid'      => { $tsid => $tver },
          'tlsids'    => { $tlsid ? ( $tlsid=>$tlver ):()},
          'desc'      => $desc,
          'exons'     => {},
          'biotype'   => $biotype,
          'ad_dl'     => $ad_dl,
          'xrefs'     => [],
          'synonyms'  => $trans_syns{$tsid} || [],
          'disp_xref' => $disp_xref ? "$disp_xref" : "novel transcript",
          'biotype'   => $biotype,
          'ad_dl'     => $ad_dl,
          'domains'   => $protein_domains->{$tid},

        };

        $old->{'exons'}  = $exons{$tid};

        #add xref details
        foreach my $type (qw(Transcript Translation)) {
          my $id = ($type eq 'Transcript')  ? $tsid
                 : ($type eq 'Translation') ? $tlsid
                 : '';
          foreach my $xref (@{$xrefs{$type}{$id}}) {
            push @{$old->{'xrefs'}}, $xref;
          }
        }

        #add supporting_evidence
        if ($supporting_evidence->{$tsid}) {
          foreach my $db (keys %{$supporting_evidence->{$tsid}}) {
            foreach my $hit (keys %{$supporting_evidence->{$tsid}{$db}}) {
              $old->{'supporting_evidence'}{$hit} = "$hit ($db) is used as supporting evidence for transcript $tsid";
            }
          }
        }
      }
      else {
        $old->{'tlsids'}{$tlsid} = $tlver if $tlsid;
        push @{$old->{'synonyms'}}, @{$trans_syns{$tsid}||[]};
        #add xref details
        foreach my $type (qw(Transcript Translation)) {
          my $id = ($type eq 'Transcript')  ? $tsid
                 : ($type eq 'Translation') ? $tlsid
                 : '';
          foreach my $xref (@{$xrefs{$type}{$id}}) {
            push @{$old->{'xrefs'}}, $xref;
          }
        }
        #add supporting_evidence
        if ($supporting_evidence->{$tsid}) {
          foreach my $db (keys %{$supporting_evidence->{$tsid}}) {
            foreach my $hit (keys %{$supporting_evidence->{$tsid}{$db}}) {
              $old->{'supporting_evidence'}{$hit} = "$hit ($db) is used as supporting evidence for transcript $tsid";
            }
          }
        }
      }
    }
    if ($old->{'tsid'}) {
      (my $old_tsi) = keys %{$old->{'tsid'}};
      &p( GeneTransLine('Transcript',
                        $dbspecies,
                        $old->{'tsid'},
                        {},
                        $old->{'tlsids'},
                        $old->{'exons'},
                        $old->{'biotype'},
                        $old->{'ad_dl'},
                        $old->{'disp_xref'},
                        $old->{'desc'},
                        $old->{'xrefs'},
                        $old->{'synonyms'},
                        $old->{'supporting_evidence'},
                        $old->{'domains'},
                        $trans_locations->{$old_tsi},
                        $has_patches,
                        '',
                        $db,
                        $counter),
          $fh) if ($old->{'tsid'});
      $c++;
    }
    print LOG "    Transcript info query done and xml generated, $c entries added ".&date_and_mem()."\n";

    my $other_count = &do_archive_stable_ids(  [ (qw(transcript translation)) ], $dbname, $db, $fh, $counter );
    print LOG "    Stable_id mapping querying done, added $other_count ".&date_and_mem()."\n";

    $total_c += footer( $counter->(), $fh);
  }
  return $total_c;
}

sub GeneTransLine {
  my ($type, $species, $id, $tsids, $tlsids, $exons, $biotype, $ad_label, $disp_xref, $desc, $xrefs, $synonyms, $supporting_evidence, $domains, $feat_loc, $has_patches, $has_orthologues, $db, $counter) = @_;

  #get stable ID of object
  my ($sid,$sid_ver);
  if (scalar(%$id) > 1) {
    print LOG "    WARNING: Multiple stable IDs for this object (".join ',',keys(%$id)."), check query\n";
  }
  else {
    ($sid,$sid_ver) = each %$id;
  }
  my $boost = 0;
  $boost += $boosts->{'GeneTrans'}{$db};
  my $ref_boost_value;
  if ($has_patches) {
    my $is_ref = $feat_loc->{'non_ref'} ? 'non_ref' : 'is_ref';
    $ref_boost_value = $boosts->{'GeneTrans'}{$is_ref};
    $boost += $ref_boost_value;
  }

  my $url = sprintf(qq(%s/%s/Summary?%s=%s&amp;db=%s),
                    $species,
                    $type,
                    ($type eq 'Gene') ?  'g' : 't',
                    $sid,
                    $db);
  my $loc;
  if ($feat_loc) {
    $loc = $feat_loc->{'sr_name'} .':'. $feat_loc->{'seq_region_start'} .'-'. $feat_loc->{'seq_region_end'} .':'. $feat_loc->{'seq_region_strand'};
  }

  my @quick_links;
  if ($type eq 'Transcript') {
    my $value = %{$tlsids} ? 'protein:1' : 'protein:0';
    push @quick_links, $value; 
  }
  else {
    my $value = $has_orthologues ? 'orthologues:1' : 'orthologues:0';
    push @quick_links, $value;  
  }

  $species =~ s/_/ /;
  $biotype =~ s/_/ /;
  $desc = &clean($desc,'desc');
  $disp_xref = &clean($disp_xref,'name');
  my $description = $desc . " [Type: $biotype $ad_label]";
  my $doc = $boost ? qq(doc boost="$boost") : 'doc';
  my $xml = qq(
<$doc>
  <field name="id">$sid</field>
  <field name="id_ver">$sid.$sid_ver</field>
  <field name="name">$disp_xref</field>
  <field name="description">$desc</field>);
  if (my $db_boost_value = $boosts->{'GeneTrans'}{$db}) {
    $xml .= qq(
  <field name="db_boost">$db_boost_value</field>);
  }
  if (defined($ref_boost_value)) {
    $xml .= qq(
  <field name="ref_boost">$ref_boost_value</field>);
  }
  $xml .= &common_fields($species,$type,$db);
  foreach (@quick_links) {
   $xml .=qq(
  <field name="quick_links">$_</field>);
  }
  my (%seen_labels,%seen_syns,%seen_sources,%labels);

  #treat supporting evidence as we do xrefs (if we decide to change it then need to update solr)
  if ($supporting_evidence) {
    foreach my $hit (keys %$supporting_evidence) {
      $hit = &clean($hit);
      $labels{$hit}++;
      my $se_desc = &clean($supporting_evidence->{$hit});
      $xml .= qq(
  <field name="_hr">$se_desc</field>);
    }
  }
  #protein domains
  if ( ($type eq 'Transcript') && $domains) {
    my %ids;
    foreach my $interpro (keys %$domains) {
      my $c = keys(%{$domains->{$interpro}});
      my $desc = "Interpro domain $interpro with $c records from signature databases (";
      foreach my $syn (keys %{$domains->{$interpro}}) {
        next if $ids{$syn};
        $ids{$syn}++;
        $syn = &clean($syn);
        $desc .= "$syn, ";
        $xml .= qq(
  <field name="prot_domain">$syn</field>);
      }
      $desc = substr $desc,0,-2;
      my $translid = (keys %{$tlsids})[0];
      $desc .= ") is found on Translation $translid";
      $xml .= qq(
  <field name="_hr">$desc</field>);
      unless ($ids{$interpro}) {
        $ids{$interpro}++;
        $interpro = &clean($interpro);
        $xml .= qq(
  <field name="prot_domain">$interpro</field>);
      }
    }
  }

  my $ext_syns;
  foreach my $xref (@$xrefs) {
    my $search_term = $xref->{'search_term'};
    my $id          = $xref->{'id'};
    my $desc        = $xref->{'desc'};

    if ($xref->{'external_syns'}) {
      foreach my $syn (keys %{$xref->{'external_syns'}}){
        $syn = &clean($syn);
        $ext_syns->{$syn}++;
      }
    }

    #remove any duplicates
    next if $seen_labels{$id};
    $seen_labels{$id}++;

    #remove any records where the hit is an Ensembl stable ID or matches the display_xref
    next if ($id eq $sid) || ( grep {$_ eq $id} keys(%$tsids), keys(%$tlsids));
    next if $id eq $disp_xref;

    $search_term = &clean($search_term);
    $labels{$search_term}++;
    $desc        = &clean($desc);
    $xml .= qq(
  <field name="_hr">$desc</field>);
  }

  my $xrefs = join ' ', keys %labels;
    $xml .= qq(
  <field name="xrefs">$xrefs</field>);
  foreach my $syn (keys %$ext_syns){
    $xml .= qq(
  <field name="name_synonym">$syn"</field>);
  } 
  my %seen_syns;
  foreach my $syn (@$synonyms) {
    next if $seen_syns{$syn};
    $seen_syns{$syn} = 1;
    $xml .= qq(
  <field name="name_synonym">$syn"</field>);
  }
  if (my $t_count = keys %$tsids) {
    $xml .= qq(
  <field name="transcript_count">$t_count</field>);
    while (my ($tsi,$tsi_ver) = each %$tsids) {
      $xml .= qq(
  <field name="transcript">$tsi</field>
  <field name="transcript_ver">$tsi.$tsi_ver</field>);
    }
  }
  if (my $tl_count = keys %$tlsids) {
    $xml .= qq(
  <field name="translation_count">$tl_count</field>);
    while ( my ($tlsi, $tlsi_ver) = each %$tlsids) {
      $xml .= qq(
  <field name="peptide">$tlsi</field>
  <field name="peptide_ver">$tlsi.$tlsi_ver</field>);
    }
  }
  if (my $e_count = keys %$exons) {
    $xml .= qq(
  <field name="exon_count">$e_count</field>);
    foreach my $esi (keys %$exons) {
      $xml .= qq(
  <field name="exon">$esi</field>);
    }
  }

  #these are not to be searchable, but would be good to facete on database
  if ($loc) {
    $xml .= qq(
  <field name="location">$loc</field>);
  }
  $xml .= qq(
  <field name="source">$ad_label</field>
  <field name="domain_url">$url</field>);
  $xml .= qq(
</doc>);

  $counter->();
  return $xml;
}


## methods for archive stable IDs (called by genes and transcripts) ##

sub do_archive_stable_ids {
  my ($types,$dbname,$db,$fh,$counter) = @_;
  my $dbspecies = $conf->{'species'};
  my $COREDB    = $conf->{'dbs'}->{'DATABASE_CORE'};
  my %current_stable_ids =();
  foreach my $type (@$types) {
    $current_stable_ids{$type} = { map {@$_} @{$conf->{'dbh'}->selectall_arrayref( "select stable_id,1 from $COREDB.$type" )}};
  }
  my $types = join "','",@$types;
  my $species = $conf->{'species'};
  my $sth = $conf->{'dbh'}->prepare( qq(
    SELECT sie.type, sie.old_stable_id, if(isnull(sie.new_stable_id),'NULL',sie.new_stable_id),
           ms.old_release*1.0 as X, ms.new_release*1.0 as Y
      FROM $dbname.mapping_session as ms, $dbname.stable_id_event as sie
     WHERE ms.mapping_session_id = sie.mapping_session_id 
       AND sie.type in ('$types')
       AND ( old_stable_id != new_stable_id or isnull(new_stable_id) )
     ORDER by Y desc, X desc
  ));

  $sth->execute();
  my %mapping = ();
  while( my($type,$osi,$nsi,$old_release,$new_release) = $sth->fetchrow_array() ) {
    next if $current_stable_ids{$type}{$osi}; ## Don't want to show current stable IDs.
    next if $osi eq $nsi; ##
    #if the mapped ID is current set it as an example, as long as it's post release 62
    if ( ! $mapping{$type}{$osi}{'example'} && $new_release > 62) {
      if ($current_stable_ids{$type}{$nsi}) {
        $mapping{$type}{$osi}{'example'} = $nsi;
      }
    }
    $mapping{$type}{$osi}{'matches'}{$nsi}++;
  }
  my $other_count = 0;
  foreach my $type ( keys %mapping ) {
    foreach my $osi ( keys %{$mapping{$type}} ) {
      my @current_sis = ();
      my @deprecated_sis = ();
      foreach my $nsi ( keys %{$mapping{$type}{$osi}{'matches'}} ) {
        if( $current_stable_ids{$type}{$nsi} ) {
          push @current_sis,$nsi;
        } elsif( $_ ne 'NULL' ) {
          push @deprecated_sis,$nsi;
        }
      }
      if( @current_sis ) {
        $other_count++;
        my $example_id   = $mapping{$type}{$osi}{'example'};
        my $current_id_c = scalar(@current_sis );
        my $cur_txt = $current_id_c > 1 ? "$current_id_c current identifiers" : "$current_id_c current identifier";
        $cur_txt .= $example_id ? " (eg $example_id)" : '';
        my $desc = qq(Ensembl $type $osi is no longer in the database.);
        my $deprecated_id_c = scalar(@deprecated_sis);
        if ($deprecated_id_c) {
          my $dep_txt = $deprecated_id_c > 1 ? "$deprecated_id_c deprecated identifiers" : "$deprecated_id_c deprecated identifier";
          $desc .= " It has been mapped to $dep_txt";
          $desc .= $current_id_c ? " and $cur_txt." : '.'
        }
        elsif ($current_id_c) {
          $desc .= "It has been mapped to $cur_txt.";
        }
        &p (&StableIdMappingLine($dbspecies,$desc,$osi,$type,$db,$counter), $fh);
      }
      elsif( @deprecated_sis ) {
        $other_count++;
        my $deprecated_id_c = scalar(@deprecated_sis);
        my $id = $deprecated_id_c > 1 ? 'identifiers' : 'identifier';
        my $desc = qq(Ensembl $type $osi is no longer in the database but it has been mapped to $deprecated_id_c deprecated $id.);
        &p (&StableIdMappingLine($dbspecies,$desc,$osi,$type,$db,$counter), $fh);
      }
      else {
        $other_count++;
        my $desc = qq(Ensembl $type $osi is no longer in the database and has not been mapped to any newer identifiers.);
        &p (&StableIdMappingLine($dbspecies,$desc,$osi,$type,$db,$counter), $fh);
      }
    }
  }
  return $other_count;
}

sub StableIdMappingLine {
  my ($species,$desc,$osi,$type,$db,$counter) = @_; 
  my $url = sprintf(qq(%s/%s/Idhistory%s),
                    $species,
                    $type eq 'gene' ? ucfirst($type) : 'Transcript',
                    $type eq 'gene' ? "?g=$osi" : $type eq 'transcript' ? "?t=$osi" : "/Protein?t=$osi");
  $species =~ s/_/ /;
  my $xml = qq(
<doc>
  <field name="id">$osi</field>
  <field name="description">$desc</field>);
    $xml .= &common_fields($species,ucfirst($type),$db);
    $xml .= qq(
  <field name="domain_url">$url</field>
  <field name="quick_links">none</field>);
    $xml .= qq(
</doc>);
  $counter->();
  return $xml;
}

########################################################################## Regulatory Features

sub dumpRegulatoryFeature {
  my $conf = shift;
  my $dbname = $conf->{'dbs'}->{'DATABASE_FUNCGEN'};
  return unless $dbname;

  my $dbspecies = $conf->{'species'};
  my $db = 'regulatoryfeatures';
  my $counter   = make_counter(0);
  my $file = $conf->{'directory'}."/${dbname}_RegulatoryFeature.xml";
  my $start_time = time;
  my $fh;
  open( $fh, ">$file" ) or die "Can't open $file: $!";
  print LOG "  Dumping $dbname to $file ... ".&date_and_mem()."\n";
  header($fh);

  my $ftype = 'RegulatoryFeature';
  my $params;

  my $d = $conf->{'dbh'}->selectall_arrayref("
    select 
      rf.stable_id, 
      sr.name, 
      (rf.seq_region_start - rf.bound_start_length), 
      (rf.seq_region_end + rf.bound_end_length), 
      ft.name
    from 
      $dbname.regulatory_feature rf
      join seq_region sr using (seq_region_id)
      join $dbname.feature_type ft using (feature_type_id)
     ");

  foreach my $row ( @$d ) {
    my $desc = qq($row->[4] regulatory feature);
    my $id = $row->[0];
    my $ids = [ ];
    my $r = $row->[1] .":".$row->[2] . "-" . $row->[3];
    $params = { 'r' => $r, 'subtype' => 'RegulatoryFeature' };
    &p (RegulatoryFeatureLine($dbspecies,$desc,$id,$ids,$ftype,$params,$db,$counter), $fh);
  }

## External Features...
  my $e = $conf->{'dbh'}->selectall_arrayref("
    select 
      ef.display_label, 
      group_concat(distinct ft.name), 
      count(distinct ef.external_feature_id), 
      ft.description, 
      ft.class, 
      fs.name
    from  
      $dbname.external_feature ef
      join $dbname.feature_type ft using (feature_type_id)
      join $dbname.feature_set fs using (feature_set_id)
      join seq_region sr using (seq_region_id)
    group by 
      ef.display_label
 ");

  foreach my $f ( @$e) {
    my ($display_label, $f_name, $count, $f_desc, $f_class, $fs_name ) = @$f;
    next if ($f_name =~ /FANTOM/);
    my @syns;
    foreach my $id (split ',', $f_name) {
      push @syns unless $id eq 'display_label';
    }
    $params = { 'fs_name' => $fs_name, 'subtype' => 'RegulatoryFactor' };
    my $desc = "$display_label is a $f_class from $fs_name which hits the genome in $count locations";
    &p(RegulatoryFeatureLine($dbspecies,$desc,$display_label,\@syns,$ftype,$params,$db,$counter), $fh);
  }

## Tarbase features
  my $e = $conf->{'dbh'}->selectall_arrayref(
  "
  select 
    mrf.display_label, 
    group_concat(distinct ft.name), 
    group_concat(distinct mrf.accession), 
    count(distinct mrf.mirna_target_feature_id),
    ft.description, 
    ft.class, 
    fs.name
  from 
    $dbname.mirna_target_feature mrf
    join $dbname.feature_type ft using (feature_type_id)
    join $dbname.feature_set fs using (feature_set_id)
    join seq_region sr using (seq_region_id)
  group by 
    mrf.display_label
 "
);
  foreach my $f ( @$e) {
    my ($display_label, $f_name, $accs, $count, $f_desc, $f_class, $fs_name) = @$f;
    my @syns;
    foreach my $id (split ',', $f_name) {
      push @syns unless $id eq 'display_label';
    }
    push @syns, split ',', $accs;
    $params = { 'fs_name' => $fs_name, 'subtype' => 'TarBase miRNA' };
    my $desc = "$display_label is a $f_class from $fs_name which hits the genome in $count locations";
    &p(RegulatoryFeatureLine($dbspecies,$desc,$display_label,\@syns,$ftype,$params,$db,$counter), $fh);
  }

  return footer( $counter->(), $fh);
}

sub RegulatoryFeatureLine {
  my ($species,$desc,$id,$ids,$ftype,$params,$db,$counter) = @_;
  my $url;
  if ($params->{'subtype'} eq 'RegulatoryFeature') {
    $url = sprintf(qq(%s/Regulation/Summary?rf=%s),
                   $species,
                   $id);
  }
  else {
    $url = sprintf(qq(%s/Location/Genome?ftype=RegulatoryFactor;id=%s;fset=%s),
                   $species,
                   $id,
                   $params->{'subtype'},
                 );
  }
  $species =~ s/_/ /;
  my $xml = qq(
<doc>
  <field name="id">$id</field>
  <field name="description">$desc</field>);
  foreach my $syn (@$ids) {
    $xml .= qq(
  <field name="synonym">$syn</field>);
  }

  #what's this for ?
  if (my $fs_name = $params->{'fs_name'}) {
    $xml .= qq(
  <field name="fs_name">$fs_name</field>);
  }
  $xml .= &common_fields($species,$ftype,'regulatoryfeatures');
  $xml .= qq(
  <field name="domain_url">$url</field>
</doc>);

  $counter->();
  return $xml;
}

########################################################################## LRGs

sub findLRGs {
  my $conf = shift;
  return $conf->{'dbh'}->selectall_arrayref(
        qq(SELECT g.stable_id, x.display_label, edb.db_name, t.stable_id, sr.length
             FROM gene g, analysis a, object_xref ox, xref x, external_db edb, transcript t, seq_region sr
            WHERE g.analysis_id = a.analysis_id
              AND g.gene_id = ox.ensembl_id
              AND ox.xref_id = x.xref_id
              AND x.external_db_id = edb.external_db_id
              AND g.gene_id = t.gene_id
              AND g.stable_id = sr.name
              AND ox.ensembl_object_type = 'Gene'
              AND edb.db_name = 'HGNC'
              AND a.logic_name = 'LRG_import'
            ORDER by g.stable_id, t.stable_id)
      );
}

sub sort_lrgs {
  my ($dbspecies,$type,$fh,$lrgs) = @_;
  my ($prev_gsi,$prev_disp_label,$prev_db_name,$prev_length);
  my $query_terms = [];
  foreach my $rec (@$lrgs) {
    my $gsi = $rec->[0];
    if ($gsi eq $prev_gsi) {
      push @$query_terms, $rec->[3];
    }
    else {
      if ($prev_gsi) {
        &p(LRGLine($dbspecies,$type,$prev_gsi,$prev_disp_label,$prev_db_name,$query_terms,$prev_length),
           $fh);
      }
      $prev_gsi        = $gsi;
      $prev_disp_label = $rec->[1];
      $prev_db_name    = $rec->[2];
      $query_terms     = [ $rec->[3] ];
      $prev_length     = $rec->[4];
    }
  }
}

sub LRGLine {
  my ($species,$type,$gsi,$dbkey,$dbname,$tsids,$length) = @_;
  my $url = sprintf(qq(%s/LRG/Summary?lrg=%s),
                    $species,
                    $gsi);
  $species =~ s/_/ /;
  my $description = "$gsi is a fixed reference sequence of length $length with a fixed transcript(s) for reporting purposes. It was created for $dbname gene $dbkey";
  my $xml = qq(
<doc>
  <field name="id">$gsi</field>
  <field name="description">$description</field>);
  $xml .= qq(
  <field name="xrefs">$dbkey</field>);
  foreach my $tsi (@$tsids) {
    $xml .= qq(
  <field name="transcript">$tsi</field>);
  }
  $xml .= &common_fields($species,$type,'core');
  $xml .= qq(
  <field name="domain_url">$url</field>
</doc>);
  return $xml
}

#######################################################################

sub on_disk_set {
  my ($name) = @_;

  my %var;
  tie(%var,'DB_File',"$tmpdir/$name.$$.db",O_RDWR|O_CREAT|O_TRUNC,0666,$DB_BTREE) or die "$!";
  return \%var;
}


my $SYNC_COUNT = 0;
sub set_add {
  my ($var,$k,$v) = @_;
  $var->{$k}.="\t$v";
  $SYNC_COUNT++;
  unless($SYNC_COUNT%1000000) {
    warn "Added $SYNC_COUNT\n";
  }
}

sub set_get {
  my ($var,$k) = @_;

  return () unless defined $var;
  return grep { $_ } split("\t",$var->{$k});
} 

sub off_disk {
  my ($name,$var) = @_;

  return unless defined $var;
  untie %$var;
  unlink "$tmpdir/$name.$$.db";
}

#######################################################################

#XML encode those non-standard characters in gene names and descriptions (order of regexps is important)
sub clean {
  my ($text,$field) = @_;
  $text =~ s/&/&amp;/g;
  $text =~ s/<i>//g;
  $text =~ s/<\/i>//g;
  $text =~ s/<sup>/-/g;
  $text =~ s/<\/sup>/-/g;
  $text =~ s/<em>//g;
  $text =~ s/<\/em>//g;
  $text =~ s/</&lt;/g;
  $text =~ s/>/&gt;/g;
  $text =~ s/'/&#44;/g;
  $text =~ s/"/&quot;/g;
  $text =~ s/ & / &amp; /g;
  $text =~ s/</&lt;/g;
  $text =~ s/>/&gt;/g;
  $text = &latin_to_utf($text);

  if ($text =~ /[<>]/) {
    print LOG "WARNING: Unsupported character $text in field $field\n";
  }
  return $text;
}

sub latin_to_utf {
  my ($text) = @_;
  $text = decode( 'iso-8859-1', $text );
  $text = encode( 'utf-8', $text );
  return $text; 
}


sub make_counter {
  my $start = shift;
  return sub { $start++ }
}

sub header {
  my ($fh) = @_;
  p(q(<add>), $fh, 1);
}

sub footer {
  my ($ecount, $fh, $type) = @_;
  p("</add>", $fh, 1);
  my $text = $type ? "  ...Dumped $ecount $type entries\n" : "  ...Dumped $ecount entries\n";
  print LOG $text;
  $fh->close();
  return $ecount;
}

sub common_fields {
  my ($species_latin_name,$feature_type,$db) = @_;
  my $species_common_name = $species_latin_name eq 'Multi' ? 'CrossSpecies' : $conf->{'species_common_name'};
  my $parent_common = $conf->{'strain_details'}{'parent_common_name'};
  my ($parent_latin, $strain);

  my $xml = qq(
  <field name="website">$website_url</field>
  <field name="feature_type">$feature_type</field>);

  if ($species_common_name eq 'CrossSpecies') {
    $xml.= qq(
  <field name="species">$species_common_name</field>
  <field name="species_name">$species_latin_name</field>
  <field name="reference_strain">1</field>);
  }
  else {
    #for the front end we need the species details to be that of the parent, and the strain to be that of the species.
    if ($parent_common) {
      $parent_latin = $conf->{'strain_details'}{'parent_latin_name'};
      $strain = $conf->{'strain_details'}{'strain_name'};
      $species_latin_name = $parent_latin;
      $species_common_name = $parent_common;
    }

    if ($species_latin_name) {
      $xml .= qq(
  <field name="species">$species_common_name</field>
  <field name="species_name">$species_latin_name</field>);
    }
    my $ref_strain = $conf->{'strain_details'}{'reference_strain'};
    if ($ref_strain) {
      $xml .= qq(
  <field name="reference_strain">$ref_strain</field>);
    }
    if ($strain) {
      $xml .= qq(
  <field name="strain">$strain</field>);
    }
  }

  if ($db) {
    $xml .= qq(
  <field name="database_type">$db</field>);
  }
  return $xml;
}

sub p {
  my ($str, $fh, $no_parse) = @_;
  return unless $str;
  if ($check_xml ) {
    unless ($no_parse) {
      eval { $parser->parse($str); };
      if ($@) {
        print LOG "\n\nWARNING XML - Error in XML, please fix and rerun:\nError is $@\n";
        exit;
      }
    }
  }
  $str .= "\n";
  print $fh $str or die "Can't write string: $str";
}

sub format_datetime {
  my $t = shift;
  my ( $y, $m, $d, $ss, $mm, $hh ) = ( localtime($t) )[ 5, 4, 3, 0, 1, 2 ];
  $y += 1900;
  $d = "0" . $d if ( $d < 10 );
  my $ms = text_month($m);
  return sprintf "$d-$ms-$y %02d:%02d:%02d", $hh, $mm, $ss;
}

sub text_month {
  my $m = shift;
  my @months = qw[JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC];
  return $months[$m];
}

sub date_and_mem {
  my $date = strftime "%Y-%m-%d %T", localtime;
  my $mem = `ps -p $$ -o vsz |tail -1`;
  chomp $mem;
  return "[$date, mem $mem]";
}

sub elapsed_time {
  my $start_time = shift;
  my $diff = time - $start_time;
  my $sec = $diff % 60;
  $diff = ($diff - $sec) / 60;
  my $min = $diff % 60;
  my $hours = ($diff - $min) / 60;
  return "${hours}h ${min}min ${sec}sec";
}

sub about {
  print STDERR <<ABOUT_END;

usage:
./indexXMLDumper --species=aaa,bbb|ALL --index=vvv,xxx|ALL (--ignore_species=ccc,ddd) (--ignore_index=yyy,zzz) (--debug) (--log=index.log) (--dir=dir)

'ALL' can be used for both 'species' and 'index'

The script will retry five times if it encounters MySQL errors (for example loses database connections)
unless --debug is specified in which case it will exit on the first failure.

In the abscence of --debug option, STDOUT and STDERR are sent to a log file (dumping_$release.log unless specified otherwise). If you run with --debug then output is sent to STDOUT

The locations of the actual xml files can be specified with the dir option. If not specified then it is dumped to 'input'.

Examine the log file for 'WARNING' messages, particularly 'WARNING XML' - this will identify any entries identified by XML::Parser as not being well formed and which would crash index production. These are not added to the xml file but the record count in the footer *will* include them. Either manaully fix and add the entry(ies) to the xml file, or else fix the database / script to account for it and rerun.

--dry_run|n does everything apart from actually write the xml [note that this option will delete any preexisting file]

Examples:

./indexXMLDumper --species=ALL --index=ALL --debug --log=debug.log  #all log output to debug.log; xml to input; all indices for all species, only each one once
./indexXMLDumper --species=ALL --index=ALL                          #all log output to dumping_$release.log; xml to input; all indices for all species
./indexXMLDumper --species=ALL --ignore_species=Homo_sapiens --index=Variation --log=no_hs_variations.log #log output to no_hs_variations; xml to /nfs/web_data/search/lucene/ensembl_$release; Variations for all species but human
./indexXMLDumper --species=ALL --ignore_index=Variation --log=no_variations.log  #log output to no_variations.log; xml to  /nfs/web_data/search/lucene/ensembl_$release; All indexes apart from Variations for for all species
./indexXMLDumper --species=ALL --index=Gene --engine solr  -log dumping.log #output in format for solr (for testing, only works for genes as yet)

ABOUT_END
}
