#! /usr/bin/env perl

# Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#      http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

use strict;
package indexXMLDumper;

my $ENSEMBL_ROOT;

BEGIN {
  use FindBin qw($Bin);
  use File::Basename qw( dirname );
  $ENSEMBL_ROOT = dirname( $Bin );
  $ENSEMBL_ROOT =~ s/\/utils$//;
  unshift @INC, "$ENSEMBL_ROOT/conf";
  eval{ require SiteDefs };
  if ($@){ die "Can't use SiteDefs.pm - $@\n"; }
  map{ unshift @INC, $_ } @SiteDefs::ENSEMBL_LIB_DIRS;
}

use EnsEMBL::Web::SpeciesDefs;
use XML::Parser;
use Data::Dumper;
use Getopt::Long;
use POSIX qw(strftime);
use HTML::Strip;
use Digest::MD5 qw(md5_hex);

$| = 1;

my ($species_list,$ignore_species_list,$indexes_list,$ignore_indexes_list,$create_elevate,$do_private,$debug,$log,$dir,$help);
GetOptions('species=s'        => \$species_list,
           'ignore_species=s' => \$ignore_species_list,
           'index|indices=s'  => \$indexes_list,
           'ignore_index=s'   => \$ignore_indexes_list,
           'create_elevate'   => \$create_elevate,
           'do_private'       => \$do_private,
           'debug'            => \$debug,
           'log=s'            => \$log,
           'dir=s'            => \$dir,
	   'help'             => \$help,
         );

if ($help){
  &about;
  exit;
}

my @species        = split ',',$species_list;
my @ignore_species = split ',',$ignore_species_list;
my @indexes        = split ',',$indexes_list;
my @ignore_indexes = split ',',$ignore_indexes_list;

my $SD          = EnsEMBL::Web::SpeciesDefs->new();
my $release     = $SD->ENSEMBL_VERSION;
my $parser      = new XML::Parser( 'ErrorContext' => 3 ); #used to check xml is well formed
my $sitetype    = $SD->ENSEMBL_SITETYPE || 'Ensembl';
my $website_url = $sitetype eq 'Vega' ? 'http://vega.sanger.ac.uk/'
                : $sitetype eq 'Pre'  ? 'http://pre.ensembl.org/'
                : 'http://www.ensembl.org';

# used to boost certain records
my $boosts = {
	      'GeneTrans' => {
			      'core'    => 40,
			      'is_ref'  => 10,
                              'non_ref' => 0,
			     },
	      'Family' => {
			   'species' => 50,
                           'ms'      => 10,
			  },
	      'GeneTree' => {
			     'All' => 50,
			    },
	     };

# redirect STDOUT and STDERR to a file if not in debug mode
if ($debug) {
  $log = '>-';
}
else {
  my $counter = 1;
  $log =  "dumping_${release}.log";
  my $l =  $log."_".sprintf("%03d", $counter);
  while ( -e $l ) {
    $counter++;
    $l = $log."_".sprintf("%03d", $counter);
  }
  $log = $l;
}

open (LOG, ">$log") or die "Can't open $log: $!";
LOG->autoflush(1); #normally file output is buffered but better to see output after every print
unless ($debug) {
  open (STDERR, ">&LOG") or die "Can't open $log: $!";
}

my $conf = {};

# grab all dumper methods
my @available_indexes;
foreach my $method (sort keys %indexXMLDumper::) {
  if ($method =~ s/dump(\w+)/$1/) {
    push @available_indexes, $method;
  }
}

if ($do_private) {
   print LOG "Dumping just private data\n";
  @indexes = qw(StructuralVariation Variation );
}
elsif ($indexes_list eq 'ALL'){
  @indexes = ();
  my %ignored;
  @ignored{@ignore_indexes} = ();
  foreach my $index (@available_indexes) {
    push @indexes, $index unless exists $ignored{$index};
  }
}
else {
  my @incorrect_indexes;
  foreach my $asked_for_index (@indexes) {
    unless (grep {$_ eq $asked_for_index} @available_indexes) {
      push @incorrect_indexes, $asked_for_index;
    }
  }
  if (@incorrect_indexes) {
    print LOG "WARNING - one or more of your indexes is not recognised, please check your spelling. Available ones are are:\n";
    print LOG join "\n", @available_indexes;
    exit;
  }
}

# where are xml files put on the filesystem ?
my %shards = (
  Domain              => 'ensembl_core',	
  Family              => 'ensembl_core',
  Gene                => 'ensembl_core',
  GeneTree            => 'ensembl_core',
  Marker              => 'ensembl_core',
  OligoProbe          => 'ensembl_core',
  Phenotype           => 'ensembl_core',
  RegulatoryFeature   => 'ensembl_core',
  Sequence            => 'ensembl_core',
  SomaticMutation     => 'ensembl_core',
  StructuralVariation => 'ensembl_core',
  Transcript          => 'ensembl_core',
  GenomicAlignment    => 'ensembl_ga',
  Help                => 'ensembl_core',
  Variation           => 'ensembl_variation',
);
if ($sitetype ne 'Ensembl') {
  foreach my $feature_type (keys %shards) {
    $shards{$feature_type} = lc($sitetype).'_core';
  }
}
foreach (@indexes) {
  unless ($shards{$_}) {
    print LOG "WARNING - the location of files for the $_ index is not defined, please add:\n";
    exit;
  }
}

# if the SPECIES is set to ALL grab them all from the config...
my %X = %{$SD->ENSEMBL_SPECIES_ALIASES};
my $input_c = @species;
if( $species_list eq 'ALL' ) {
  @species = ();
  my %ignored;
  foreach my $ig (@ignore_species) {
    my $val = 0;
    $val = -1  if($ig =~ s!^<!!);
    $val = 1 if($ig =~ s!^>!!);
    @ignored{grep { ($_ cmp $ig) == $val } @{$SD->ENSEMBL_DATASETS}} = ();
  }
  foreach my $sp (@{$SD->ENSEMBL_DATASETS}) {
    push @species,$sp unless exists $ignored{$sp};
  }
}
else {
  @species = grep {$_} map { $X{lc($_)} } @species;
  if (@species ne $input_c) {
    print LOG "WARNING - one or more of your species names is not recognised, please check your spelling. Available species are:\n";
    print LOG join "\n", @{$SD->ENSEMBL_DATASETS};
    print LOG "\n";
    exit;
  }
}

# path to files
my $dir = $dir ? $dir : 'input';
print LOG "Dumping xml files to $dir\n";
mkdir $dir, 0777 unless -e "$dir";

my $start_time = time;
my $total_c;
my $elevate;
foreach my $index (@indexes) {
  my $loc = $do_private ? "$dir/ensembl_private/" : "$dir/".$shards{$index}."/";
  my $start = time;
  $conf->{'directory'} = $loc . lc($sitetype)."_$index";
  system( "mkdir -p $conf->{'directory'}") unless -e $conf->{'directory'};

  if ($index eq 'Variation' && ! $do_private) {
    $conf->{'directory_somatic_mutations'} = "$dir/".$shards{'SomaticMutation'}."/".lc($sitetype).'_SomaticMutation';
    system("mkdir -p $conf->{'directory_somatic_mutations'}") unless -e  $conf->{'directory_somatic_mutations'};
  }
  foreach my $species ( @species ) {
    my $single_species = 0;
    my %dbs = %{$SD->get_config($species,'databases')||{}};
    $conf->{'dbs'}                     = { map { ($_,$dbs{$_}{NAME}) } keys %dbs };
    $conf->{'dbs'}{'DATABASE_COMPARA'} = 'ensembl_compara_'.$SD->ENSEMBL_VERSION;
    my $core = $dbs{'DATABASE_CORE'};
    $conf->{'core_details'}            = $core;

    my $variation = $do_private ? $dbs{'DATABASE_VARIATION_PRIVATE'} : $dbs{'DATABASE_VARIATION'};
    if ($variation) {
      $conf->{'variation_dbh'} = DBI->connect( "dbi:mysql:$variation->{'NAME'};host=$variation->{'HOST'};port=$variation->{'PORT'}",
                                               $variation->{'USER'},
                                               $variation->{'PASS'},
                                               { PrintError => 1, RaiseError => 0} );
      $conf->{'variation_details'} = $variation;
      $conf->{'variation_dbname'}  = $variation->{'NAME'};
    }
    else {
      $conf->{'variation_details'} = undef;
      $conf->{'variation_dbname'}  = undef;
    }

    if ($index eq 'Help') {
      $single_species = 1;
      my $website = $SD->multidb->{DATABASE_WEBSITE};
      $conf->{'website'}{'name'} = $website->{'NAME'};
      $conf->{'website'}{'dbh'}  = DBI->connect("dbi:mysql:$website->{'NAME'};host=$website->{'HOST'};port=$website->{'PORT'}",
                                                $website->{'USER'},
                                                $website->{'PASS'},
                                                { PrintError => 1, RaiseError => 0} );
    }
    else {
      $conf->{'species'}             = $species;
      $conf->{'species_sci_name'}    = $species;
      $conf->{'authority'}           = $SD->get_config($species,'AUTHORITY');
      $conf->{'species_common_name'} = $SD->get_config($species,'SPECIES_COMMON_NAME');
    }

    if ($create_elevate) {
      &create_elevate($conf);
    }
    else {
      my $no_success = 1;
      my $c;
      print LOG "Starting: $index $species\n";
      while ($no_success) {
        $c++;
        $conf->{'dbh'} = DBI->connect("dbi:mysql:$core->{'NAME'};host=$core->{'HOST'};port=$core->{'PORT'}",
                                      $core->{'USER'},
                                      $core->{'PASS'},
                                      {PrintError => 1, RaiseError => 0}
                                    );
        if ( ! $conf->{'dbh'}) {
          print LOG "WARNING: Unable to get database connection for ".$core->{'NAME'}."\n";
          exit;
        }
        if ($index =~ /Family|GeneTree/) {
          my $compara = $SD->multidb->{DATABASE_COMPARA};
          $conf->{'dbh_compara'} = DBI->connect("dbi:mysql:$compara->{'NAME'};host=$compara->{'HOST'};port=$compara->{'PORT'}",
                                                $compara->{'USER'},
                                                $compara->{'PASS'},
                                                {PrintError => 1, RaiseError => 0}
                                              );
        }
        my $function = "dump$index";
        no strict "refs";

        #do the dumping!
        eval {
          $total_c += &$function( $conf );
        };
        if ($@) {
          unless ($debug) {
            #if the query dumping fails try four more times in case it's just a db connection issue
            if ( $conf->{'dbh'}->errstr()) {
              if ($c < 6) {
                print LOG "WARNING: Error when dumping, will retry in 5 minutes (mysql error is ".$conf->{'dbh'}->errstr().", other errors are $@)\n";
                sleep (5*60);}
              else {
                print LOG "WARNING: Error when dumping. you'll need to retry this later (error is ".$conf->{'dbh'}->errstr().")\n";
                $no_success = 0;
              }
            }
            else {
              print LOG "WARNING: Error when dumping, you'll need to retry this one later (error is $@)\n";
              $no_success = 0;
            }
          }
          else {
            print LOG "WARNING: Error when dumping. Exiting since in debug mode (mysql error is ".$conf->{'dbh'}->errstr().", other errors are $@)\n";
            exit;
          }
        }
        else {
          $no_success = 0;
        }
      }
      eval { $conf->{'dbh'}->disconnect; };
      if ($@) { print LOG "WARNING: Problems disconnecting database handle, don't understand this!"; }
      last if $single_species;
    }
    print LOG "  Time for $index is " . &elapsed_time($start) . "\n\n";
  }
}

if ($create_elevate) {
  if ($elevate) {
    print LOG $elevate;
  }
}


#prune empty directories
foreach my $subdir (<$dir/*>) {
  if (rmdir $subdir) {
    print LOG "\nRemoved empty directory $subdir\n";
  }
}

print LOG "\nDumped $total_c records in total\n";
print LOG "\nTotal time for dumping " . &elapsed_time($start_time) . "\n";
exit;


sub create_elevate {
  my ($conf) = @_;
  my $species     = $conf->{'species'};
  my $url = $website_url . "/$species/Info/Index";
  my $common_name = $conf->{'species_common_name'};
  my $variant1 = lc($common_name);
  my %names;
  foreach my $name ($common_name, $variant1, $species) {
    foreach (split ' ', $name) {
      $names{$_}++;
    }
  }
  my $text = join ' ', keys %names;

  $elevate .= qq(
  <query text="$text">
    <doc id="$url" />
  </query>);
}

## Now for all the dump functions...............................


########################################################################## Help

sub dumpHelp {
  my $conf = shift;
  my $start_time = time;
  my $total_c;
  my @types = $sitetype eq 'Vega' ? qw(Glossary) : qw(View Glossary FAQ);
  foreach my $type (@types) {
    my $counter   = make_counter(0);
    my $file = $conf->{'directory'}.'/'.$conf->{'website'}{'name'}.'_'.$type.'.xml';
    my $dbname    = $conf->{'website'}{'name'};
    my $db_type   = $type;
    my $fh;
    open( $fh, ">$file" ) or die "Can't open $file: $!";
    print LOG "  Dumping $dbname Help to $file ".&date_and_mem()."\n";
    header($fh);

    if ($type eq 'View') {
      my $sth = $conf->{'website'}{'dbh'}->prepare(qq(
       SELECT hr.help_record_id, keyword, data, page_url
         FROM help_record hr, help_link hl
        WHERE status = 'live'
          AND type = lower('$type')
          AND hr.help_record_id = hl.help_record_id
      ));
      $sth->execute;

      my ($id, $keywords, $content, $page_url);

      while (($id, $keywords, $content, $page_url) = $sth->fetchrow_array) {
        my $data        = eval($content);
        my $description = $data->{'content'};
        my $title        = "$page_url View";
           $title        =~ s/\// /g;

        &p(helpLine($id, $title, $keywords, $description, undef, $type, $counter), $fh); #### need to parse it
      }
    } else {
      my $sth = $conf->{'website'}{'dbh'}->prepare(qq(
       SELECT help_record_id, keyword, data
         FROM help_record
        WHERE status = 'live'
          AND type = lower('$type')
      ));
      $sth->execute;

      my ($id, $keywords, $content);
      while (($id, $keywords, $content) = $sth->fetchrow_array) {
        my ($extra, $description, $title);
        my $data = eval($content);
        if ($type eq 'Glossary') {
          $description = $data->{'meaning'};
          $title        = $data->{'word'};
          push @$extra, $data->{'expanded'} if $data->{'expanded'};
        } elsif ($type eq 'FAQ') {
          $description = $data->{'answer'};
          $title        = $data->{'question'};
        }

        &p(helpLine($id, $title, $keywords, $description, $extra, $type, $counter), $fh); #### need to parse it
      }
    }
    $total_c += footer($counter->(), $fh, $type);
  }
  return $total_c;
}

sub helpLine {
  my ($id, $title, $keywords, $desc, $extra,  $type, $counter) = @_;
  my @keywords = map { s/^ //; $_; } split ',', $keywords if $keywords;

  #remove all HTML markup, extra whitespace and extra lines. Escape any characters that might have slipped through
  my $hs = HTML::Strip->new(decode_entities => 0); #don't decode HTML entitites, they're fine as they are
  my $description = $hs->parse( $desc );
  $description =~ s/\s{1,}/ /g;
  $description = clean($description);
  $hs->eof;

  #remove markup from headers and escape just to be sure
  $title =~ s/<\/?\w+>//g;
  $title = &clean($title);

  my $url = $type eq 'FAQ'      ? "Help/Faq#faq$id"
    : $type eq 'Glossary' ? "Help/Glossary?id=$id"
    : $type eq 'View'     ? "Help/View?id=$id"
    : '';
  print LOG "NO URL available for feature type $type, please check\n" unless $url;

  my $xml = qq(
<doc>
  <field name="id">$id</field>
  <field name="description">$description</field>
  <field name="article_title">$title</field>);
  foreach my $kw (@keywords) {
    $xml .= qq(
  <field name="keyword">$kw</field>);
  }
  $xml .= &common_fields('','Documentation','');
  $xml .= qq(
  <field name="feature_subtype">$type</field>);
  $xml .= qq(
  <field name="domain_url">$url</field>
</doc>);
  $counter->();
  return $xml;
}

########################################################################## Markers

sub dumpMarker {
  my $conf = shift;
  my $dbname    = $conf->{'dbs'}{'DATABASE_CORE'};
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/${dbname}_Marker.xml";
  my $start_time = time;
  my $db = 'core';
  my $fh;
  my ($marker_present) = $conf->{'dbh'}->selectrow_array(qq(SELECT count(*) from marker_feature));
  return unless $marker_present;
  open( $fh, ">$file" ) or die "Can't open $file: $!";
  print LOG "  Dumping $dbname to $file ".&date_and_mem()."\n";
  header($fh);
  my $sth = $conf->{'dbh'}->prepare("
   SELECT m.marker_id, ms2.name, ms1.name
     FROM marker_synonym as ms1, marker as m
LEFT JOIN marker_synonym as ms2 on ms2.marker_synonym_id = m.display_marker_synonym_id
    WHERE ms1.marker_id = m.marker_id
 ORDER BY m.marker_id
  ");

  $sth->execute( );
  my $names  = [];
  my $old_ID = 0;
  my ($ID,$marker,$synonym);
  my $params = { contigviewbottom => 'marker_core_marker=normal'}; #used to switch on track by default
  while( ($ID,$marker,$synonym) = $sth->fetchrow_array()){
    $marker = $synonym unless $marker;
    if($ID == $old_ID) {
      push @$names, $synonym;
    } else {
      if ($old_ID) {
        &p( markerLine( $dbspecies, $names, $params, $counter ), $fh);
      }
      $names    = [ $synonym ];
      $old_ID  = $ID;
    }
  }
  &p( markerLine( $dbspecies, $names, $params, $counter ), $fh);
  return footer( $counter->(), $fh);
}

sub markerLine {
  my( $species, $IDS, $params, $counter ) = @_;
  my @synonyms = sort @$IDS;
  my $key = pop @synonyms;
  my $url = sprintf(qq(%s/Marker/Details?m=%s),
                    $species,
                    $key);
  $species =~ s/_/ /;
  my $desc = 'A marker with '.@synonyms.' synonym';
  $desc .= 's' if (@synonyms > 1);
  $desc .= 's' unless (@synonyms);
  return '' unless $key;
  my $xml = qq(
<doc>
  <field name="id">$key</field>);
  foreach my $syn (@synonyms) {
    $xml .= qq(
  <field name="synonym">$syn</field>);
  }
  while (my ($param,$value) = each %$params) {
    $xml .= qq(
  <field name="$param">$value</field>);
  }
  $xml .= &common_fields($species,'Marker','core');
  $xml .= qq(
  <field name="domain_url">$url</field>
</doc>);
  $counter->();
  return $xml;
}


########################################################################## Variations

sub dumpVariation {
  my $conf = shift;
  my $VariationDB = $conf->{'variation_dbname'};
  return unless $VariationDB;

  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/${VariationDB}_Variation.xml";
  my $start_time = time;
  my $db = 'variation';
  my $fh;
  open( $fh,  ">$file"  ) or die "Can't open $file: $!";
  print LOG "  Dumping $VariationDB Variations to $file... ".&date_and_mem()."\n";
  header($fh);
  my ($counter2,$file2,$fh2);
  my $somatic = { map { @$_ } @{$conf->{'variation_dbh'}->selectall_arrayref( "select source_id, somatic_status from source" )} };
  my $somatic_present =  $do_private ? 0 : ( grep { $somatic->{$_} } keys %$somatic ) ? 1 : 0;
  if ($somatic_present) {
    $counter2 = make_counter(0);
    $file2 = $conf->{'directory_somatic_mutations'}."/${VariationDB}_SomaticMutation.xml";
    open( $fh2, ">$file2" ) or die "Can't open $file2: $!";
    print LOG "  Dumping $VariationDB SomaticMutations to $file2 ... ".&date_and_mem()."\n";
    header($fh2);
  }

  my $sources = { map { @$_ } @{$conf->{'variation_dbh'}->selectall_arrayref( "select source_id, name from source" )} };

  my $sth;
  my ($all_hgvs_names,$hgvs_sth);
  if ($dbspecies ne 'Homo_sapiens') {
    print LOG "    Preparing to get HGVS data ".&date_and_mem()."\n";
    $sth = $conf->{'variation_dbh'}->prepare(qq(
    SELECT variation_id, hgvs_name
       FROM variation_hgvs));
    $sth->execute;
    while ( my ($variation_id,$hgvs_name) = $sth->fetchrow_array ) {
      $all_hgvs_names->{$variation_id}{$hgvs_name}++;
    }
  }
  else {
    print LOG "    Will get HGVS data as we go along\n";
    my $sql = qq(SELECT hgvs_name FROM variation_hgvs where variation_id = ?);
    $hgvs_sth = $conf->{'variation_dbh'}->prepare($sql);
  }

  print LOG "    Preparing to get HGNC data ".&date_and_mem()."\n";
  my $all_hgnc_names;
  $sth = $conf->{'variation_dbh'}->prepare(qq(
     SELECT variation_id, gene_name
       FROM variation_genename));
  $sth->execute;
  while ( my ($variation_id,$hgnc_name) = $sth->fetchrow_array ) {
    $all_hgnc_names->{$variation_id}{$hgnc_name}++;
  }

  print LOG "    Preparing to identify GWAS variations ".&date_and_mem()."\n";
  my $gwas_variations;
  $sth = $conf->{'variation_dbh'}->prepare(qq(
     SELECT distinct pf.object_id, s.name
       FROM phenotype_feature pf, source s
      WHERE pf.source_id = s.source_id
        AND pf.is_significant = 1
        AND s.name like "%NHGRI_GWAS%"));
  $sth->execute;
  while ( my ($variation_name,$gwas_study) = $sth->fetchrow_array ) {
    $gwas_study =~ s/_/ /g;
    $gwas_variations->{$variation_name}{$gwas_study}++;
  }

  print LOG "    Preparing to get extra SNP info (phenotypes etc) ".&date_and_mem()."\n";
  my %snp_extra = map { ($_->[0] => $_) }
    @{$conf->{'variation_dbh'}->selectall_arrayref(
     "SELECT v.variation_id,
           group_concat( distinct sta.name SEPARATOR '; ') AS lsi,
           group_concat( distinct st.external_reference SEPARATOR ';') AS st,
           group_concat( distinct pfa1.value SEPARATOR ';') AS gn,
           group_concat( distinct pfa2.value SEPARATOR ';') AS vars,
           group_concat( distinct
             if(
               isnull(p.name),
               p.description,
               concat( p.description,' (',p.name,')' )
             )
             SEPARATOR ';'
           ) AS phen
      FROM phenotype_feature AS pf left join
           variation AS v ON v.name = pf.object_id left join
           phenotype AS p ON p.phenotype_id = pf.phenotype_id left join
           study AS st ON st.study_id=pf.study_id left join
           associate_study AS sa ON sa.study1_id=st.study_id left join
           study AS sta ON sta.study_id=sa.study2_id left join
           ( phenotype_feature_attrib AS pfa1
             join attrib_type AS at1 on pfa1.attrib_type_id = at1.attrib_type_id and at1.code = 'associated_gene' )
           on pfa1.phenotype_feature_id = pf.phenotype_feature_id left join 
           ( phenotype_feature_attrib AS pfa2
             join attrib_type AS at2 on pfa2.attrib_type_id = at2.attrib_type_id and at2.code = 'variation_names' )
           on pfa2.phenotype_feature_id = pf.phenotype_feature_id
     WHERE pf.type = 'Variation'
       AND pf.is_significant = 1
  GROUP BY v.variation_id
  ORDER BY v.variation_id"
   )};
  print LOG "     Retrieved extra SNP info ".&date_and_mem()."\n";

  my $quick_links;
  my $locations = {};
  if ($do_private) {
    # only needed for private data
    print LOG "    Preparing to get SNP location info ", &date_and_mem, "\n";
    my $query = qq(
     SELECT vf.variation_id, concat(sr.name, ':', vf.seq_region_start-50, '-',  vf.seq_region_end+50, ':', vf.seq_region_strand ) as location
     FROM variation_feature vf, seq_region sr
     WHERE vf.seq_region_id = sr.seq_region_id);
    $sth = $conf->{'variation_dbh'}->prepare($query);
    $sth->execute;
    while ( my $rows = $sth->fetchrow_arrayref() ) {
      push @{$locations->{$rows->[0]}},$rows->[1];
    }
    print LOG "     Retrieved SNP location info ".&date_and_mem()."\n";

    #disable all links from these hits
    $quick_links = 'all:0';
  }

  my ($ssid_sth, $stmt,$ssid_hash);
  # the human database is so big that that dumping in one go runs out of memory even with 128Gb!
  if ($dbspecies ne 'Homo_sapiens') {
    print LOG "    Preparing to get extra ssID info ".&date_and_mem()."\n";
    $stmt = qq{SELECT variation_id,
                      GROUP_CONCAT('ss',subsnp_id) as ssid
                 FROM subsnp_map
             GROUP BY variation_id};
    $ssid_sth = $conf->{'variation_dbh'}->prepare($stmt);
    $ssid_sth->execute();
    print LOG "     ...executed SQL, now retrieving data ".&date_and_mem()."\n";

    # Get a hashref of the results with the variation_id as key
    $ssid_hash = $ssid_sth->fetchall_hashref('variation_id');
    print LOG "     Retrieved extra ssID info ".&date_and_mem()."\n";
  }
  else {
    #for human we need to get the extra allele info as we go along
    print LOG "    Will get extra ssID info as we go along ".&date_and_mem()."\n";
    $stmt = qq{SELECT GROUP_CONCAT('ss',subsnp_id) as ssid
                 FROM subsnp_map
                WHERE variation_id = ?};
    $ssid_sth = $conf->{'variation_dbh'}->prepare($stmt);
  }

  ## get synonym info
  print LOG "    Preparing to get all synonyms ".&date_and_mem()."\n";
  my $synonyms;
  $sth = $conf->{'variation_dbh'}->prepare(qq(
      SELECT v.variation_id,
GROUP_CONCAT(vs.source_id,' ',vs.name)
       FROM variation v, variation_synonym vs
      WHERE v.variation_id = vs.variation_id
   GROUP BY v.variation_id));
  $sth->execute;
  while ( my ($variation_id,$syns) = $sth->fetchrow_array ) {
    $synonyms->{$variation_id} = $syns;
  }

  ## get failed mappings
  print LOG "    Preparing to get details of failed mappings ".&date_and_mem()."\n";
  my $failures;
  $sth = $conf->{'variation_dbh'}->prepare(qq(
      SELECT v.variation_id, fd.description
       FROM variation v, failed_variation fv, failed_description fd
      WHERE v.variation_id = fv.variation_id
        AND fv.failed_description_id = fd.failed_description_id));
  $sth->execute;
  while ( my ($variation_id,$desc) = $sth->fetchrow_array ) {
    $failures->{$variation_id} = $desc;
  }

  # Statement to get all variations, both mapped, failed and the precious non-mapped, non-failed
  print LOG "    Preparing to get all SNPs ".&date_and_mem()."\n";
  $sth = $conf->{'variation_dbh'}->prepare(qq(
    SELECT v.variation_id, v.name, v.source_id, v.somatic
      FROM variation v));

  $sth->execute() or die "Error:", $DBI::errstr;

  print LOG "     ...executed SQL, now retrieving data and generating xml ".&date_and_mem()."\n";

  my $new_syn_c = 0;
  while ( my $rowcache = $sth->fetchall_arrayref( undef, 10_000 ) ) {
    while ( my $row = shift( @{$rowcache} ) ) {
      my $variation_id       = $row->[0];
      my $variation_name     = $row->[1];
      my $source_id          = $row->[2];
      my $synonym_list       = $synonyms->{$variation_id};
      my $failed_desc        = $failures->{$variation_id};
      my $somatic_var        = $row->[3];
      my $ssids;
      if ($ssid_hash) {
        $ssids = $ssid_hash->{$variation_id}{'ssid'};
      }
      else {
        #comment out these three lines if time constraints mean you need to generate indices without extra allele info
        my $timed_out = 1;
        until ($ssid_sth->execute($variation_id) || $timed_out > 5) {
          print LOG "Can't execute query to get extra allele info:\n".$conf->{'variation_dbh'}->errstr."\n. Retrying\n";
          sleep 3;
          $timed_out++;
        }
        if ($timed_out > 5) {
          print LOG "WARNING: You'll need to reindex $dbspecies Variations, can't maintain connection\n";
          return 0;
        }

        (my $res) = $ssid_sth->fetchrow_arrayref();
        if ($conf->{'variation_dbh'}->err) {
          print LOG "Data retrieval for $variation_name terminated early:\n".$conf->{'variation_dbh'}->errstr."\n";
          print LOG "WARNING: You'll need to reindex $dbspecies Variations, can't maintain connection\n";
          return 0;
        }
        $ssids = $res->[0];
      }
      my %synonyms;
      my $syn_c = 0;
      foreach my $syn (split /,/, $synonym_list) {
        my ($source_id,$sname) = split / /,$syn;
        $synonyms{$sname} = $sources->{$source_id};
        $syn_c++;
      }
      foreach my $ssid_syn (split /,/,$ssids) {
        unless (exists $synonyms{$ssid_syn}) {
          $synonyms{$ssid_syn} = 'dbSNP';
          $syn_c++;
          $new_syn_c++;
        }
      }
      my (@syns, %genes, @phenotypes, @studies, @hgvs_names);
      foreach my $syn (keys %synonyms) {
        push @syns, $syn;
      }

      my $somatic_mutation = $somatic_var;
      my $type             = $somatic_mutation ? 'Somatic Mutation' : 'Variation';
      my $snp_source       = $sources->{ $source_id };
      my $desc;
      my $x = $snp_extra{$variation_id};
      if( $x ) {
        foreach my $g ($x->[3]) {
          foreach (split ';', $g) {
            $genes{$_}++ if $_;
          }
        }
        push @syns,       split ';', $x->[1];
        push @syns,       split ';', $x->[4];
        push @phenotypes, $x->[5] if $x->[5];
        push @studies,    split ';', $x->[2];
      }

      my $hgvs_names;
      if ($all_hgvs_names) {
        if ($all_hgvs_names->{$variation_id}) {
          foreach my $hgvs_name (keys %{$all_hgvs_names->{$variation_id}}) {
            push @hgvs_names, $hgvs_name;
          }
        }
      }
      else {
        $hgvs_sth->execute($variation_id);
        while (my ($hgvs_name) = $hgvs_sth->fetchrow_array) {
          push  @hgvs_names, $hgvs_name;
        }
      }
      if ($all_hgnc_names->{$variation_id}) {
        foreach my $hgnc_name (keys %{$all_hgnc_names->{$variation_id}}) {
          $genes{$hgnc_name}++;
        }
      }
      my $loc = $locations->{$variation_id}[0];
      my $gwas_studies = join ', ', keys %{$gwas_variations->{$variation_name}};
      $desc = sprintf( "A $snp_source $type.%s%s%s%s%s",
                       @phenotypes   ? ' Phenotype(s): '        . (join ', ', @phenotypes)         . '.' : '',
                       %genes          ? ' Gene Association(s): ' . (join ', ', keys %genes)           . '.' : '',
                       @hgvs_names   ? ' HGVS Name(s): '        . &clean((join ', ', @hgvs_names)) . '.' : '',
                       $gwas_studies ? " GWAS studies: $gwas_studies"                              . '.' : '',
                       $failed_desc  ? " $failed_desc."                                                  : '');
      if ($somatic_mutation){
        &p( VariationLine( $dbspecies, $variation_name, \@syns, \%genes, \@phenotypes, \@studies, \@hgvs_names, $type, $snp_source, $loc, $quick_links, $desc, $counter2 ), $fh2);
      }
      else {
        &p( VariationLine( $dbspecies, $variation_name, \@syns, \%genes, \@phenotypes, \@studies, \@hgvs_names, $type, $snp_source, $loc, $quick_links, $desc, $counter ), $fh);
      }
    }
  }
  print LOG "    All SNPs dumped to file ".&date_and_mem()."\n";

  my $c = footer( $counter->(), $fh, 'Variation');
  if ($somatic_present) {
    $c += footer( $counter2->(), $fh2, 'Somatic Mutation');
  }
  print LOG "  $new_syn_c synonyms added from the subsnp_map table\n";

  %snp_extra    = undef;
  $ssid_hash = undef;

  return $c;
}

sub VariationLine {
  my ($species, $name, $synonyms, $genes, $phenotypes, $studys, $hgvs_names, $type, $source, $loc, $quick_links, $desc, $counter ) = @_;
  my $url = sprintf(qq(%s/Variation/Summary?v=%s),
                    $species,
                    $name);
  #if we have a location then use this in the URL
  if ($loc) {
    $url = sprintf(qq(%s/Location/View?r=%s),
                    $species,
                    $loc);
  }
  $species =~ s/_/ /;
  my $xml = qq(
<doc>
  <field name="id">$name</field>
  <field name="description">$desc</field>);
  if ($quick_links) {
    $xml .= qq(
  <field name="quick_links">$quick_links</field>);
  }
  foreach (@$synonyms) {
    $xml .= qq(
  <field name="synonym">$_</field>);
  }
  foreach (keys %$genes) {
    $xml .= qq(
  <field name="assoc_gene">$_</field>);
  }
  foreach (@$phenotypes) {
    $xml .= qq(
  <field name="phenotype">$_</field>);
  }
  foreach my $hgvs_name (@$hgvs_names) {
    $hgvs_name = &clean($hgvs_name,'hgvs_name');
    $xml .= qq(
  <field name="hgvs_name">$hgvs_name</field>);
  }
  foreach (@$studys ) {
    $xml .= qq(
  <field name="study">$_</field>);
  }
  $xml .= qq(
  <field name="variation_source">$source</field>);
  $xml .= &common_fields($species,$type,'variation');
  $xml .= qq(
  <field name="domain_url">$url</field>
</doc>);
  $counter->();
  return $xml;
}

########################################################################## Variation Phenotypes

sub dumpPhenotype {
  my $conf = shift;
  my $VariationDB = $conf->{'dbs'}->{'DATABASE_VARIATION'};
  return unless $VariationDB;
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/${VariationDB}_Phenotype.xml";
  my $start_time = time;
  my $db = 'variation';
  my $fh;
  open $fh, '>', $file  or die "Can't open $file: $!";
  print LOG "  Dumping $VariationDB Phenotype info to $file ... ".&date_and_mem()."\n";
  header($fh);

  my %synonyms = ();
  my $phenotype_info = $conf->{'variation_dbh'}->selectall_hashref(qq(
     SELECT p.description, p.phenotype_id
       FROM phenotype p, phenotype_feature pf
      WHERE p.phenotype_id = pf.phenotype_id
        AND pf.is_significant = 1
      GROUP BY p.phenotype_id),'description');
  foreach my $phen (keys %$phenotype_info) {
    my $syns = $synonyms{$phenotype_info->{$phen}{'phenotype_id'}} || [];
    &p( PhenLine( $dbspecies, $phen, $phenotype_info->{$phen}{'phenotype_id'}, $syns, $counter ), $fh);
  }

  return footer( $counter->(), $fh);
}

sub PhenLine {
  my ($species, $name, $id, $synonyms, $counter ) = @_;
  my $url = sprintf(qq(%s/Phenotype/Locations?ph=%s),
                    $species,
                    $id);
  $species =~ s/_/ /;
  $name = &clean($name,'name');
  my $xml = qq(
<doc>
  <field name="id">$id</field>
  <field name="name">$name</field>);
  foreach my $syn (@$synonyms) {
    $xml .= qq(
  <field name="synonym">$syn</field>);
  }
  $xml .= &common_fields($species,'Phenotype','variation');
  $xml .= qq(
  <field name="domain_url">$url</field>
</doc>);
  $counter->();
  return $xml;
}

########################################################################## StructuralVariations

sub dumpStructuralVariation {
  my $conf = shift;
  my $VariationDB = $conf->{'variation_dbname'};

  return unless $VariationDB;
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/${VariationDB}_StructuralVariations.xml";
  my $start_time = time;
  my $db = 'variation';
  my $fh;
  open( $fh, ">$file" ) or die "Can't open $file: $!";
  print LOG "  Dumping $VariationDB to $file ... ".&date_and_mem()."\n";
  header($fh);

  my $quick_links;
  my $locations = {};
  if ($do_private) {
    # only needed for private data
    print LOG "    Preparing to get StructuralVariation location info ", &date_and_mem, "\n";
    my $query = qq(
    SELECT svf.structural_variation_id, concat(sr.name, ':', svf.seq_region_start, '-', svf.seq_region_end, ':', svf.seq_region_strand ) as location
      FROM structural_variation sv, structural_variation_feature svf, seq_region sr
     WHERE sv.structural_variation_id = svf.structural_variation_id
       AND svf.seq_region_id = sr.seq_region_id);
    my $sth = $conf->{'variation_dbh'}->prepare($query);
    $sth->execute;
    while ( my $rows = $sth->fetchrow_arrayref() ) {
      push @{$locations->{$rows->[0]}},$rows->[1];
    }
    print LOG "     Retrieved StructuralVariation location info ".&date_and_mem()."\n";

    #disable all links from these hits
    $quick_links = 'all:0';
  }

  my $scale           = $SD->ENSEMBL_GENOME_SIZE || 1;
  my $max_length      = $scale *= 1e6;
  my $T = $conf->{'variation_dbh'}->selectall_arrayref(qq(
    SELECT v.structural_variation_id,
           v.variation_name,
           s.name as source,
           s.description,
           st.name as study,
           r.name as seq_region,
           vf.seq_region_start,
           vf.seq_region_end,
           group_concat(ssv.variation_name) as ssv
      FROM structural_variation as v LEFT JOIN study as st ON st.study_id=v.study_id
        LEFT JOIN structural_variation_association as sva ON v.structural_variation_id = sva.structural_variation_id
        LEFT JOIN structural_variation as ssv ON ssv.structural_variation_id = sva.supporting_structural_variation_id,
           source as s,
           seq_region as r,
           structural_variation_feature as vf
     WHERE s.source_id = v.source_id
       AND v.structural_variation_id = vf.structural_variation_id
       AND vf.seq_region_id = r.seq_region_id
       AND v.is_evidence = 0
  GROUP BY v.structural_variation_id));

  foreach my $row ( @$T ) {
    my $id = $row->[1];
    my $location = $row->[5] .":" . $row->[6] ."-". $row->[7];
    my $length = $row->[7] - $row->[6] + 1;
    my $evidence =  $row->[8];
    my $study  = $row->[4];
 #   my $loc = $locations->{$row->[0][0]};
 #   warn $loc; exit;
    my $action = ($length >> $max_length) ? 'Overview' : 'View';
    my $params = ($length >> $max_length) ? { 'cytoview' => 'variation_feature_structural=normal' }
       : { 'contigviewbottom' => 'variation_feature_structural=normal' };
    my $desc;
    if ($study) {
      $desc = qq(A structural variation from $row->[2], identified by $row->[3] (study $study).);
      }
    else {
      $desc = qq(A structural variation from $row->[2], identified by $row->[3].);
    }
    &p( StrucVarLine( $dbspecies, $id, $evidence, $study, $location, $quick_links, $desc, $action, $params, $counter ), $fh);
  }
  return footer( $counter->(), $fh);
}

sub StrucVarLine {
  my ($species, $id, $evidence, $study, $location, $quick_links, $desc, $action, $params, $counter ) = @_;
# $location, $action and $params contain info for location view, no point in adding it until we can pass this info from StructuralVariation/Summary

  my $url = sprintf(qq(%s/StructuralVariation/Summary?sv=%s),
                    $species,
                    $id);
  if ($do_private) {
    my ($chr,$coords) = split ':', $location;
    my ($start,$stop) = split '-', $coords;
#    my $view = ($stop-$start+1 > 1e6) ? 'Overview' : 'View'; #use this when we have Structural Variations on Genoverse
    my $view = 'View';
    $url = sprintf(qq(%s/Location/View?r=%s),
                    $species,
                    $location);
  }
  $species =~ s/_/ /;
  my $xml = qq(
<doc>
  <field name="id">$id</field>
  <field name="description">$desc</field>);
  if ($quick_links) {
    $xml .= qq(
  <field name="quick_links">$quick_links</field>);
  }
  foreach (split ',', $evidence) {
    $xml .= qq(
  <field name="supporting_evidence">$_</field>);
  }
  if ($study) {
    $xml .= qq(
  <field name="study">$study</field>);
  }
  $xml .= &common_fields($species,'StructuralVariation','variation');
  $xml .= qq(
  <field name="domain_url">$url</field>
</doc>);
  $counter->();
  return $xml;
}


########################################################################## Similarity features

sub dumpGenomicAlignment {
  my $conf    = shift;
  my $dbspecies = $conf->{'species'};
  my $COREDB  = $conf->{'dbs'}->{'DATABASE_CORE'};
  my $ESTDB   = $conf->{'dbs'}->{'DATABASE_OTHERFEATURES'};
  my $CDNADB  = $conf->{'dbs'}->{'DATABASE_CDNA'};
  my $RNASEQDB = $conf->{'dbs'}->{'DATABASE_RNASEQ'};
  my %dbs      = ( 'core' => $COREDB );
  $dbs{'otherfeatures'} = $ESTDB  if $ESTDB;
  $dbs{'cdna'}          = $CDNADB if $CDNADB;
  my %tables = (
    'dna_align_feature'     => [ 'DnaAlignFeature',     'DNA alignment feature' ],
    'protein_align_feature' => [ 'ProteinAlignFeature', 'Protein alignment feature' ]
  );
  my $total_af_c;
  foreach my $db ( sort { $a cmp $b } keys %dbs) {
    my $counter    = make_counter(0);
    my $dbname     = $dbs{$db};
    my $file       = $conf->{'directory'}."/${dbname}_GenomicAlignment.xml";
    my $start_time = time;
    my $fh;
    open( $fh, ">$file" ) or die "Can't open $file: $!";
    print LOG "  Dumping $dbname to $file ... ".&date_and_mem()."\n";
    header($fh);

    foreach my $table ( keys %tables ) {
      my $source = $tables{ $table }[0];
      $source .= ";db=$db" unless $db eq 'core';
      my $type   = $tables{ $table }[1];
      my $sth    = $conf->{'dbh'}->prepare(
        "select ad.display_label, a.logic_name, ad.displayable, t.hit_name, ad.web_data, edb.db_name, count(*) as hits
                from (($dbname.analysis as a, $dbname.$table as t) left join
                     $dbname.analysis_description ad on a.analysis_id = ad.analysis_id) 
           left join $dbname.external_db edb on t.external_db_id = edb.external_db_id
               where a.analysis_id = t.analysis_id
                 and ad.displayable = 1
               group by ad.display_label, t.hit_name");
      $sth->execute();
      my $c = 0;
      while( my( $label, $logic_name, $displayable, $hid, $webdata, $db_name, $count  ) = $sth->fetchrow_array ) {
        my $wd = eval($webdata);
        next if $wd->{$table}{'do_not_display'};
        next unless $displayable;
        $c++;
        $label ||= '';
        my $desc = "$label $hid hits the genome in $count locations.";
        (my $track_name = $table) =~ s/feature//;
        my $renderer = $track_name . $db . '_' . lc($logic_name) . '=stack' ;
        my $params = { 'contigviewbottom' => $renderer };
        &p( GenomicAlignmentLine( $dbspecies, $hid, $desc, $db_name, $db, $tables{$table}->[0], $params, $counter ), $fh);
      }
      print LOG "  ...Dumped $c $table entries\n";
    }
    if ($db eq 'cdna') {
      my $sth    = $conf->{'dbh'}->prepare(
        "select ad.display_label, uo.identifier,  ur.summary_description, 'Unmapped feature'
           from $dbname.unmapped_object uo, $dbname.unmapped_reason ur, $dbname.analysis a
                left join $dbname.analysis_description ad on a.analysis_id = ad.analysis_id
          where a.analysis_id = uo.analysis_id
            and uo.unmapped_reason_id = ur.unmapped_reason_id");
      $sth->execute();
      my $c++;
      while (my ($label, $hid, $reason, $type) = $sth->fetchrow_array ) {
        $c++;
        $label ||= '';
        my $desc = "$label $hid fails to map to the genome. Reason: $reason.";
        &p( GenomicAlignmentLine( $dbspecies, $hid, $desc, undef, $db, 'Unmapped feature', {}, $counter ), $fh);
      }
      print LOG "  ...Dumped $c Unmapped features\n";
    }
    $total_af_c += footer( $counter->(), $fh);
  }
  return $total_af_c;
}

sub GenomicAlignmentLine {
  my ($species, $id, $desc, $db_name, $db, $ftype, $params, $counter ) = @_;
# $params contains what's needed to switch the track on region in detail but there's no point in using it since we get to this via Location/Genome

  my $url = sprintf(qq(%s/Location/Genome?ftype=%s;id=%s%s),
                    $species,
                    $ftype,
                    $id,
                    $db ne 'core' ? ";db=$db" : '');
  $species =~ s/_/ /;
  my $xml = qq(
<doc>
  <field name="id">$id</field>
  <field name="description">$desc</field>);
  $xml .= &common_fields($species,'GenomicAlignment',$db);
  if ($db_name) {
    $xml .= qq(
  <field name="external_source">$db_name</field>);
  }
  $xml .= qq(
  <field name="domain_url">$url</field>
</doc>);
  $counter->();
  return $xml;
}


########################################################################## OligoProbes

sub dumpOligoProbe {
  my $conf = shift;
  my $FUNCDB = $conf->{'dbs'}->{'DATABASE_FUNCGEN'};
  return unless $FUNCDB;
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/${FUNCDB}_OligoProbe.xml";
  my $start_time = time;
  my $db = 'funcgen';
  my $fh;
  open( $fh, ">$file" ) or die "Can't open $file: $!";
  print LOG "  Dumping $FUNCDB to $file ... ".&date_and_mem()."\n";
  header($fh);

  #gene details
  my $gene_dets;
  my $sql = qq(
    SELECT t.stable_id, g.stable_id, x.display_label
      FROM transcript t, gene g, xref x
     WHERE t.gene_id = g.gene_id
       AND g.display_xref_id = x.xref_id);
  my $sth = $conf->{'dbh'}->prepare($sql);
  $sth->execute;
  while( my( $tsi, $gsi, $gname) = $sth->fetchrow_array ) {
    $gene_dets->{$tsi} = {
      'gene_id'   => $gsi,
      'gene_name' => $gname
    };
  }

  my $probe_set_trans_dets;
  $sql = qq(
    SELECT ps.probe_set_id, x.dbprimary_acc, x.display_label
      FROM $FUNCDB.probe_set ps, $FUNCDB.object_xref ox, $FUNCDB.xref x, $FUNCDB.external_db edb
     WHERE ps.probe_set_id = ox.ensembl_id 
       AND ox.xref_id = x.xref_id
       AND x.external_db_id = edb.external_db_id
       AND ox.ensembl_object_type='ProbeSet'
       AND edb.db_name = '${dbspecies}_core_Transcript');
  $sth = $conf->{'dbh'}->prepare($sql);
  $sth->execute;
  while( my( $probe_set_id, $tsi, $display_label) = $sth->fetchrow_array ) {
    my $gene_label = $gene_dets->{$tsi}{'gene_name'};
    push @{$probe_set_trans_dets->{$probe_set_id}{$gene_label}}, {
      'stable_id'     => $tsi,
      'display_label' => $display_label,
    };
  };

  $sth    = $conf->{'dbh'}->prepare(
    "select ps.name, ps.probe_set_id, count(distinct pf.probe_feature_id) as hits, a.vendor
        from $FUNCDB.probe_set ps, $FUNCDB.probe p, $FUNCDB.probe_feature pf, $FUNCDB.array_chip ac, $FUNCDB.array a, $FUNCDB.status s, $FUNCDB.status_name sn
      where sn.name='MART_DISPLAYABLE'
        and sn.status_name_id=s.status_name_id
        and s.table_name='array'
        and s.table_id=a.array_id
        and ps.probe_set_id = p.probe_set_id
        and p.probe_id = pf.probe_id
        and p.array_chip_id = ac.array_chip_id
        and ac.array_id = a.array_id
      group by ps.name, a.vendor"
  );
  $sth->execute();
  print LOG "    Retrieved probe_set features; dumping to xml...".&date_and_mem()."\n";
  while( my( $probe_name, $pset_id, $count, $type ) = $sth->fetchrow_array ) {
    next unless $probe_name;
    my $locations_c = $count > 1 ? 'locations' : 'location';
    my $desc =  qq($type probeset $probe_name has probes which hit the genome in $count $locations_c.);
    if (my @gname = keys %{$probe_set_trans_dets->{$pset_id} || {}}) {
      my $gene_c = scalar(@gname) > 1 ? 'genes' : 'gene';
      $desc .= " They hit transcripts in the following $gene_c:";
      foreach my $gene (@gname) {
        $desc .= " $gene (";
        foreach my $trans (@{$probe_set_trans_dets->{$pset_id}{$gene}}) {
          $desc .= $trans->{'stable_id'}.', ';
        }
        $desc =~ s/, $//;
        $desc .= '),';
      }
      $desc =~ s/,$/\./;
    }
    &p( OligoProbeLine($dbspecies,$probe_name,$desc,'','pset',$db,$counter ), $fh);
  }

  my $probe_trans_dets;
  $sql = qq(
    SELECT p.probe_id, x.dbprimary_acc, x.display_label
      FROM $FUNCDB.probe p, $FUNCDB.object_xref ox, $FUNCDB.xref x, $FUNCDB.external_db edb
     WHERE p.probe_id = ox.ensembl_id 
       AND ox.xref_id = x.xref_id
       AND x.external_db_id = edb.external_db_id
       AND ox.ensembl_object_type='Probe'
       AND edb.db_name = '${dbspecies}_core_Transcript');
  $sth = $conf->{'dbh'}->prepare($sql);
  $sth->execute;
  while( my( $probe_id, $tsi, $display_label) = $sth->fetchrow_array ) {
    my $gene_label = $gene_dets->{$tsi}{'gene_name'};
    push @{$probe_trans_dets->{$probe_id}{$gene_label}}, {
      'stable_id' => $tsi,
      'display_label' => $display_label,
    };
  };

  $sth    = $conf->{'dbh'}->prepare(
    "select p.probe_id, p.name, a.vendor, a.name, count(distinct pf.probe_feature_id) as hits
        from $FUNCDB.probe p, $FUNCDB.probe_feature pf, $FUNCDB.array_chip ac, $FUNCDB.array a, $FUNCDB.status s, $FUNCDB.status_name sn
      where sn.name='MART_DISPLAYABLE'
        and sn.status_name_id=s.status_name_id
        and s.table_name='array'
        and s.table_id=a.array_id
        and p.probe_set_id is NULL
        and p.probe_id = pf.probe_id
        and p.array_chip_id = ac.array_chip_id
        and ac.array_id = a.array_id
      group by p.name"
  );
  $sth->execute();
  print LOG "    Retrieved probe features; dumping to xml...".&date_and_mem()."\n";
  my $old;
  while( my( $pid, $pname, $vendor, $aname, $count ) = $sth->fetchrow_array ) {
    if( $old->{'pid'} != $pid ) {
      if( $old->{'pid'}) {
        my ($p_probe_name,$desc) = &get_oligo_terms($old);
        if (my @gname = keys %{$probe_trans_dets->{$pid} || {}}) {
          my $gene_c = scalar(@gname) > 1 ? 'genes' : 'gene';
          $desc .= " It hits transcripts in the following $gene_c:";
          foreach my $gene (@gname) {
            $desc .= " $gene (";
            foreach my $trans (@{$probe_trans_dets->{$pid}{$gene}}) {
              $desc .= $trans->{'stable_id'}. ', ';
            }
            $desc =~ s/, $//;
            $desc .= '),';
          }
          $desc =~ s/,$/\./;
        }
        &p( OligoProbeLine($dbspecies,$p_probe_name,$desc,$old->{'array_dets'},'probe',$db,$counter ), $fh);
      }
      $old = {
        'pid'        => $pid,
        'array_dets' => [ [ $aname, $pname] ],
        'vendor'     => $vendor,
        'count'      => $count,
      };
    }
    else {
      push @{$old->{'array_dets'}}, [ $aname, $pname ];
    }
  }
  if( $old->{'pid'} ) {
    my ($p_probe_name,$desc) = &get_oligo_terms($old);
    &p( OligoProbeLine($dbspecies,$p_probe_name,$desc,$old->{'array_dets'},'probe',$db,$counter ), $fh);
  }
  return footer( $counter->(), $fh);
}

sub get_oligo_terms {
  my $old = shift;
  my $primary_probe  = shift @{$old->{'array_dets'}};
  my ($p_array_name,$p_probe_name) = @$primary_probe;
  my $type  = $old->{'vendor'};
  my $count = $old->{'count'};
  my $locations_c = $count > 1 ? 'locations' : 'location';
  my $desc = "$type probe $p_probe_name ($p_array_name array) hits the genome in $count $locations_c.";
  if ($old->{'array_dets'}) {
    my $c = scalar(@{$old->{'array_dets'}});
    if ($c) {
      my $synonyms_c = $c > 1 ? 'synonyms' : 'synonym';
      $desc .= " It has $c $synonyms_c:";
      foreach (@{$old->{'array_dets'}}) {
        my ($array_name,$probe_name) = @$_;
        $desc .= " $probe_name ($array_name array),";
      }
      $desc =~ s/,$//;
      $desc .= '.';
    }
  }
  return $p_probe_name,$desc;
}

sub OligoProbeLine {
  my ($species,$hid,$desc,$syns,$pset,$db,$counter) = @_; 
  my $url = sprintf(qq(%s/Location/Genome?fdb=%s;ftype=ProbeFeature;id=%s),
                   $species,
                   $db,
                   $hid);
  $url .= ";ptype=$pset" if $pset eq 'pset';
  $species =~ s/_/ /;
  my $xml = qq(
<doc>
  <field name="id">$hid</field>
  <field name="description">$desc</field>);

  #not used but could be if we ever need the client to distinguish between probes and probe sets
#  $xml .= qq(
#  <field name="ptype">$pset</field>);

  foreach my $syn (@{$syns||[]}) {
    my ($array_name,$probe_name) = @$syn;
    $xml .= qq(
  <field name="synonym">$probe_name</field>);
  }

  $xml .= &common_fields($species,'ProbeFeature',$db);
  $xml .= qq(
  <field name="domain_url">$url</field>
</doc>);
  $counter->();
  return $xml;
}


########################################################################## Domains

sub dumpDomain {
  my $conf = shift;
  my $dbname    = $conf->{'dbs'}{'DATABASE_CORE'};
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/${dbname}_Domain.xml";
  my $start_time = time;
  my $db = 'core';
  my $fh;
  open( $fh, ">$file" ) or die "Can't open $file: $!";
  print LOG "  Dumping $dbname to $file ... ".&date_and_mem()."\n";
  header($fh);

  my $sth = $conf->{'dbh'}->prepare(
    "select x.dbprimary_acc, i.id, x.description
       from xref as x, interpro as i, protein_feature pf
      where x.dbprimary_acc = i.interpro_ac
        and i.id = pf.hit_name
      group by i.id
      order by x.dbprimary_acc");
  $sth->execute();
  my $old_acc     = '';
  my $IDS         = [];
  my $description = '';
  my $count       = 0;
  my ($acc, $id, $desc, $old_desc );
  while( ($acc, $id, $desc ) = $sth->fetchrow_array()){
    if($acc eq $old_acc) {
      push @$IDS, $id;
      $count++;
    }
    else {
      if ($old_acc) {
        $description = "Interpro domain $old_acc [$old_desc] has";
        &p( DomainLine($dbspecies,$old_acc,$description,$IDS,$count,$counter ), $fh);
      }
      $IDS      = [ $id ];
      $old_acc  = $acc;
      $old_desc = $desc;
      $count    = 1;
    }
  }
  $description = "Interpro domain $old_acc [$old_desc] has";
  &p( DomainLine($dbspecies,$old_acc,$description,$IDS,$count,$counter ), $fh);
  return footer( $counter->(), $fh);
}

sub DomainLine {
  my($species, $acc, $desc, $IDS, $count, $counter) = @_;
  my $url = sprintf(qq(%s/Location/Genome?ftype=Domain;id=%s),
                    $species,
                    $acc);
  $species =~ s/_/ /;
  my $ids = join ',', @$IDS;
  my $description = &clean($desc)." $count associated external database identifiers: $ids";
  my $xml = qq(
<doc>
  <field name="id">$acc</field>
  <field name="description">$description</field>);
  foreach my $id (@$IDS) {
    $xml .= qq(
  <field name="synonym">$id</field>);
  }
  $xml .= &common_fields($species,'Protein Domain','core');
  $xml .= qq(
  <field name="domain_url">$url</field>
</doc>);
  $counter->();
  return $xml;
}


########################################################################## GeneTrees

sub dumpGeneTree {
  my $conf   = shift;
  my ($gt_present) = $conf->{'dbh_compara'}->selectrow_array(qq(SELECT count(*) FROM gene_tree_root WHERE stable_id IS NOT null));
  if (! $gt_present) {
    print LOG "  Error - can't find any gene trees to dump".&date_and_mem()."\n";
  }
  my $dbspecies = $conf->{'species'};
  my ($multi_species,$counter,$start_time,$fh);
  my $compara_dbname = $conf->{'dbs'}->{'DATABASE_COMPARA'};
  my $compara_file = $conf->{'directory'}."/${compara_dbname}_GeneTree.xml";
  unless (-e $compara_file) {
    $multi_species = 1;
    $counter   = make_counter(0);
    $start_time = time;
    $dbspecies = 'Multi';
    $fh;
    open( $fh, ">$compara_file" ) or die "Can't open $compara_file: $!";
    print LOG "  Dumping $compara_dbname to $compara_file ... ".&date_and_mem()."\n";
    header($fh);
    my $sth = $conf->{'dbh_compara'}->prepare(qq(SELECT stable_id FROM gene_tree_root WHERE stable_id IS NOT NULL));
    $sth->execute();
    while( my( $gt_id) = $sth->fetchrow_array()) {
      &p( GeneTreeLine($dbspecies,$gt_id,$counter,$multi_species), $fh);
    }
    my $c = footer( $counter->(), $fh);
  }
  $multi_species = 0;
  $dbspecies = $conf->{'species'};
  $counter   = make_counter(0);
  $start_time = time;
  my $dbname = $conf->{'dbs'}->{'DATABASE_CORE'};
  my $file = $conf->{'directory'}."/${dbname}_GeneTree.xml";
  my $fh;
  open( $fh, ">$file" ) or die "Can't open $file: $!";
  print LOG "  Dumping $dbname gene trees to $file ... ".&date_and_mem()."\n";
  header($fh);
  my $gene_names = { map { @$_ } @{$conf->{'dbh'}->selectall_arrayref( "select g.stable_id, x.display_label from gene g, xref x where g.display_xref_id = x.xref_id" )} };
  my $sql = qq(
        SELECT gtr.stable_id, gm.stable_id
         FROM gene_tree_root gtr
         JOIN gene_tree_node USING (root_id)
         JOIN seq_member sm USING (seq_member_id)
         JOIN gene_member gm ON sm.gene_member_id = gm.gene_member_id
         JOIN genome_db gdb ON gm.genome_db_id = gdb.genome_db_id
        WHERE clusterset_id = "default"
          AND tree_type = "tree"
          AND gdb.name = '$dbspecies');
  my $sth =  $conf->{'dbh_compara'}->prepare($sql);
  $sth->execute;
  while (my ($gt_id, $gid) = $sth->fetchrow_array() ) {
    next unless $gt_id;
    my $name = $gene_names->{$gid};
    &p( GeneTreeLine($dbspecies,$gt_id,$counter,$multi_species,$gid,$name), $fh);
  }
  return footer( $counter->(), $fh);
}

sub GeneTreeLine {
  my($species,$gt_id,$counter,$ms,$gid,$name) = @_;
  my ($url,$xml,$desc);
  $xml = qq(
<doc>
  <field name="id">$gt_id</field>);
  if ($ms) {
    $desc = "GeneTree $gt_id contains genes from multiple species";
    $xml .= qq(
  <field name="name">$gt_id</field>
  <field name="description">$desc</field>);
    $xml .= &common_fields($species,'GeneTree','compara');
    $url = sprintf(qq(Multi/GeneTree/Image?gt=%s),$gt_id);
    $xml .= qq(
  <field name="domain_url">$url</field>);
  }
  else {
    if ($name && ($name ne $gid)) {
      $desc = "Gene $name ($gid) is a member of GeneTree $gt_id";
      $xml .= qq(
  <field name="name">$gt_id</field>
  <field name="assoc_gene">$gid</field>
  <field name="assoc_gene_name">$name</field>
  <field name="description">$desc</field>);
    }
    else {
      $desc = "Gene $gid is a member of GeneTree $gt_id";
      $xml .= qq(
  <field name="name">$gt_id</field>
  <field name="assoc_gene">$gid</field>
  <field name="description">$desc</field>);
    }
    $xml .= &common_fields($species,'GeneTree','core');
    $url = sprintf(qq($species/Gene/Compara_Tree?g=%s),$gid);
    $xml .= qq(
  <field name="domain_url">$url</field>);
  }
  $xml .= qq(
</doc>);
  $counter->();
  return $xml;
}

########################################################################## Families

sub dumpFamily {
  my $conf   = shift;
  my ($multi_species,$counter,$start_time,$fh);
  my $compara_dbname = $conf->{'dbs'}->{'DATABASE_COMPARA'};
  my $dbname = $conf->{'dbs'}->{'DATABASE_CORE'};
  my $dbspecies;
  my ($family_present) = $conf->{'dbh_compara'}->selectrow_array(qq(SELECT count(*) from family));
  return unless $family_present;
  my $compara_file = $conf->{'directory'}."/${compara_dbname}_Family.xml";
  unless (-e $compara_file) {
    $multi_species = 1;
    $counter   = make_counter(0);
    $start_time = time;
    $dbspecies = 'Multi';
    $fh;
    open( $fh, ">$compara_file" ) or die "Can't open $compara_file: $!";
    print LOG "  Dumping $compara_dbname to $compara_file ... ".&date_and_mem()."\n";
    header($fh);

    # uniprot records linked to families do not have a species to filter on so link them to the cross species view
    my $uniprot_members;
    my $sth = $conf->{'dbh_compara'}->prepare(qq(
        SELECT f.stable_id as family_id, sm.stable_id as uniprot_id
          FROM family f, family_member fm, seq_member sm
         WHERE f.family_id = fm.family_id
           AND fm.seq_member_id = sm.seq_member_id
           AND sm.source_name like 'Uniprot%'));
    $sth->execute;
    while( my( $fid, $uniprot_id ) = $sth->fetchrow_array()) {
      push @{$uniprot_members->{$fid}}, $uniprot_id;
    }

    my $sth = $conf->{'dbh_compara'}->prepare(qq(SELECT stable_id, description FROM family));
    $sth->execute();
    while( my( $fid,$desc) = $sth->fetchrow_array()) {
      my @uniprots;
      foreach my $uniprot_id (@{$uniprot_members->{$fid}}) {
        push @uniprots,$uniprot_id;
      }
      &p( FamilyLine($dbspecies,$fid,$desc,$multi_species,'','','',\@uniprots,$counter ), $fh);
    }
    my $c = footer( $counter->(), $fh);
  }
  $multi_species = 0;
  my $t_sth  = $conf->{'dbh'}->prepare("select meta_value from $dbname.meta where meta_key='species.taxonomy_id'");
  $t_sth->execute;
  my $taxon_id = ($t_sth->fetchrow);
  return unless $taxon_id;

  $counter   = make_counter(0);
  $start_time = time;
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/${dbname}_Family.xml";
  my $db = 'core';
  my $fh;
  open( $fh, ">$file" ) or die "Can't open $file: $!";
  print LOG "  Dumping $dbname to $file ... ".&date_and_mem()."\n";
  header($fh);

  ( my $species = $conf->{'species'} ) =~ s/_/ /g;

  # get details of genes and proteins that make up the families for this species
  my $gene_names = { map { @$_ } @{$conf->{'dbh'}->selectall_arrayref(qq(
        SELECT g.stable_id, x.display_label
          FROM gene g, xref x
         WHERE g.display_xref_id = x.xref_id))}};
  my $transl = $conf->{'dbh'}->selectall_hashref(qq(
        SELECT tl.stable_id as transl, t.stable_id as trans
          FROM translation tl, transcript t
         WHERE tl.transcript_id = t.transcript_id),'transl');
#  warn
  my $gene_members = $conf->{'dbh_compara'}->selectall_hashref(qq(
        SELECT gm.gene_member_id, gm.stable_id
          FROM gene_member gm, genome_db gdb
         WHERE gm.genome_db_id = gdb.genome_db_id
           AND gm.source_name = 'ENSEMBLGENE'
           AND gdb.name = '$dbspecies'),'gene_member_id');
  my $protein_members = $conf->{'dbh_compara'}->selectall_hashref(qq(
        SELECT sm.seq_member_id, sm.stable_id
          FROM seq_member sm, genome_db gdb
         WHERE sm.genome_db_id = gdb.genome_db_id
           AND sm.source_name = 'ENSEMBLPEP'
           AND gdb.name = '$dbspecies'),'seq_member_id');
  #get all families
  my $sth = $conf->{'dbh_compara'}->prepare(qq(
    select f.stable_id,
           f.description,
           group_concat(fm.seq_member_id),
           group_concat(gm.gene_member_id)
      from family as f, family_member as fm, seq_member sm, gene_member gm
     where f.family_id = fm.family_id
       and fm.seq_member_id = sm.seq_member_id
       and sm.gene_member_id = gm.gene_member_id
       and sm.source_name not like 'Uniprot%'
     group by f.stable_id ));
  $sth->execute();
  my $X = $conf->{'authority'} || 'Ensembl';
  while( my( $fid, $desc, $seq_member_ids,$gene_member_ids ) = $sth->fetchrow_array()) {
    $desc =~ s/(\S+)\/(\S+)/$1 \/ $2/g;
    my (%genes,%proteins,%transcripts);
    foreach my $gene_id (split ',',$gene_member_ids) {
      if ($gene_members->{$gene_id}) {
	my $stable_id = $gene_members->{$gene_id}{'stable_id'};
	my $display_label = $gene_names->{$stable_id} || 'none';
        $genes{$stable_id}{display_label} = $display_label;
      }
    }
    foreach my $tl_id (split ',', $seq_member_ids) {
      if ($protein_members->{$tl_id}) {
        my $tl_sid = $protein_members->{$tl_id}{'stable_id'};
        $proteins{$tl_sid}++;
	my $t_sid = $transl->{$tl_sid}{'trans'};
	$transcripts{$t_sid}++;
      }
    }
    if (%genes) {
      my $ensembl_genes_species    = scalar (keys %genes);
      my $ensembl_peptides_species = scalar (keys %proteins);
      my $genes   = $ensembl_genes_species == 1 ? 'gene' : 'genes';
      my $peptide = $ensembl_peptides_species == 1 ? 'protein' : 'proteins';
      my $full_desc = qq($X protein family $fid [$desc]: $ensembl_genes_species $genes / $ensembl_peptides_species $peptide in $species);
      &p( FamilyLine($dbspecies,$fid,$full_desc,$multi_species,\%genes,\%proteins,\%transcripts,'',$counter ), $fh);
    }
  }
  return footer( $counter->(), $fh);
}

sub FamilyLine {
  my($species,$fid,$desc,$ms,$genes,$proteins,$transcripts,$uniprots,$counter) = @_;
  my ($url,$xml);
  my $boost = $ms ? $boosts->{'Family'}{'ms'} : $boosts->{'Family'}{'species'};
  my $doc = $boost ? qq(doc boost="$boost") : 'doc';
  $desc = &clean($desc,'desc');
  $xml = qq(
<$doc>
  <field name="id">$fid</field>
  <field name="name">$fid</field>);
  if ($ms) {
    my $full_desc = "Gene family $fid ($desc) contains genes from multiple species";
    $xml .= qq(
  <field name="description">$full_desc</field>);
    foreach my $up (@$uniprots){
      $xml .= qq(
  <field name="assoc_protein">$up</field>);
    }
    $url = sprintf(qq(Multi/Family/Details?fm=%s),$fid);
    $xml .= &common_fields($species,'Protein Family','compara');
    $xml .= qq(
  <field name="domain_url">$url</field>);
  }
  else {
    $xml .= qq(
  <field name="description">$desc</field>);
    my $sample_g;
    my %seen_names;
    foreach my $gsi (keys $genes){
      unless ($sample_g) {
        $sample_g = $gsi;
        $url = sprintf(qq(%s/Gene/Family?family=%s;g=%s),
                       $species,
                       $fid,
                       $sample_g,
                     );
        $species =~ s/_/ /;
      }
      $xml .= qq(
  <field name="assoc_gene">$gsi</field>);
      my $name = $genes->{$gsi}{'display_label'};
      unless ($seen_names{$name}) {
        unless ($name eq 'none') {
          $seen_names{$name}++;
          $xml .= qq(
  <field name="assoc_gene_name">$name</field>);
        }
      }
    }
    foreach my $id (keys %$proteins){
      $xml .= qq(
  <field name="assoc_protein">$id</field>);
    }
    foreach my $id (keys %$transcripts){
      $xml .= qq(
  <field name="assoc_transcript">$id</field>);
    }
    $xml .= &common_fields($species,'Protein Family','core');
    $xml .= qq(
  <field name="domain_url">$url</field>);
  }
  $xml .= qq(
</doc>);
  $counter->();
  return $xml;
}


########################################################################## Sequences

sub dumpSequence {
  my $conf = shift;
  my $sanger = {};
  my @misc_feat_disallowed = (); #features that we know we don't want to dump if we ever decide to do this (not implemented)
  my @name_order = (qw(name well_name clone_name sanger_project synonym embl_acc)); #defines the order of attribute_type we use to get the name for misc_features (comes from B::E::G::_clone.pm)
  my $dbname    = $conf->{'dbs'}{'DATABASE_CORE'};
  my $counter   = make_counter(0);
  my $dbspecies = $conf->{'species'};
  my $file = $conf->{'directory'}."/${dbname}_Sequence.xml";
  my $start_time = time;
  my $db = 'core';
  my $fh;
  open( $fh, ">$file" ) or die "Can't open $file: $!";
  print LOG "  Dumping $dbname to $file ... ".&date_and_mem()."\n";
  header($fh);

  my $lrgs = &findLRGs($conf);
  if (@$lrgs) {
    &sort_lrgs($dbspecies,'Sequence',$fh,$lrgs);
  }

  #get all types of misc features - used for 'type' label
  my $feat_types = $conf->{'dbh'}->selectall_hashref(qq(
                  SELECT ms.code, ms.misc_set_id, ma.value as type
                    FROM $dbname.attrib_type at, $dbname.misc_attrib ma, $dbname.misc_feature_misc_set mfms, $dbname.misc_set ms
                   WHERE at.attrib_type_id = ma.attrib_type_id
                     AND ma.misc_feature_id = mfms.misc_feature_id
                     AND mfms.misc_set_id = ms.misc_set_id
                     AND at.code = 'type'
                   GROUP by ms.code, ma.value), 'misc_set_id');
  if (%$feat_types) {
    my $mapsets = join ',', keys %$feat_types;
    #get all misc_features
    my $sth = $conf->{'dbh'}->prepare(qq(
       SELECT mf.misc_feature_id, sr.name, cs.name, mf.seq_region_start, mf.seq_region_end,
              mf.seq_region_end-mf.seq_region_start+1 as len, ms.misc_set_id, at.code, ma.value
         FROM $dbname.misc_feature_misc_set as ms,
              $dbname.misc_feature as mf,
              seq_region as sr,
              coord_system as cs,
              $dbname.misc_attrib as ma,
              $dbname.attrib_type as at
        WHERE cs.coord_system_id = sr.coord_system_id
          AND sr.seq_region_id = mf.seq_region_id 
          AND mf.misc_feature_id = ms.misc_feature_id
          AND ms.misc_set_id in ($mapsets)
          AND mf.misc_feature_id = ma.misc_feature_id
          AND ma.attrib_type_id = at.attrib_type_id
        ORDER by mf.misc_feature_id, at.code));
    $sth->execute();
    my ($old_ID,$old_sr,$old_sr_type,$old_start,$old_end,$old_len,$NAMES,$ftype);
    while( my($ID,$sr,$sr_type,$start,$end,$len,$ms_id,$code,$val) = $sth->fetchrow_array() ) {
      if($ID == $old_ID) {
        if (! $ftype && $code eq 'type') {
          $ftype = $feat_types->{$ms_id}{'type'};
          #some hacks for the display of the type
          $ftype =~ s/_/ /;
          $ftype =~ s/arrayclone/clone/;
          $ftype = ucfirst($ftype);
        }
        if (grep {$code eq $_} @name_order) {
          push @$NAMES, [$code,$val];
        }
      }
      else {
        if ($old_ID) {
          my ($name, $synonyms) = &sort_mf_names($NAMES,\@name_order);
          &p( SeqLine($dbspecies,$old_sr,$old_sr_type,$old_start,$old_end,$old_len,$name,$synonyms,[],$ftype,$sanger,$counter), $fh);
          $NAMES = undef;
          $ftype = undef;
        }
        if (! $ftype && $code eq 'type') {
          $ftype = $feat_types->{$ms_id}{'type'};
          $ftype =~ s/_/ /;
          $ftype =~ s/arrayclone/clone/;
          $ftype = ucfirst($ftype);
        }
        if (grep {$code eq $_} @name_order) {
          push @$NAMES, [$code,$val];
        }
        ($old_ID,$old_sr,$old_sr_type,$old_start,$old_end,$old_len) = ($ID,$sr,$sr_type,$start,$end,$len);
      }
    }
    my ( $name, $synonyms) = sort_mf_names($NAMES,\@name_order);
    &p( SeqLine($dbspecies,$old_sr,$old_sr_type,$old_start,$old_end,$old_len,$name,$synonyms,[],$ftype,$sanger,$counter), $fh);
  }

  #identify current default top level
  (my $current_cs_id) = $conf->{'dbh'}->selectrow_array(qq(
       SELECT cs.coord_system_id
         FROM coord_system cs, meta m
        WHERE cs.version = m.meta_value
          AND cs.name = 'chromosome'
          AND m.meta_key = 'assembly.default'));

  my %patch_hap_dets = ();
  # get seq_region_synonyms and start / stop positions for patches (ensembl)
  #  - requires the supercontig (which has the seq_region_synonym) and the chromosome to have the same name
  #  - positions come from assembly_exception table
  my $sth = $conf->{'dbh'}->prepare(qq(
       SELECT sr2.name, srs.synonym, ae.seq_region_start, ae.seq_region_end
         FROM coord_system cs, seq_region sr2, assembly_exception ae, seq_region sr1
            LEFT JOIN seq_region_synonym srs ON sr1.seq_region_id = srs.seq_region_id
       WHERE sr1.name = sr2.name
         AND sr1.coord_system_id != sr2.coord_system_id
         AND sr1.coord_system_id = cs.coord_system_id
         AND sr2.seq_region_id = ae.seq_region_id));
  $sth->execute;
  while (my ($name, $grc_name, $start, $end) = $sth->fetchrow_array() ) {
    $patch_hap_dets{$name} = {
      'name' => $name,
      'syn'  => $grc_name,
      'start'=> $start,
      'end'   => $end,
    };
  }


  #for Vega - get Ensembl chromosome names if they're different from the vega names
  my %enames = ();
  if ($sitetype eq 'Vega') {
    $sth = $conf->{'dbh'}->prepare(qq(
       SELECT sr.name, sra.value
         FROM seq_region sr, seq_region_attrib sra, attrib_type at
        WHERE sr.seq_region_id = sra.seq_region_id
          AND sra.attrib_type_id = at.attrib_type_id
          AND sr.name != sra.value
          AND at.code = 'ensembl_name'));
    $sth->execute;
    while (my ($v_name, $e_name) = $sth->fetchrow_array() ) {
      $enames{$v_name} = $e_name;
    }
    #get seq_region_synonyms and start / stop positions for patches (vega)
    %patch_hap_dets = ();
    $sth = $conf->{'dbh'}->prepare(qq(
              SELECT sr.name, concat(sra1.value,'.',sra2.value) as synonym,  ae.seq_region_start, ae.seq_region_end
                FROM assembly_exception ae, seq_region sr, seq_region_attrib sra1, attrib_type at1, seq_region_attrib sra2, attrib_type at2
               WHERE sr.seq_region_id    = ae.seq_region_id
                 AND sr.seq_region_id    = sra1.seq_region_id
                 AND sra1.attrib_type_id = at1.attrib_type_id
                 AND at1.code            = 'embl_acc'
                 AND sr.seq_region_id    = sra2.seq_region_id
                 AND sra2.attrib_type_id = at2.attrib_type_id
                 AND at2.code            = 'embl_version'));
    $sth->execute;
    while (my ($name, $grc_name, $start, $end) = $sth->fetchrow_array() ) {
      $patch_hap_dets{$name} = {
        'name' => $name,
        'syn'  => $grc_name,
        'start'=> $start,
        'end'   => $end,
      };
    }
  }

  #haplotypes
  $sth = $conf->{'dbh'}->prepare(qq(
       SELECT sr.name, ae.seq_region_start, ae.seq_region_end
         FROM assembly_exception ae, seq_region sr
        WHERE ae.seq_region_id = sr.seq_region_id
          AND ae.exc_type = 'HAP'));
  $sth->execute;
  while (my ($name, $start, $end) = $sth->fetchrow_array() ) {
    $patch_hap_dets{$name} = {
      'name' => $name,
      'start'=> $start,
      'end'   => $end,
    };
  }

  #get all seq_regions
  $sth = $conf->{'dbh'}->prepare(qq(
       SELECT sr.name, sr.length, cs.name, cs.coord_system_id, srs.synonym
         FROM coord_system as cs, seq_region as sr
         LEFT JOIN seq_region_synonym as srs on sr.seq_region_id = srs.seq_region_id
        WHERE sr.coord_system_id = cs.coord_system_id));
  $sth->execute();
  my ($old_name,$old_type,$old_length,$old_start,$old_end);
  my $synonyms = [];
  my $other_names = [];
  while( my($name,$length,$type,$cs_id,$syn) = $sth->fetchrow_array() ) {
    my ($prev_name,$prev_length,$mapping_text);
    next if $type eq 'lrg'; #we've done LRGs already
    next if $type eq 'supercontig' && $patch_hap_dets{$name}; #don't index the supercontig with PATCH name
    next if ($type eq 'chromosome') && ($cs_id != $current_cs_id); #don't index chromosomes from previous assemblies
    if ($old_name eq $name) {
      push @$synonyms, $syn if $syn;
    }
    else {
      if ($old_name) {
        &p( SeqLine($dbspecies,$old_name,$old_type,$old_start,$old_end,$old_length,$old_name,$synonyms,$other_names,$old_type,$sanger,$counter), $fh);
      }
      $old_name = $name;
      $old_type = $type;
      $old_length = $length;
      $synonyms = [];
      $other_names = [];
      if (my $ename = $enames{$name}) {
        push @$other_names, $ename;
      }
      push @$synonyms, $syn if $syn;

      #set different seq_region start and stop, add a synonym, for Patches
      if ($patch_hap_dets{$old_name}) {
        $old_end = $patch_hap_dets{$old_name}{'end'};
        $old_start = $patch_hap_dets{$old_name}{'start'};
        if ($patch_hap_dets{$old_name}{'syn'}) {
          push @$synonyms, $patch_hap_dets{$old_name}{'syn'} unless (grep {$syn eq $_} @$synonyms);
        }
      }
      else {
        $old_end = $length;
        $old_start = 1;
      }
    }
  }
  &p( SeqLine($dbspecies,$old_name,$old_type,$old_start,$old_end,$old_length,$old_name,$synonyms,$other_names,$old_type,$sanger,$counter), $fh);
  return footer( $counter->(), $fh);
}

#decide which of the possible many name entries we should be using, the rest will be synonyms
sub sort_mf_names {
  my ($all_names, $name_order) = @_;
  my $name_to_use;
  foreach my $name_type ( @$name_order ) {
    unless ($name_to_use) {
      foreach my $name (@$all_names) {
        if ($name->[0] eq $name_type) {
          $name_to_use = $name->[1];
        }
      }
    }
  }
  my @synonyms = map {$_->[1]} grep { $_->[1] ne $name_to_use } @$all_names;
  return $name_to_use, \@synonyms ;
}

sub SeqLine {
  my($species,$sr,$sr_type,$start,$end,$len,$name,$synonyms,$other_names,$type,$sanger,$counter) = @_;
  print LOG "WARNING: no type set for $name" unless $type;
  my $action = $len > 0.5e6 ? 'Overview' : 'View';
  my $r = "$sr:$start-$end";
  my $url = sprintf(qq(%s/Location/%s?r=%s),
                    $species,
                    $action,
                    $r);
  $species =~ s/_/ /;

  my $desc = ($name eq $sr) ? "$type $name has a length of $len bp." : "$type $name (length $len bp) is mapped to $sr_type $sr.";
  #deal with any synonyms
  if (@$synonyms) {
    $desc .= " It has synonyms of " . join(',',@$synonyms) . ".";
  }

  my $xml = qq(
<doc>
  <field name="id">$name</field>
  <field name="description">$desc</field>);
  foreach my $syn (@$synonyms, @$other_names) {
    $xml .= qq(
  <field name="synonym">$syn</field>);
  }
  $xml .= &common_fields($species,'Sequence','core');
  $xml .= qq(
  <field name="domain_url">$url</field>
</doc>);
  $counter->();
  return $xml;
}

########################################################################## Genes

#contains hacks to exclude rnaseq, refseq and ccds_import

sub dumpGene {
  my $conf      = shift;
  my $dbspecies = $conf->{'species'};
  my $COREDB    = $conf->{'dbs'}->{'DATABASE_CORE'};
  my $ESTGENEDB = $conf->{'dbs'}->{'DATABASE_OTHERFEATURES'};
  my $RNASEQDB = $conf->{'dbs'}->{'DATABASE_RNASEQ'};
  my %dbs = ( 'core' => $COREDB );
  $dbs{'otherfeatures'} = $ESTGENEDB if $ESTGENEDB;
#  $dbs{'rnaseq'} = $RNASEQDB if $RNASEQDB; #don't add these until the IDs mean something and the gene pages are usefull!
  my $total_c;
 DB:
  foreach my $db ( sort { $b cmp $a } keys %dbs) {
    my $dbname    = $dbs{$db};
    my $counter   = make_counter(0);
    my $file = $conf->{'directory'}."/${dbname}_Gene.xml";
    my $start_time = time;
    my $fh;
    open( $fh, ">$file" ) or die "Can't open $file: $!";
    print LOG "  Dumping $dbname to $file ... ".&date_and_mem()."\n";
    header($fh);

    #does this species have PATCHES
    (my $has_patches) = $conf->{'dbh'}->selectrow_array(qq(select count(*) from assembly_exception where exc_type != 'PAR'));

    my $external_dbs = $conf->{'dbh'}->selectall_hashref(
      'select external_db_id, db_display_name
         from external_db', 'external_db_id'
       );
    my $external_synonyms;
    my $es = $conf->{'dbh'}->selectall_arrayref(qq(select xref_id, synonym from external_synonym));
    foreach (@$es) {
      $external_synonyms->{$_->[0]}{$_->[1]} = 1;
    }

    my %xrefs = ();
    foreach my $type( qw(Gene Transcript Translation) ) {
      my $t = lc($type);
      my $sql = qq(
         SELECT f.stable_id, x.external_db_id, x.display_label, x.description, x.xref_id
           FROM $dbname.$t as f, $dbname.object_xref as ox, $dbname.xref as x
          WHERE f.${t}_id = ox.ensembl_id
            AND ox.xref_id = x.xref_id 
            AND ox.ensembl_object_type = '$type');
      my $T = $conf->{'dbh'}->selectall_arrayref($sql);
      foreach (@$T) {
        my $stable_id         = $_->[0];
        my $external_db_label = $_->[2];
        my $external_db_desc  = $_->[3];
        my $xref_id           = $_->[4];
        my $external_db = $external_dbs->{$_->[1]}{'db_display_name'};
        my $desc        = "$external_db_label ($external_db";
        my $search_term = "$external_db_label";
        if ($external_db_desc) {
          $external_db_desc =~ s/ $//;
          $desc .= " record with a description of $external_db_desc)";
          $search_term .= " $external_db_desc";
        }
        else {
          $desc .= ')'; 
        }
        if ($external_synonyms->{$xref_id}) {
          my $syn_c = keys(%{$external_synonyms->{$xref_id}});
          $desc .= $syn_c > 1 ? ', with synonyms of' : ', with a synonym of';
          foreach my $syn (keys %{$external_synonyms->{$xref_id}}) {
            $search_term .= " $syn";
            $desc .= " $syn,";
          }
        }
        $desc .= " is associated with $type $stable_id";
        push @{$xrefs{$type}{$stable_id}},{
          id          => $external_db_label,
          search_term => $search_term,
          desc        => $desc,
        };
      }
      print LOG "    $type xref query done ".&date_and_mem()."\n";
    }
    #    warn Dumper(\%xrefs); exit;

    my %gene_trans_syns = ();
    if ($sitetype eq 'Vega') {
      print LOG "    Getting gene and transcript synonyms ".&date_and_mem()."\n";
      my ($gc,$tc) = (0,0);
      my $sql = qq(
         SELECT g.stable_id, ga.value
           FROM $dbname.gene g, $dbname.gene_attrib ga, $dbname.attrib_type at
          WHERE g.gene_id = ga.gene_id
            AND ga.attrib_type_id = at.attrib_type_id
            AND at.code = 'synonym');
      my $G = $conf->{'dbh'}->selectall_arrayref($sql);
      foreach (@$G) {
        $gc++;
        push @{$gene_trans_syns{$_->[0]}},$_->[1];
      }
      $sql = qq(
         SELECT t.stable_id, ta.value
           FROM $dbname.transcript t, $dbname.transcript_attrib ta, $dbname.attrib_type at
          WHERE t.transcript_id = ta.transcript_id
            AND ta.attrib_type_id = at.attrib_type_id
            AND at.code = 'synonym');
      my $T = $conf->{'dbh'}->selectall_arrayref($sql);
      foreach (@$T) {
        $tc++;
        push @{$gene_trans_syns{$_->[0]}},$_->[1];
      }
      print LOG "    Got $gc gene and $tc transcript synonyms ".&date_and_mem()."\n";
    }

    my %exons = ();
    my $sql = qq(
       SELECT distinct t.gene_id, e.stable_id
         FROM $dbname.transcript as t, $dbname.exon_transcript as et, $dbname.exon as e
        WHERE t.transcript_id = et.transcript_id
          AND et.exon_id = e.exon_id);
    my $sth = $conf->{'dbh'}->prepare($sql);
    $sth->execute;
    while (my $r = $sth->fetchrow_arrayref()) {
      $exons{$r->[0]}{$r->[1]}=1;
    }
    $sth->finish;
    print LOG "    Exon query done ".&date_and_mem()."\n";

    $sql = qq(
      SELECT g.stable_id, sr.name as sr_name, g.seq_region_start, g.seq_region_end, g.seq_region_strand, cs.name as sr_type, cs.version,
             (SELECT sra.value 
                FROM $dbname.seq_region_attrib sra, $dbname.attrib_type at
               WHERE sr.seq_region_id = sra.seq_region_id
                 AND sra.attrib_type_id = at.attrib_type_id
                 AND at.code = 'non_ref') as non_ref
        FROM $dbname.gene g, $dbname.coord_system cs, $dbname.seq_region sr
       WHERE g.seq_region_id = sr.seq_region_id 
         AND sr.coord_system_id = cs.coord_system_id);
    my $gene_locations = $conf->{'dbh'}->selectall_hashref($sql,'stable_id');
    $sql = qq(
      SELECT g.gene_id, t.transcript_id, tr.translation_id,
             g.stable_id as gsid, g.version as gversion, t.stable_id as tsid, t.version as tversion, tr.stable_id as trsid, tr.version as trversion,
             g.description, x.display_label, ad.display_label, ad.web_data, ad.displayable, g.status, g.biotype, a.logic_name
        FROM (( $dbname.gene as g,
             $dbname.analysis as a,
             $dbname.analysis_description as ad,
             $dbname.transcript as t) left join
             $dbname.translation as tr on t.transcript_id = tr.transcript_id) left join
             $dbname.xref as x on g.display_xref_id = x.xref_id
       WHERE t.gene_id = g.gene_id
         AND g.analysis_id = a.analysis_id
         AND g.analysis_id = ad.analysis_id
         AND a.logic_name != 'LRG_import'
       ORDER by g.stable_id, t.stable_id);
    $sth = $conf->{'dbh'}->prepare($sql);
    $sth->execute();

    my $old;
    my $c;
    my ($gid,$tid,$tlid,$gsid,$gver,$tsid,$tver,$tlsid,$tlver,$desc,$disp_xref,$ad_dl,$webdata,$displayable,$status,$biotype,$ln);
    while (my $r = $sth->fetchrow_arrayref()) {
      ($gid,$tid,$tlid,$gsid,$gver,$tsid,$tver,$tlsid,$tlver,$desc,$disp_xref,$ad_dl,$webdata,$displayable,$status,$biotype,$ln) = @$r;
      my $wd = eval($webdata);
      next if $wd->{'gene'}{'do_not_display'};
      next if ($ln =~ /rnaseq/);
      next if ($ln =~ /ccds_import/); #exclude CCDS transcripts
      next if ($ln =~ /refseq_\w+_import/); #exclude RefSeq transcripts
      if( $old->{'gid'} != $gid ) {
        if( $old->{'gid'} ) {
          my $type = $old->{'biotype'}.' '.$old->{'ad_dl'};
	  (my $old_gsi) = keys %{$old->{'gsid'}};
          &p( GeneTransLine('Gene',
                       $dbspecies,
                       $old->{'gsid'},
                       $old->{'tsids'},
                       $old->{'tlsids'},
                       $old->{'exons'},
                       $old->{'biotype'},
                       $old->{'ad_dl'},
                       $old->{'disp_xref'},
                       $old->{'desc'},
                       $old->{'xrefs'},
                       $old->{'synonyms'},
                       '',
                       $gene_locations->{$old_gsi},
                       $has_patches,
                       $db,
                       $counter),
              $fh);
          $c++;
        }

        $old = {
          'gid'       => $gid,
          'gsid'      => { $gsid => $gver },
          'tlsids'    => { $tlsid ? ($tlsid => $tlver)  :()},
          'tsids'     => { $tsid  ? ($tsid  => $tver) :()},
          'desc'      => $desc,
          'exons'     => {},
          'biotype'   => $biotype,
          'ad_dl'     => $ad_dl,
          'xrefs'     => [],
          'synonyms'  => [ @{$gene_trans_syns{$gsid}||[]}, @{$gene_trans_syns{$tsid}||[]} ],
          'disp_xref' => $disp_xref ? "$disp_xref" : "novel gene",
          'status'    => $status,
          'biotype'   => $biotype,
          'ad_dl'     => $ad_dl,
        };

        $old->{'exons'}  = $exons{$gid};

        #add xref details
        foreach my $type (qw(Gene Transcript Translation)) {
          my $id = ($type eq 'Gene')        ? $gsid
                 : ($type eq 'Transcript')  ? $tsid
                 : ($type eq 'Translation') ? $tlsid
                 : '';
          foreach my $xref (@{$xrefs{$type}{$id}}) {
            push @{$old->{'xrefs'}}, $xref;
          }
        }
      }
      else {
        $old->{'tsids' }{$tsid }= ($tsid  => $tver);
        $old->{'tlsids'}{$tlsid}= ($tlsid => $tlver) if $tlsid;
        push @{$old->{'synonyms'}}, @{$gene_trans_syns{$tsid}||[]};

        #add xref details
        foreach my $type (qw(Gene Transcript Translation)) {
          my $id = ($type eq 'Gene')        ? $gsid
                 : ($type eq 'Transcript')  ? $tsid
                 : ($type eq 'Translation') ? $tlsid
                 : '';
          foreach my $xref (@{$xrefs{$type}{$id}}) {
            push @{$old->{'xrefs'}}, $xref;
          }
        }
      }
    }
    if ($old->{'gsid'}) {
      (my $old_gsi) = keys %{$old->{'gsid'}};
      &p( GeneTransLine('Gene',
                        $dbspecies,
                        $old->{'gsid'},
                        $old->{'tsids'},
                        $old->{'tlsids'},
                        $old->{'exons'},
                        $old->{'biotype'},
                        $old->{'ad_dl'},
                        $old->{'disp_xref'},
                        $old->{'desc'},
                        $old->{'xrefs'},
                        $old->{'synonyms'},
                        '',
                        $gene_locations->{$old_gsi},
                        $has_patches,
                        $db,
                        $counter),
          $fh);
      $c++;
    }
    print LOG "    Querying done, added $c entries ".&date_and_mem()."\n";

    #archive Stable IDs
    my $other_count = &do_archive_stable_ids( [ 'gene' ], $dbname, $db, $fh, $counter );

    print LOG "    Stable_id mapping querying done, added $other_count entries ".&date_and_mem()."\n";
    $total_c += footer( $counter->(), $fh);

    #this code for unmapped entries has not been used for a long time and will not work
    while (0) {
      $other_count = 0;
      my %unmapped_queries = (
        'None' => qq(
      select a.logic_name, e.db_display_name,
             uo.identifier, ur.summary_description,
             'Not mapped'
        from $dbname.analysis as a, $dbname.external_db as e, $dbname.unmapped_object as uo,
             $dbname.unmapped_reason as ur
       where a.analysis_id = uo.analysis_id and
             uo.external_db_id = e.external_db_id and
             uo.unmapped_reason_id = ur.unmapped_reason_id and
               uo.ensembl_id = 0
       ),
       'Transcript' => qq(
      select a.logic_name, e.db_display_name,
             uo.identifier, ur.summary_description,
             concat( 'Transcript: ', t.stable_id, '; Gene: ',g.stable_id )
        from $dbname.analysis as a, $dbname.external_db as e, $dbname.unmapped_object as uo,
             $dbname.unmapped_reason as ur, $dbname.transcript as t, $dbname.gene as g
       where a.analysis_id = uo.analysis_id and
             uo.external_db_id = e.external_db_id and
             uo.unmapped_reason_id = ur.unmapped_reason_id and
             uo.ensembl_id = t.transcript_id and
             uo.ensembl_object_type = 'Transcript' and
             t.gene_id       = g.gene_id
       ),
        'Translation' => qq(
      select a.logic_name, e.db_display_name, uo.identifier, ur.summary_description,
             concat( 'Protein: ',tr.stable_id,'; Transcript: ', t.stable_id, '; Gene: ',g.stable_id )
        from $dbname.analysis as a, $dbname.external_db as e, $dbname.unmapped_object as uo,
             $dbname.unmapped_reason as ur, $dbname.translation as tr, $dbname.transcript as t, $dbname.gene as g
       where a.analysis_id = uo.analysis_id and
             uo.external_db_id = e.external_db_id and
             uo.unmapped_reason_id = ur.unmapped_reason_id and
             uo.ensembl_id = tr.translation_id and
             tr.transcript_id = t.transcript_id and
             uo.ensembl_object_type = 'Translation' and
             t.gene_id = gsi.gene_id
       ),
      );
      foreach my $FLAG (keys %unmapped_queries) {
        my $SQL = $unmapped_queries{$FLAG};
        my $sth = $conf->{'dbh'}->prepare($SQL);
        $sth->execute;
        while( my $T = $sth->fetchrow_arrayref() ) {
          print O join "\t",
            qq(Unmapped feature),
              "$T->[1] $T->[2]",
                "/$conf->{'species'}/Location/Genome?ftype=Gene;id=$T->[2]",
                  "$T->[2] $T->[4]",
                    "$T->[3]; $T->[4]\n";
        }
      }
    }
    close O;
  }
  return $total_c;
}


########################################################################## Transcripts

sub dumpTranscript {
  my $conf      = shift;
  my $dbspecies = $conf->{'species'};
  my $COREDB    = $conf->{'dbs'}->{'DATABASE_CORE'};
  my $ESTGENEDB = $conf->{'dbs'}->{'DATABASE_OTHERFEATURES'};
  my $RNASEQDB  = $conf->{'dbs'}->{'DATABASE_RNASEQ'};
  my %dbs = ( 'core' => $COREDB );
  $dbs{'otherfeatures'} = $ESTGENEDB if $ESTGENEDB;
#  $dbs{'rnaseq'} = $RNASEQDB if $RNASEQDB; #don't add these until the IDs mean something and the transcript pages are usefull
  my $total_c;

 DB:
  foreach my $db ( sort { $b cmp $a } keys %dbs) {
    my $dbname    = $dbs{$db};
    my $counter   = make_counter(0);
    my $file = $conf->{'directory'}."/${dbname}_Transcript.xml";
    my $start_time = time;
    my $fh;
    open( $fh, ">$file" ) or die "Can't open $file: $!";
    print LOG "  Dumping $dbname to $file ... ".&date_and_mem()."\n";
    header($fh);

    #does this species have PATCHES
    (my $has_patches) = $conf->{'dbh'}->selectrow_array(qq(select count(*) from assembly_exception where exc_type != 'PAR'));

    my $external_dbs = $conf->{'dbh'}->selectall_hashref(
      'select external_db_id, db_name, db_display_name, description
         from external_db', 'external_db_id'
       );
    my $external_synonyms;
    my $es = $conf->{'dbh'}->selectall_arrayref(qq(select xref_id, synonym from external_synonym));
    foreach (@$es) {
      $external_synonyms->{$_->[0]}{$_->[1]} = 1;
    }
    my %xrefs = ();
    foreach my $type( qw(Transcript Translation) ) {
      my $t = lc($type);
      my $sql = qq(
         SELECT f.stable_id, x.external_db_id, x.display_label, x.description, x.xref_id
           FROM $dbname.$t as f, $dbname.object_xref as ox, $dbname.xref as x
          WHERE f.${t}_id = ox.ensembl_id
            AND ox.xref_id = x.xref_id
            AND ox.ensembl_object_type = '$type');
      my $T = $conf->{'dbh'}->selectall_arrayref($sql);
      foreach (@$T) {
        my $stable_id         = $_->[0];
        my $external_db_label = $_->[2];
        my $external_db_desc  = $_->[3];
        my $xref_id           = $_->[4];
        my $external_db = $external_dbs->{$_->[1]}{'db_display_name'};
        my $desc        = "$external_db_label ($external_db";
        my $search_term = "$external_db_label";
        if ($external_db_desc) {
          $external_db_desc =~ s/ $//;
          $desc .= " record with a description of $external_db_desc)";
          $search_term .= " $external_db_desc";
        }
        else {
          $desc .= ')'; 
        }
        if ($external_synonyms->{$xref_id}) {
          my $syn_c = keys(%{$external_synonyms->{$xref_id}});
          $desc .= $syn_c > 1 ? ', with synonyms of' : ', with a synonym of';
          foreach my $syn (keys %{$external_synonyms->{$xref_id}}) {
            $search_term .= " $syn";
            $desc .= " $syn,";
          }
        }
        $desc .= " is associated with $type $stable_id";
        push @{$xrefs{$type}{$stable_id}},{
          id          => $external_db_label,
          search_term => $search_term,
          desc        => $desc,
        };
      }
      print LOG "    $type xref query done ".&date_and_mem()."\n";
    }

    my $supporting_evidence;
    foreach my $t ('dna_align_feature','protein_align_feature') {
      my $sql = qq(
        SELECT t.stable_id, f.hit_name, edb.db_display_name
          FROM transcript t, transcript_supporting_feature tsf, $t f
          LEFT JOIN external_db edb ON f.external_db_id = edb.external_db_id
         WHERE t.transcript_id = tsf.transcript_id
           AND tsf.feature_id = f.${t}_id and tsf.feature_type = '$t');
      my $sth = $conf->{'dbh'}->prepare($sql);
      $sth->execute();
      while (my ($tsi,$hit,$db) = $sth->fetchrow_array()) {
        $supporting_evidence->{$tsi}{$db}{$hit}++;
      }
      $sql = qq(
        SELECT t.stable_id, f.hit_name, edb.db_display_name
          FROM transcript t, exon_transcript et, supporting_feature sf, $t f
          LEFT JOIN external_db edb ON f.external_db_id = edb.external_db_id
         WHERE t.transcript_id = et.transcript_id
           AND et.exon_id = sf.exon_id
           AND sf.feature_id = f.${t}_id
           AND sf.feature_type = '$t');
      $sth = $conf->{'dbh'}->prepare($sql);
      $sth->execute();
      while (my ($tsi,$hit,$db) = $sth->fetchrow_array()) {
        $supporting_evidence->{$tsi}{$db}{$hit}++;
      }
    }

    print LOG "    Supporting evidence query done... ".&date_and_mem()."\n";

#    warn Data::Dumper::Dumper($supporting_evidence); exit;

    my %trans_syns = ();
    if ($sitetype eq 'Vega') {
      print LOG "    Getting transcript synonyms ".&date_and_mem()."\n";
      my $sql = qq(
         SELECT t.stable_id, ta.value
           FROM $dbname.transcript t, $dbname.transcript_attrib ta, $dbname.attrib_type at
          WHERE t.transcript_id = ta.transcript_id
            AND ta.attrib_type_id = at.attrib_type_id
            AND at.code = 'synonym');
      my $T = $conf->{'dbh'}->selectall_arrayref($sql);
      foreach (@$T) {
        push @{$trans_syns{$_->[0]}},$_->[1];
      }
      print LOG "    Got transcript synonyms ".&date_and_mem()."\n";
    }

    my %exons = ();
    my $sql = qq(
       SELECT t.transcript_id, e.stable_id
         FROM $dbname.transcript as t, $dbname.exon_transcript as et, $dbname.exon as e
        WHERE t.transcript_id = et.transcript_id
          AND et.exon_id = e.exon_id);
    my $sth = $conf->{'dbh'}->prepare($sql);
    $sth->execute;
    while (my $r = $sth->fetchrow_arrayref()) {
      $exons{$r->[0]}{$r->[1]}=1;
    }
    $sth->finish;
    print LOG "    Exon query done ".&date_and_mem()."\n";

    #get descriptions for the genes to use if none have been assigned to the transcript
    my $gene_desc = $conf->{'dbh'}->selectall_hashref(qq(
      SELECT t.transcript_id, g.description
        FROM transcript t, gene g
       WHERE t.gene_id = g.gene_id),
     'transcript_id');

    my $sql = qq(
      SELECT t.stable_id, sr.name as sr_name, t.seq_region_start, t.seq_region_end, t.seq_region_strand, cs.name as sr_type, cs.version,
            (SELECT sra.value
                FROM $dbname.seq_region_attrib sra, $dbname.attrib_type at
               WHERE sr.seq_region_id = sra.seq_region_id
                 AND sra.attrib_type_id = at.attrib_type_id
                 AND at.code = 'non_ref') as non_ref
        FROM $dbname.transcript t, $dbname.seq_region sr, $dbname.coord_system cs
       WHERE t.seq_region_id = sr.seq_region_id
         AND sr.coord_system_id = cs.coord_system_id);
    my $trans_locations = $conf->{'dbh'}->selectall_hashref($sql,'stable_id');
    $trans_locations->{'has_patches'} = $has_patches;
    $sql = qq(
      SELECT t.transcript_id, tr.translation_id, t.stable_id as tsid, t.version as tversion, tr.stable_id as trsid, tr.version as trversion,
             t.description, x.display_label, ad.display_label, ad.web_data, ad.displayable, t.status, t.biotype, a.logic_name
        FROM (( $dbname.analysis_description as ad,
             $dbname.analysis as a,
             $dbname.transcript as t) left join
             $dbname.translation as tr on t.transcript_id = tr.transcript_id) left join
             $dbname.xref as x on t.display_xref_id = x.xref_id
       WHERE t.analysis_id = a.analysis_id
         AND a.analysis_id = ad.analysis_id
         AND a.logic_name != 'LRG_import'
       ORDER by t.stable_id);
    $sth = $conf->{'dbh'}->prepare($sql);
    $sth->execute();


    my $old;
    my $c = 0;
    my ($tid,$tlid,$tsid,$tver,$tlsid,$tlver,$desc,$disp_xref,$ad_dl,$webdata,$displayable,$status,$biotype,$ln);
    while (my $r = $sth->fetchrow_arrayref()) {
      ($tid,$tlid,$tsid,$tver,$tlsid,$tlver,$desc,$disp_xref,$ad_dl,$webdata,$displayable,$status,$biotype,$ln) = @$r;
      $desc = $desc ? $desc : $gene_desc->{$tid}{'description'} ? $gene_desc->{$tid}{'description'} : '';
      my $wd = eval($webdata);
      next if $wd->{'gene'}{'do_not_display'};
      next if ($ln =~ /rnaseq/);
      next if ($ln =~ /ccds_import/); #exclude CCDS transcripts
      next if ($ln =~ /refseq_human_import/); #exclude RefSeq transcripts
      if( $old->{'tid'} != $tid ) {
        if( $old->{'tid'} ) {
          my $type = $old->{'biotype'}.' '.$old->{'ad_dl'};
	  (my $old_tsi) = keys %{$old->{'tsid'}};
          &p( GeneTransLine('Transcript',
                        $dbspecies,
                        $old->{'tsid'},
                        {},
                        $old->{'tlsids'},
                        $old->{'exons'},
                        $old->{'biotype'},
                        $old->{'ad_dl'},
                        $old->{'disp_xref'},
                        $old->{'desc'},
                        $old->{'xrefs'},
                        $old->{'synonyms'},
                        $old->{'supporting_evidence'},
                        $trans_locations->{$old_tsi},
                        $has_patches,
                        $db,
                        $counter),
              $fh);
          $c++;
        }

        $old = {
          'tid'       => $tid,
          'tsid'      => { $tsid => $tver },
          'tlsids'    => { $tlsid ? ( $tlsid=>$tlver ):()},
          'desc'      => $desc,
          'exons'     => {},
          'biotype'   => $biotype,
          'ad_dl'     => $ad_dl,
          'xrefs'     => [],
          'synonyms'  => $trans_syns{$tsid} || [],
          'disp_xref' => $disp_xref ? "$disp_xref" : "novel transcript",
          'status'    => $status,
          'biotype'   => $biotype,
          'ad_dl'     => $ad_dl,
        };

        $old->{'exons'}  = $exons{$tid};

        #add xref details
        foreach my $type (qw(Transcript Translation)) {
          my $id = ($type eq 'Transcript')  ? $tsid
                 : ($type eq 'Translation') ? $tlsid
                 : '';
          foreach my $xref (@{$xrefs{$type}{$id}}) {
            push @{$old->{'xrefs'}}, $xref;
          }
        }

        #add supporting_evidence
        if ($supporting_evidence->{$tsid}) {
          foreach my $db (keys %{$supporting_evidence->{$tsid}}) {
            foreach my $hit (keys %{$supporting_evidence->{$tsid}{$db}}) {
              $old->{'supporting_evidence'}{$hit} = "$hit ($db) is used as supporting evidence for transcript $tsid";
            }
          }
        }
      }
      else {
        $old->{'tlsids'}{$tlsid} = $tlver if $tlsid;
        push @{$old->{'synonyms'}}, @{$trans_syns{$tsid}||[]};
        #add xref details
        foreach my $type (qw(Transcript Translation)) {
          my $id = ($type eq 'Transcript')  ? $tsid
                 : ($type eq 'Translation') ? $tlsid
                 : '';
          foreach my $xref (@{$xrefs{$type}{$id}}) {
            push @{$old->{'xrefs'}}, $xref;
          }
        }
        #add supporting_evidence
        if ($supporting_evidence->{$tsid}) {
          foreach my $db (keys %{$supporting_evidence->{$tsid}}) {
            foreach my $hit (keys %{$supporting_evidence->{$tsid}{$db}}) {
              $old->{'supporting_evidence'}{$hit} = "$hit ($db) is used as supporting evidence for transcript $tsid";
            }
          }
        }
      }
    }
    if ($old->{'tsid'}) {
      (my $old_tsi) = keys %{$old->{'tsid'}};
      &p( GeneTransLine('Transcript',
                        $dbspecies,
                        $old->{'tsid'},
                        {},
                        $old->{'tlsids'},
                        $old->{'exons'},
                        $old->{'biotype'},
                        $old->{'ad_dl'},
                        $old->{'disp_xref'},
                        $old->{'desc'},
                        $old->{'xrefs'},
                        $old->{'synonyms'},
                        $old->{'supporting_evidence'},
                        $trans_locations->{$old_tsi},
                        $has_patches,
                        $db,
                        $counter),
          $fh) if ($old->{'tsid'});
      $c++;
    }
    print LOG "    Transcript info query done and xml generated, $c entries added ".&date_and_mem()."\n";

    my $other_count = &do_archive_stable_ids(  [ (qw(transcript translation)) ], $dbname, $db, $fh, $counter );
    print LOG "    Stable_id mapping querying done, added $other_count ".&date_and_mem()."\n";

    $total_c += footer( $counter->(), $fh);
  }
  return $total_c;
}

sub GeneTransLine {
  my ($type, $species, $id, $tsids, $tlsids, $exons, $biotype, $ad_label, $disp_xref, $desc, $xrefs, $synonyms, $supporting_evidence, $feat_loc, $has_patches, $db, $counter) = @_;

  #get stable ID of object
  my ($sid,$sid_ver);
  if (scalar(%$id) > 1) {
    print LOG "    WARNING: Multiple stable IDs for this object (".join ',',keys(%$id)."), check query\n";
  }
  else {
    ($sid,$sid_ver) = each %$id;
  }
  my $boost = 0;
  $boost += $boosts->{'GeneTrans'}{$db};
  my $ref_boost_value;
  if ($has_patches) {
    my $is_ref = $feat_loc->{'non_ref'} ? 'non_ref' : 'is_ref';
    $ref_boost_value = $boosts->{'GeneTrans'}{$is_ref};
    $boost += $ref_boost_value;
  }

  my $url = sprintf(qq(%s/%s/Summary?%s=%s&amp;db=%s),
                    $species,
                    $type,
                    ($type eq 'Gene') ?  'g' : 't',
                    $sid,
                    $db);
  my $loc;
  if ($feat_loc) {
    $loc = $feat_loc->{'sr_name'} .':'. $feat_loc->{'seq_region_start'} .'-'. $feat_loc->{'seq_region_end'} .':'. $feat_loc->{'seq_region_strand'};
  }

  my $quick_links;
  if ($type eq 'Transcript') {
    $quick_links = %{$tlsids} ? 'protein:1' : 'protein:0';
  }

  $species =~ s/_/ /;
  $biotype =~ s/_/ /;
  $desc = &clean($desc,'desc');
  $disp_xref = &clean($disp_xref,'name');
  my $description = $desc . " [Type: $biotype $ad_label]";
  my $doc = $boost ? qq(doc boost="$boost") : 'doc';
  my $xml = qq(
<$doc>
  <field name="id">$sid</field>
  <field name="id_ver">$sid.$sid_ver</field>
  <field name="name">$disp_xref</field>
  <field name="description">$desc</field>);
  if (my $db_boost_value = $boosts->{'GeneTrans'}{$db}) {
    $xml .= qq(
  <field name="db_boost">$db_boost_value</field>);
  }
  if (defined($ref_boost_value)) {
    $xml .= qq(
  <field name="ref_boost">$ref_boost_value</field>);
  }
  $xml .= &common_fields($species,$type,$db);
  if ($quick_links) {
   $xml .=qq(
  <field name="quick_links">$quick_links</field>);
  }
  my (%seen_labels,%seen_syns,%seen_sources,%labels);

  #treat supporting evidence as we do xrefs (if we decide to change it then need to update solr)
  if ($supporting_evidence) {
    foreach my $hit (keys %$supporting_evidence) {
      $hit = &clean($hit);
      $labels{$hit}++;
      my $se_desc = &clean($supporting_evidence->{$hit});
      $xml .= qq(
  <field name="_hr">$se_desc</field>);
    }
  }

 foreach my $xref (@$xrefs) {
    my $search_term = $xref->{'search_term'};
    my $xref_id     = $xref->{'id'};
    my $desc        = $xref->{'desc'};

    #remove any duplicates
    next if $seen_labels{$xref_id};
    $seen_labels{$xref_id}++;

    #remove any records where the hit is an Ensembl stable ID
    next if ($xref_id eq $sid) || ( grep {$_ eq $xref_id} keys(%$tsids), keys(%$tlsids));

    $search_term = &clean($search_term);
    $labels{$search_term}++;
    $desc        = &clean($desc);
    $xml .= qq(
  <field name="_hr">$desc</field>);
  }

  my $xrefs = join ' ', keys %labels;
    $xml .= qq(
  <field name="xrefs">$xrefs</field>);
  my %seen_syns;
  foreach my $syn (@$synonyms) {
    next if $seen_syns{$syn};
    $seen_syns{$syn} = 1;
    $xml .= qq(
  <field name="name_synonym">$syn"</field>);
  }
  if (my $t_count = keys %$tsids) {
    $xml .= qq(
  <field name="transcript_count">$t_count</field>);
    while (my ($tsi,$tsi_ver) = each %$tsids) {
      $xml .= qq(
  <field name="transcript">$tsi</field>
  <field name="transcript_ver">$tsi.$tsi_ver</field>);
    }
  }
  if (my $tl_count = keys %$tlsids) {
    $xml .= qq(
  <field name="translation_count">$tl_count</field>);
    while ( my ($tlsi, $tlsi_ver) = each %$tlsids) {
      $xml .= qq(
  <field name="peptide">$tlsi</field>
  <field name="peptide_ver">$tlsi.$tlsi_ver</field>);
    }
  }
  if (my $e_count = keys %$exons) {
    $xml .= qq(
  <field name="exon_count">$e_count</field>);
    foreach my $esi (keys %$exons) {
      $xml .= qq(
  <field name="exon">$esi</field>);
    }
  }

  #these are not to be searchable, but would be good to facete on database
  if ($loc) {
    $xml .= qq(
  <field name="location">$loc</field>);
  }
  $xml .= qq(
  <field name="source">$ad_label</field>
  <field name="domain_url">$url</field>);
  $xml .= qq(
</doc>);

  $counter->();
  return $xml;
}


## methods for archive stable IDs (called by genes and transcripts) ##

sub do_archive_stable_ids {
  my ($types,$dbname,$db,$fh,$counter) = @_;
  my $dbspecies = $conf->{'species'};
  my $COREDB    = $conf->{'dbs'}->{'DATABASE_CORE'};
  my %current_stable_ids =();
  foreach my $type (@$types) {
    $current_stable_ids{$type} = { map {@$_} @{$conf->{'dbh'}->selectall_arrayref( "select stable_id,1 from $COREDB.$type" )}};
  }
  my $types = join "','",@$types;
  my $species = $conf->{'species'};
  my $sth = $conf->{'dbh'}->prepare( qq(
    SELECT sie.type, sie.old_stable_id, if(isnull(sie.new_stable_id),'NULL',sie.new_stable_id),
           ms.old_release*1.0 as X, ms.new_release*1.0 as Y
      FROM $dbname.mapping_session as ms, $dbname.stable_id_event as sie
     WHERE ms.mapping_session_id = sie.mapping_session_id 
       AND sie.type in ('$types')
       AND ( old_stable_id != new_stable_id or isnull(new_stable_id) )
     ORDER by Y desc, X desc
  ));

  $sth->execute();
  my %mapping = ();
  while( my($type,$osi,$nsi,$old_release,$new_release) = $sth->fetchrow_array() ) {
    next if $current_stable_ids{$type}{$osi}; ## Don't want to show current stable IDs.
    next if $osi eq $nsi; ##
    #if the mapped ID is current set it as an example, as long as it's post release 62
    if ( ! $mapping{$type}{$osi}{'example'} && $new_release > 62) {
      if ($current_stable_ids{$type}{$nsi}) {
        $mapping{$type}{$osi}{'example'} = $nsi;
      }
    }
    $mapping{$type}{$osi}{'matches'}{$nsi}++;
  }
  my $other_count = 0;
  foreach my $type ( keys %mapping ) {
    foreach my $osi ( keys %{$mapping{$type}} ) {
      my @current_sis = ();
      my @deprecated_sis = ();
      foreach my $nsi ( keys %{$mapping{$type}{$osi}{'matches'}} ) {
        if( $current_stable_ids{$type}{$nsi} ) {
          push @current_sis,$nsi;
        } elsif( $_ ne 'NULL' ) {
          push @deprecated_sis,$nsi;
        }
      }
      if( @current_sis ) {
        $other_count++;
        my $example_id   = $mapping{$type}{$osi}{'example'};
        my $current_id_c = scalar(@current_sis );
        my $cur_txt = $current_id_c > 1 ? "$current_id_c current identifiers" : "$current_id_c current identifier";
        $cur_txt .= $example_id ? " (eg $example_id)" : '';
        my $desc = qq(Ensembl $type $osi is no longer in the database.);
        my $deprecated_id_c = scalar(@deprecated_sis);
        if ($deprecated_id_c) {
          my $dep_txt = $deprecated_id_c > 1 ? "$deprecated_id_c deprecated identifiers" : "$deprecated_id_c deprecated identifier";
          $desc .= " It has been mapped to $dep_txt";
          $desc .= $current_id_c ? " and $cur_txt." : '.'
        }
        elsif ($current_id_c) {
          $desc .= "It has been mapped to $cur_txt.";
        }
        &p (&StableIdMappingLine($dbspecies,$desc,$osi,$type,$db,$counter), $fh);
      }
      elsif( @deprecated_sis ) {
        $other_count++;
        my $deprecated_id_c = scalar(@deprecated_sis);
        my $id = $deprecated_id_c > 1 ? 'identifiers' : 'identifier';
        my $desc = qq(Ensembl $type $osi is no longer in the database but it has been mapped to $deprecated_id_c deprecated $id.);
        &p (&StableIdMappingLine($dbspecies,$desc,$osi,$type,$db,$counter), $fh);
      }
      else {
        $other_count++;
        my $desc = qq(Ensembl $type $osi is no longer in the database and has not been mapped to any newer identifiers.);
        &p (&StableIdMappingLine($dbspecies,$desc,$osi,$type,$db,$counter), $fh);
      }
    }
  }
  return $other_count;
}

sub StableIdMappingLine {
  my ($species,$desc,$osi,$type,$db,$counter) = @_; 
  my $url = sprintf(qq(%s/%s/Idhistory%s),
                    $species,
                    $type eq 'gene' ? ucfirst($type) : 'Transcript',
                    $type eq 'gene' ? "?g=$osi" : $type eq 'transcript' ? "?t=$osi" : "/Protein?t=$osi");
  $species =~ s/_/ /;
  my $xml = qq(
<doc>
  <field name="id">$osi</field>
  <field name="description">$desc</field>);
    $xml .= &common_fields($species,ucfirst($type),$db);
    $xml .= qq(
  <field name="domain_url">$url</field>
  <field name="quick_links">none</field>);
    $xml .= qq(
</doc>);
  $counter->();
  return $xml;
}

########################################################################## Regulatory Features

sub dumpRegulatoryFeature {
  my $conf = shift;
  my $dbname = $conf->{'dbs'}->{'DATABASE_FUNCGEN'};
  return unless $dbname;

  my $dbspecies = $conf->{'species'};
  my $db = 'regulatoryfeatures';
  my $counter   = make_counter(0);
  my $file = $conf->{'directory'}."/${dbname}_RegulatoryFeature.xml";
  my $start_time = time;
  my $fh;
  open( $fh, ">$file" ) or die "Can't open $file: $!";
  print LOG "  Dumping $dbname to $file ... ".&date_and_mem()."\n";
  header($fh);

  my $ftype = 'RegulatoryFeature';
  my $params;

  my $d = $conf->{'dbh'}->selectall_arrayref(
    "select rf.stable_id, sr.name, (rf.seq_region_start - rf.bound_start_length), (rf.seq_region_end + rf.bound_end_length), ft.name
       from $dbname.regulatory_feature rf, $dbname.seq_region sr, $dbname.coord_system cs,
            $dbname.feature_type ft, $dbname.feature_set fs
      where fs.name='RegulatoryFeatures:MultiCell' and fs.feature_set_id=rf.feature_set_id and
            rf.feature_type_id=ft.feature_type_id and rf.seq_region_id=sr.seq_region_id and
            sr.coord_system_id=cs.coord_system_id and cs.is_current=1
   group by rf.regulatory_feature_id"
  );

  foreach my $row ( @$d ) {
    my $desc = qq($row->[4] regulatory feature);
    my $id = $row->[0];
    my $ids = [ ];
    my $r = $row->[1] .":".$row->[2] . "-" . $row->[3];
    $params = { 'r' => $r, 'subtype' => 'RegulatoryFeature' };
    &p (RegulatoryFeatureLine($dbspecies,$desc,$id,$ids,$ftype,$params,$db,$counter), $fh);
  }

## External Features...
  my $e = $conf->{'dbh'}->selectall_arrayref(
 "select ef.display_label, group_concat(distinct ft.name), count(distinct ef.external_feature_id), ft.description, ft.class, fs.name
    from  $dbname.feature_type ft, $dbname.external_feature ef, $dbname.feature_set fs, $dbname.seq_region sr,
          $dbname.coord_system cs,$dbname.status s, $dbname.status_name sn
    where ft.feature_type_id=ef.feature_type_id
      and fs.feature_set_id=ef.feature_set_id
      and fs.type='external'
      and ef.seq_region_id=sr.seq_region_id
      and sr.coord_system_id=cs.coord_system_id
      and cs.is_current=1
      and s.table_name='feature_set'
      and s.table_id=fs.feature_set_id
      and s.status_name_id=sn.status_name_id
      and sn.name='MART_DISPLAYABLE'
 group by ef.display_label"
  );

  foreach my $f ( @$e) {
    my ($display_label, $f_name, $count, $f_desc, $f_class, $fs_name ) = @$f;
    next if ($f_name =~ /FANTOM/);
    my @syns;
    foreach my $id (split ',', $f_name) {
      push @syns unless $id eq 'display_label';
    }
    $params = { 'fs_name' => $fs_name, 'subtype' => 'RegulatoryFactor' };
    my $desc = "$display_label is a $f_class from $fs_name which hits the genome in $count locations";
    &p(RegulatoryFeatureLine($dbspecies,$desc,$display_label,\@syns,$ftype,$params,$db,$counter), $fh);
  }

## Tarbase features
  my $e = $conf->{'dbh'}->selectall_arrayref(
  "select mrf.display_label, group_concat(distinct ft.name), group_concat(distinct mrf.accession), count(distinct mrf.mirna_target_feature_id),
          ft.description, ft.class, fs.name
     from $dbname.feature_type ft, $dbname.mirna_target_feature mrf, $dbname.feature_set fs, $dbname.seq_region sr, $dbname.coord_system cs
    where ft.feature_type_id = mrf.feature_type_id
      and fs.feature_set_id = mrf.feature_set_id
      and mrf.seq_region_id = sr.seq_region_id
      and sr.coord_system_id = cs.coord_system_id
          and cs.is_current = 1
 group by mrf.display_label"
);
  foreach my $f ( @$e) {
    my ($display_label, $f_name, $accs, $count, $f_desc, $f_class, $fs_name) = @$f;
    my @syns;
    foreach my $id (split ',', $f_name) {
      push @syns unless $id eq 'display_label';
    }
    push @syns, split ',', $accs;
    $params = { 'fs_name' => $fs_name, 'subtype' => 'TarBase miRNA' };
    my $desc = "$display_label is a $f_class from $fs_name which hits the genome in $count locations";
    &p(RegulatoryFeatureLine($dbspecies,$desc,$display_label,\@syns,$ftype,$params,$db,$counter), $fh);
  }

  return footer( $counter->(), $fh);
}

sub RegulatoryFeatureLine {
  my ($species,$desc,$id,$ids,$ftype,$params,$db,$counter) = @_;
  my $url;
  if ($params->{'subtype'} eq 'RegulatoryFeature') {
    $url = sprintf(qq(%s/Regulation/Summary?rf=%s),
                   $species,
                   $id);
  }
  else {
    $url = sprintf(qq(%s/Location/Genome?ftype=RegulatoryFactor;id=%s;fset=%s),
                   $species,
                   $id,
                   $params->{'subtype'},
                 );
  }
  $species =~ s/_/ /;
  my $xml = qq(
<doc>
  <field name="id">$id</field>
  <field name="description">$desc</field>);
  foreach my $syn (@$ids) {
    $xml .= qq(
  <field name="synonym">$syn</field>);
  }

  #what's this for ?
  if (my $fs_name = $params->{'fs_name'}) {
    $xml .= qq(
  <field name="fs_name">$fs_name</field>);
  }
  $xml .= &common_fields($species,$ftype,'regulatoryfeatures');
  $xml .= qq(
  <field name="domain_url">$url</field>
</doc>);

  $counter->();
  return $xml;
}

########################################################################## LRGs

sub findLRGs {
  my $conf = shift;
  return $conf->{'dbh'}->selectall_arrayref(
        qq(SELECT g.stable_id, x.display_label, edb.db_name, t.stable_id, sr.length
             FROM gene g, analysis a, object_xref ox, xref x, external_db edb, transcript t, seq_region sr
            WHERE g.analysis_id = a.analysis_id
              AND g.gene_id = ox.ensembl_id
              AND ox.xref_id = x.xref_id
              AND x.external_db_id = edb.external_db_id
              AND g.gene_id = t.gene_id
              AND g.stable_id = sr.name
              AND ox.ensembl_object_type = 'Gene'
              AND edb.db_name = 'HGNC'
              AND a.logic_name = 'LRG_import'
            ORDER by g.stable_id, t.stable_id)
      );
}

sub sort_lrgs {
  my ($dbspecies,$type,$fh,$lrgs) = @_;
  my ($prev_gsi,$prev_disp_label,$prev_db_name,$prev_length);
  my $query_terms = [];
  foreach my $rec (@$lrgs) {
    my $gsi = $rec->[0];
    if ($gsi eq $prev_gsi) {
      push @$query_terms, $rec->[3];
    }
    else {
      if ($prev_gsi) {
        &p(LRGLine($dbspecies,$type,$prev_gsi,$prev_disp_label,$prev_db_name,$query_terms,$prev_length),
           $fh);
      }
      $prev_gsi        = $gsi;
      $prev_disp_label = $rec->[1];
      $prev_db_name    = $rec->[2];
      $query_terms     = [ $rec->[3] ];
      $prev_length     = $rec->[4];
    }
  }
}

sub LRGLine {
  my ($species,$type,$gsi,$dbkey,$dbname,$tsids,$length) = @_;
  my $url = sprintf(qq(%s/LRG/Summary?lrg=%s),
                    $species,
                    $gsi);
  $species =~ s/_/ /;
  my $description = "$gsi is a fixed reference sequence of length $length with a fixed transcript(s) for reporting purposes. It was created for $dbname gene $dbkey";
  my $xml = qq(
<doc>
  <field name="id">$gsi</field>
  <field name="description">$description</field>);
  $xml .= qq(
  <field name="xrefs">$dbkey</field>);
  foreach my $tsi (@$tsids) {
    $xml .= qq(
  <field name="transcript">$tsi</field>);
  }
  $xml .= &common_fields($species,$type,'core');
  $xml .= qq(
  <field name="domain_url">$url</field>
</doc>);
  return $xml
}

#######################################################################

#XML encode those non-standard characters in gene names and descriptions (order of regexps is important)
sub clean {
  my ($text,$field) = @_;
  $text =~ s/&/&amp;/g;
  $text =~ s/<i>//g;
  $text =~ s/<\/i>//g;
  $text =~ s/<sup>/-/g;
  $text =~ s/<\/sup>/-/g;
  $text =~ s/<em>//g;
  $text =~ s/<\/em>//g;
  $text =~ s/</&lt;/g;
  $text =~ s/>/&gt;/g;
  $text =~ s/'/&#44;/g;
  $text =~ s/"/&quot;/g;
  $text =~ s/ & / &amp; /g;
  $text =~ s/</&lt;/g;
  $text =~ s/>/&gt;/g;

  if ($text =~ /[<>]/) {
    print LOG "WARNING: Unsupported character $text in field $field\n";
  }
  return $text;
}

sub make_counter {
  my $start = shift;
  return sub { $start++ }
}

sub header {
  my ($fh) = @_;
  p(q(<add>), $fh, 1);
}

sub footer {
  my ($ecount, $fh, $type) = @_;
  p("</add>", $fh, 1);
  my $text = $type ? "  ...Dumped $ecount $type entries\n" : "  ...Dumped $ecount entries\n";
  print LOG $text;
  $fh->close();
  return $ecount;
}

sub common_fields {
  my ($species,$feature_type,$db) = @_;
  my $species_name = $species eq 'Multi' ? 'CrossSpecies' : $conf->{'species_common_name'};
  my $xml = qq(
  <field name="website">$website_url</field>
  <field name="feature_type">$feature_type</field>);
  if ($species) {
    $xml .= qq(
  <field name="species">$species_name</field>
  <field name="species_name">$species</field>);
  }
  if ($db) {
    $xml .= qq(
  <field name="database_type">$db</field>);
  }
  return $xml;
}

sub p {
  my ($str, $fh, $no_parse) = @_;
  return unless $str;
  unless ($no_parse) {
    eval { $parser->parse($str); };
    if ($@) {
      print LOG "\n\nWARNING XML - Error in XML, please fix and rerun:\nError is $@\n";
      exit;
    }
  }
  $str .= "\n";
  print $fh $str or die "Can't write string: $str";
}

sub format_datetime {
  my $t = shift;
  my ( $y, $m, $d, $ss, $mm, $hh ) = ( localtime($t) )[ 5, 4, 3, 0, 1, 2 ];
  $y += 1900;
  $d = "0" . $d if ( $d < 10 );
  my $ms = text_month($m);
  return sprintf "$d-$ms-$y %02d:%02d:%02d", $hh, $mm, $ss;
}

sub text_month {
  my $m = shift;
  my @months = qw[JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC];
  return $months[$m];
}

sub date_and_mem {
  my $date = strftime "%Y-%m-%d %T", localtime;
  my $mem = `ps -p $$ -o vsz |tail -1`;
  chomp $mem;
  return "[$date, mem $mem]";
}

sub elapsed_time {
  my $start_time = shift;
  my $diff = time - $start_time;
  my $sec = $diff % 60;
  $diff = ($diff - $sec) / 60;
  my $min = $diff % 60;
  my $hours = ($diff - $min) / 60;
  return "${hours}h ${min}min ${sec}sec";
}

sub about {
  print STDERR <<ABOUT_END;

usage:
./indexXMLDumper --species=aaa,bbb|ALL --index=vvv,xxx|ALL (--ignore_species=ccc,ddd) (--ignore_index=yyy,zzz) (--debug) (--log=index.log) (--dir=dir)

'ALL' can be used for both 'species' and 'index'

The script will retry five times if it encounters MySQL errors (for example loses database connections)
unless --debug is specified in which case it will exit on the first failure.

In the abscence of --debug option, STDOUT and STDERR are sent to a log file (dumping_$release.log unless specified otherwise). If you run with --debug then output is sent to STDOUT

The locations of the actual xml files can be specified with the dir option. If not specified then it is dumped to 'input'.

Examine the log file for 'WARNING' messages, particularly 'WARNING XML' - this will identify any entries identified by XML::Parser as not being well formed and which would crash index production. These are not added to the xml file but the record count in the footer *will* include them. Either manaully fix and add the entry(ies) to the xml file, or else fix the database / script to account for it and rerun.

--dry_run|n does everything apart from actually write the xml [note that this option will delete any preexisting file]

Examples:

./indexXMLDumper --species=ALL --index=ALL --debug --log=debug.log  #all log output to debug.log; xml to input; all indices for all species, only each one once
./indexXMLDumper --species=ALL --index=ALL                          #all log output to dumping_$release.log; xml to input; all indices for all species
./indexXMLDumper --species=ALL --ignore_species=Homo_sapiens --index=Variation --log=no_hs_variations.log #log output to no_hs_variations; xml to /nfs/web_data/search/lucene/ensembl_$release; Variations for all species but human
./indexXMLDumper --species=ALL --ignore_index=Variation --log=no_variations.log  #log output to no_variations.log; xml to  /nfs/web_data/search/lucene/ensembl_$release; All indexes apart from Variations for for all species
./indexXMLDumper --species=ALL --index=Gene --engine solr  -log dumping.log #output in format for solr (for testing, only works for genes as yet)

ABOUT_END
}
