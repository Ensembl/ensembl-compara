#!/usr/local/bin/perl

use strict;

my $ENSEMBL_ROOT;

BEGIN {
  use FindBin qw($Bin);
  use File::Basename qw( dirname );
  $ENSEMBL_ROOT = dirname( $Bin );
  $ENSEMBL_ROOT =~ s/\/utils$//;
  unshift @INC, "$ENSEMBL_ROOT/conf";
  eval{ require SiteDefs };
  if ($@){ die "Can't use SiteDefs.pm - $@\n"; }
  map{ unshift @INC, $_ } @SiteDefs::ENSEMBL_LIB_DIRS;
}

use EnsEMBL::Web::SpeciesDefs;
use Data::Dumper;
package indexDumper;

use constant INC_SPECIES => 0;
use CGI;

our $SD = EnsEMBL::Web::SpeciesDefs->new();

my ( $SPECIES_STRING, @indexes) = @ARGV;

## HACK 1 - if the INDEX is set to all grab all dumper methods...
@indexes = map { /dump(\w+)/?$1:() } keys %indexDumper:: if $indexes[0] eq 'ALL';

## HACK 2 - if the SPECIES is set to ALL grab stuff from config...

my @species;
my %X = %{$SD->ENSEMBL_SPECIES_ALIASES};

if( $SPECIES_STRING eq 'ALL' ) {
  @species = @{$SD->ENSEMBL_DATASETS}
} else {
  @species = grep {$_} map { $X{lc($_)} } split /:/, $SPECIES_STRING;
}

# EnsEMBL::Web::IndexSupport takes path to conf, path to files, species
my $conf = {};
mkdir 'input', 0777 unless -e 'input';

foreach my $species ( @species ) {
  $conf->{'directory'} = "input/$species";
  mkdir $conf->{'directory'}, 0777 unless -e  $conf->{'directory'};
  $conf->{'species'}   = $species;
  $conf->{'authority'} = $SD->get_config($species,'AUTHORITY');
  my %dbs = %{$SD->get_config($species,'databases')||{}};
  $conf->{'dbs'}       = { map { ($_,$dbs{$_}{NAME}) } keys %dbs };
  $conf->{'dbs'}{'DATABASE_COMPARA'} = 'ensembl_compara_'.$SD->ENSEMBL_VERSION;
  my $core = $dbs{'DATABASE_CORE'};
  $conf->{'dbh_compara'} = DBI->connect( "dbi:mysql:ensembl_compara_".$SD->ENSEMBL_VERSION.";host=ensdb-1-13;port=5307", $core->{'USER'}, $core->{'PASS'} );
  $conf->{'dbh'}         = DBI->connect( "dbi:mysql:$core->{'NAME'};host=$core->{'HOST'};port=$core->{'PORT'}", $core->{'USER'}, $core->{'PASS'} );
  warn join ' ', $species, Data::Dumper::Dumper $conf;
  foreach my $index (@indexes) {
    warn "  Index: $species $index";
    my $function = "dump$index";
    no strict "refs";
    &$function( $conf );
  }
}

## Now for all the dump functions...............................

########################################################################## QTLs

sub dumpQTL {
  my $conf = shift;
  my $sth = $conf->{'dbh'}->prepare("
 select c.name as chr, qf.seq_region_start, qf.seq_region_end,
        a.logic_name as analysis, q.qtl_id,
        q.trait, qs.source_database, qs.source_primary_id,
        fms1.source as fm1_source, fms1.name as fm1_name,
        fms2.source as fm2_source, fms2.name as fm2_name,
        pms.source  as pm_source,  pms.name  as pm_name
   from ((((((seq_region as c, qtl_feature as qf, qtl_synonym as qs,
        analysis as a, qtl as q) left join marker as fm1 on
        fm1.marker_id = q.flank_marker_id_1) left join marker_synonym as fms1 on
        fm1.display_marker_synonym_id = fms1.marker_synonym_id) left join marker as fm2 on
        fm2.marker_id = q.flank_marker_id_2) left join marker_synonym as fms2 on
        fm2.display_marker_synonym_id = fms2.marker_synonym_id) left join marker as pm on
        pm.marker_id = q.peak_marker_id) left join marker_synonym as pms on
        pm.display_marker_synonym_id = pms.marker_synonym_id 
  where c.seq_region_id = qf.seq_region_id and qs.qtl_id = q.qtl_id and 
        qf.analysis_id = a.analysis_id and qf.qtl_id = q.qtl_id
  ");
  $sth->execute();
  open O, ">$conf->{'directory'}/QTL.txt";
  my $desc       = '';
  my $old_qtl = 0;
  my $old_ID  = '';
  my $old_pos = '';
  my $IDS;
  while( my $T = $sth->fetchrow_hashref() ){
    if($T->{qtl_id} eq $old_qtl) {
      $IDS  .= " $T->{source_primary_id}";
      $desc .= " $T->{source_database}:$T->{source_primary_id}";
    } else {
      print O &QTLLine( $conf->{'species'}, $old_ID, $old_pos, $IDS,$desc );
      $IDS = "$T->{trait} $T->{source_primary_id}";
      $IDS.= " $T->{fm1_name}" if $T->{fm1_name};
      $IDS.= " $T->{fm2_name}" if $T->{fm2_name};
      $IDS.= " $T->{pm_name}" if $T->{pm_name};
      $old_ID = $T->{pm_name};
      $old_pos = "$T->{chr}:".($T->{seq_region_start}-1e4).'-'.($T->{seq_region_end}+1e4);
      $desc       = "QTL exhibiting '$T->{trait}' has ";
      my $f2 = $T->{pm_name} ? 1 : 0;
      if( $T->{fm1_name} || $T->{fm2_name} ) {
        my $f1= ($T->{fm1_name}) && ($T->{fm2_name}) ? 1 : 0;
        $desc.='flanking marker'.($f1?'s ':' ').$T->{fm1_name}.($f1?' and ':'').$T->{fm2_name}.($f2?'; ':'');
      }
      if($f2) {
        $desc.= "peak marker $T->{pm_name};";
      }
      $desc.=" and names: $T->{source_database}:$T->{source_primary_id}";
      $old_qtl = $T->{qtl_id};
    }
  }
  print O &QTLLine( $conf->{'species'}, $old_ID,$old_pos, $IDS,$desc );
  close O;
}

sub QTLLine {
  my ($species, $trait, $pos, $IDS, $desc ) = @_;
  return if $trait eq '';
  return join "\t", (INC_SPECIES?"$conf->{'species'}\t":"").qq(QTL),
    $trait, "/$conf->{'species'}/Location/View?r=$pos", $IDS, "$desc\n";
}

########################################################################## SNPs

sub dumpSNP {
  my $conf = shift;
  my $SNPDB = $conf->{'dbs'}->{'DATABASE_VARIATION'};
  return unless $SNPDB;

  `/usr/bin/mysql -h ensdb-1-13 -P5307 -uensro $SNPDB -e 'select variation_id,source_id,name from variation order by variation_id' > v.txt`;
  `/usr/bin/mysql -h ensdb-1-13 -P5307 -uensro $SNPDB -e 'select variation_id,source_id,name from variation_synonym order by variation_id' > vs.txt`;

  return unless $SNPDB;


  my %SNP_EXTRA = map { ($_->[0] => $_) }
    @{$conf->{'dbh'}->selectall_arrayref( 
      "select va.variation_id,
              group_concat( distinct va.local_stable_id SEPARATOR '; ') as lsi,
              group_concat( distinct va.study           SEPARATOR '; ') as st,
              group_concat( distinct va.associated_gene SEPARATOR '; ') as gn,
              group_concat( distinct va.variation_names SEPARATOR '; ') as vars,
              group_concat( distinct 
                if(
                  isnull(p.name),
                  description,
                  concat( p.description,' (',p.name,')' )
                )
                SEPARATOR '; '
              ) as phen
         from $SNPDB.variation_annotation as va left join
              $SNPDB.phenotype as p on p.phenotype_id = va.phenotype_id
        group by va.variation_id
        order by va.variation_id"
   )};

  my $SOURCES = { map { @$_ } @{$conf->{'dbh'}->selectall_arrayref( "select source_id, name from $SNPDB.source" )} };

  open( my $fh1, 'v.txt' );
  open( my $fh2, 'vs.txt' );
  open( my $fh3, '>snps.txt' );
  my $shift = <$fh1>; # remove first line
  $shift = <$fh2>;
  my $F=1;
  my $snp1 = n($fh1,$SOURCES);
  my $snp2 = n($fh2,$SOURCES) || [0,0,''];
  while( $snp1 && $snp2 ) {
#   warn "$snp1->[0]-$snp2->[0]";
    if( $snp2->[0] ) {
      if( $snp1->[0] ) {
        if($snp2->[0]<$snp1->[0]) {
          warn "ARGH!! snp2_ID < snp1_ID panic!! @{$snp2}";
          $snp2 = n($fh2,$SOURCES)||[0,0,'']; # get next synonym
        } elsif($snp2->[0]>$snp1->[0]) {
          print $fh3 "@$snp1\n";
          $snp1 = n($fh1,$SOURCES); # get next snp...
        } else {
          push @{$snp1}, "$snp2->[1]:$snp2->[2]";
          $snp2 = n($fh2,$SOURCES)||[0,0,'']; # get next snp2
        }
      } else {
        warn "ARGH!!!! run out of snps";
      }
    } elsif( $snp1->[0] ) {
      print $fh3 "@$snp1\n";
      $snp1 = n($fh1,$SOURCES);
    } else {
      $F = 0;
    }
  }
  if($snp1) {
    print $fh3 "@$snp1\n";
  }

  unlink 'v.txt';
  unlink 'vs.txt';
  close $fh1;
  close $fh2;
  close $fh3;
  open I, 'snps.txt' ;
  open O, ">$conf->{'directory'}/SNP.txt";
  while(<I>) {
    my($ID,$source,$name,@keywords) = split;
    my @K = map { (my $t=$_)=~ s/^\w+://;$t } @keywords;
    my $size = @keywords;
    my $extra = '';
    my $x = $SNP_EXTRA{$ID};
    if( $x ) {
      push @K, $x->[1], $x->[3],$x->[4];
      $extra = '; and is associated with following phenotypes:'. $x->[4];
      if( $x->[1] ) {
        $extra .= sprintf ', through %s', $x->[1];
      }
      if( $x->[2] ) {
        $extra .= sprintf ', through study(s): %s, and associated with following gene(s): %s', $x->[2], $x->[3];
      }
    } 
    print O join "\t",
      "$source SNP",
      $name,
      "/$conf->{'species'}/Variation/Summary?source=$source;v=$name",
      "$name @K",
      sprintf( "A %s SNP with %s%s\n",
        $source, 
          $size > 1 ? " with $size synonyms: @keywords" 
        : $size     ? " with one synonym: @keywords"
        :             " with no synonyms",
        $extra
      );
  }
  close O;
  close I;
  unlink 'snps.txt';
}

sub n {
  my( $fh, $sources ) = @_;
  my $L = <$fh>;
  my $snp;
  if( $L ) {
    chomp $L;
    my @L = split /\t/, $L;
    $snp = [ $L[0], $sources->{$L[1]}, $L[2]];
  }
  return $snp;
}

sub snpLine {
  my ($species, $source, $snpid, $IDS, $desc ) =@_;
  return if $snpid eq '';
  $desc =~ s/^, //;
  return join "\t",
    (INC_SPECIES?"$species\t":"").qq(Ensembl SNP),
    $snpid,
    "/$species/snpview?snp=$snpid;source=$source",
    "$IDS",
    "SNP $snpid. Alternative IDs: $desc.\n";
}

########################################################################## Markers

sub dumpMarker {
  my $conf = shift;
  my $sth = $conf->{'dbh'}->prepare("
   select m.marker_id, ms2.name, ms1.name, sr.name, mf.seq_region_start, mf.seq_region_end
     from (marker_synonym as ms1, marker as m, marker_feature mf, seq_region sr) left join
          marker_synonym as ms2 on ms2.marker_synonym_id = m.display_marker_synonym_id
    where ms1.marker_id = m.marker_id
      and m.marker_id = mf.marker_id
      and mf.seq_region_id = sr.seq_region_id
    order by m.marker_id
  ");

  $sth->execute( );

  open O, ">$conf->{'directory'}/Marker.txt";
  my $counter    = 0;
  my $desc       = '';
  my $old_ID = 0;
  my ($ID,$marker,$synonym,$r_name,$r_start,$r_end,$r);
  while( ($ID,$marker,$synonym,$r_name,$r_start,$r_end) = $sth->fetchrow_array()){
    $marker = $synonym unless $marker;
    if($ID == $old_ID) {
      $desc .= " $synonym";
      $counter++;
    } else {
      print O &markerLine( $conf->{'species'},$desc,$counter,$r);
      $r       = "$r_name:$r_start-$r_end";
      $desc    = "$synonym";
      $old_ID  = $ID;
      $counter = 1;
    }
  }
  print O &markerLine( $conf->{'species'},$desc,$counter,$r);
  close O;
}

sub markerLine {
  my( $species, $IDS, $counter, $r ) = @_;
  return if $counter == 0;
  my @synonyms = sort split /\s+/, $IDS;
  my $key = pop @synonyms;
  return join "\t",
    (INC_SPECIES?"$species\t":"").qq(Ensembl Marker),    ## Type
    qq($key),               ## ID
    qq(/$species/Location/Marker?m=$key;r=$r),
    qq($IDS),     ## Index locations,
    qq(A marker with $counter synonyms ($IDS)\n);
}

########################################################################## Similarity features

sub dumpGenomicAlignment {
  my  $conf = shift;
  open D, ">$conf->{'directory'}/GenomicAlignment.txt";

  my $species = $conf->{'species'};
  my $COREDB = $conf->{'dbs'}->{'DATABASE_CORE'};
  my $ESTDB  = $conf->{'dbs'}->{'DATABASE_OTHERFEATURES'};
  my $CDNADB = $conf->{'dbs'}->{'DATABASE_CDNA'};
  my %dbs    = ( 'core' => $COREDB );
  $dbs{'otherfeatures'}  =  $ESTDB  if $ESTDB;
  $dbs{'cdna'} = $CDNADB if $CDNADB;
  my %tables = (
    'dna_align_feature'     => [ 'DnaAlignFeature',     'DNA alignment feature' ],
    'protein_align_feature' => [ 'ProteinAlignFeature', 'Protein alignment feature' ]
  );
  my %errors = ();
  my $core_features;
  foreach my $db ( sort { $b cmp $a } keys %dbs) {
    my $DB_NAME = $dbs{$db};
    foreach my $table ( keys %tables ) {
      my $source = $tables{ $table }[0];
      $source .= ";db=$db" unless $db eq 'core';
      my $type   = $tables{ $table }[1];
      my $sth    = $conf->{'dbh'}->prepare(
	"select a.logic_name, ad.display_label, t.hit_name, sr.name, t.seq_region_start, t.seq_region_end, count(*) as hits
                from ($DB_NAME.analysis as a, $DB_NAME.$table as t, seq_region as sr) left join
                     $DB_NAME.analysis_description as ad on ad.analysis_id = a.analysis_id
               where a.analysis_id = t.analysis_id
                 and t.seq_region_id = sr.seq_region_id
               group by a.logic_name, t.hit_name");
      $sth->execute();
      my $c = 0;
      while( my( $logic_name, $label, $hid, $sr_name, $sr_start, $sr_end, $count  ) = $sth->fetchrow_array ) {
	$c++;
	print D join "\t",
	  (INC_SPECIES?"$species\t":"")."$type: ".($label||$logic_name),
	    $hid,
	      "/$species/Location/Genome?ftype=$source;id=$hid",
		$hid,
		  qq($logic_name $hid hits the genome in $count locations.\n);
      }
#      warn "Dumped $c genomic alignments from $DB_NAME $table";
    }
    if (0) {#$db eq 'cdna') { #don't do these for now
      my $sth    = $conf->{'dbh'}->prepare(
	"select uo.identifier, a.logic_name, ur.summary_description, 'Unmapped feature'
                from $DB_NAME.analysis a, $DB_NAME.unmapped_object uo, $DB_NAME.unmapped_reason ur 
               where a.analysis_id = uo.analysis_id
                 and uo.unmapped_reason_id = ur.unmapped_reason_id");
      $sth->execute();
      while (my ($name, $ln, $desc, $type) = $sth->fetchrow_array ) {
	$ln =~ s/_/ /;
	print D join "\t",
	  (INC_SPECIES?"$species\t":"")."$type: ",
	    "$ln $name",
	      "/$species/Location/Genome?ftype=UnmappedObject;id=$name;db=$db",
		$name,
		  "Reason: $desc\n";
      }
    }
  }
  close D;
}

sub dumpOligoProbe {
  my $conf = shift;
  open A, ">$conf->{'directory'}/OligoProbe.txt";
  my $species = $conf->{'species'};
  my $FUNCDB = $conf->{'dbs'}->{'DATABASE_FUNCGEN'};
  if ($FUNCDB) {
    my $sth    = $conf->{'dbh'}->prepare(
      "select ps.name, count(distinct pf.probe_feature_id) as hits, a.vendor
        from $FUNCDB.probe_set ps, $FUNCDB.probe p, $FUNCDB.probe_feature pf, $FUNCDB.array_chip ac, $FUNCDB.array a, $FUNCDB.status s, $FUNCDB.status_name sn
      where sn.name='MART_DISPLAYABLE'
        and sn.status_name_id=s.status_name_id
        and s.table_name='array'
        and s.table_id=a.array_id
        and ps.probe_set_id = p.probe_set_id
        and p.probe_id = pf.probe_id
        and p.array_chip_id = ac.array_chip_id
        and ac.array_id = a.array_id
      group by ps.name, a.vendor"
    );
    $sth->execute();
    while( my( $hid, $count, $type ) = $sth->fetchrow_array ) {
      next unless $hid;
      print A join "\t", (INC_SPECIES?"$species\t":"")."$type Oligo Probe set",
	$hid, "/$species/Location/Genome?ftype=ProbeFeature;fdb=funcgen;ptype=pset;id=$hid;",
	  $hid, qq($type oligo probeset $hid hits the genome in $count locations.\n);
    }

    my $sth    = $conf->{'dbh'}->prepare(
      "select group_concat(distinct p.name), count(distinct pf.probe_feature_id) as hits, a.vendor
        from $FUNCDB.probe p, $FUNCDB.probe_feature pf, $FUNCDB.array_chip ac, $FUNCDB.array a, $FUNCDB.status s, $FUNCDB.status_name sn
      where sn.name='MART_DISPLAYABLE'
        and sn.status_name_id=s.status_name_id
        and s.table_name='array'
        and s.table_id=a.array_id
        and p.probe_set_id is NULL
        and p.probe_id = pf.probe_id
        and p.array_chip_id = ac.array_chip_id
        and ac.array_id = a.array_id
      group by p.probe_id, a.vendor"
    );
    $sth->execute();
    while( my( $hid, $count, $type ) = $sth->fetchrow_array ) {
      next unless $hid;
      print A join "\t", (INC_SPECIES?"$species\t":"")."$type Oligo Probe set",
  $hid, "/$species/Location/Genome?ftype=ProbeFeature;fdb=funcgen;ptype=probet;id=$hid;",
    $hid, qq($type oligo probeset $hid hits the genome in $count locations.\n);
    }
  }
  close A;
}


########################################################################## Diseases

sub dumpDisease {
  my $conf = shift;
  my $DISDB   = $conf->{'dbs'}->{'ENSEMBL_DISEASE'};    
  return unless $DISDB;
  my $COREDB   = $conf->{'dbs'}->{'DATABASE_CORE'};    
  my $sth = $conf->{'dbh'}->prepare(
    "select distinct concat( g.gene_symbol,':',g.omim_id, ' (',gsi.stable_id,')') as name,
            d.disease, d.disease
       from $DISDB.disease as d,
            $DISDB.gene as g,
            $COREDB.xref as cx, 
            $COREDB.object_xref as cox, 
            $COREDB.translation as tr,
            $COREDB.transcript as t,
            $COREDB.gene_stable_id as gsi 
      where d.id = g.id and cx.display_label = g.omim_id and cx.external_db_id = 1500 and
            cox.xref_id = cx.xref_id and cox.ensembl_id = tr.translation_id and
            tr.transcript_id = t.transcript_id and gsi.gene_id = t.gene_id
      order by disease, g.omim_id, g.gene_symbol"
  );
  $sth->execute();
  open O, ">$conf->{'directory'}/Disease.txt";
  my $old_omim = '';
  my $IDS  = '';
  my $description = '';
  my $old_desc = '';
  my ($gene, $omim, $desc );
  while( ($gene, $omim, $desc ) = $sth->fetchrow_array()){
    if($omim eq $old_omim) {
      $IDS .= " $gene";
      $description .=", $gene";
    } else {
      print O &diseaseLine($conf->{'species'}, $old_omim, $IDS, $description );
      $description = "$desc Genes: $gene";
      $IDS  = "$gene $desc";
      $old_omim = $omim;
    }
  }
  print O &diseaseLine($conf->{'species'}, $old_omim, $IDS, $description );
  close O;
}

use CGI qw(escape escapeHTML);
sub diseaseLine {
  my($species, $did, $IDS, $description) = @_;
  return if $description eq '';
  return join "\t",
    (INC_SPECIES?"$species\t":"").qq(OMIM disease),    ## Type
    escapeHTML($did),               ## ID
    qq(/$species/featureview?type=Disease;id=).escape($did),
    qq($did $IDS),     ## Index locations,
    qq(OMIM - $description\n);
}

########################################################################## Domains

sub dumpDomain {
  my $conf = shift;
  my $COREDB = $conf->{'dbs'}->{'DATABASE_CORE'};
  my $t_sth = $conf->{'dbh'}->prepare(
      "select i.interpro_ac, tsi.stable_id
       from $COREDB.interpro i, $COREDB.protein_feature pf, $COREDB.translation tl, $COREDB.transcript_stable_id tsi
       where i.id = pf.hit_name
       and pf.translation_id = tl.translation_id
       and tl.transcript_id = tsi.transcript_id
       group by i.interpro_ac");
  $t_sth->execute;
  my %t_examples;
  while( my ($id, $example ) = $t_sth->fetchrow_array()){
      $t_examples{$id} = $example;
  }
  my $sth = $conf->{'dbh'}->prepare(
    "select x.dbprimary_acc, i.id, x.description
       from $COREDB.xref as x, $COREDB.interpro as i
      where x.dbprimary_acc = i.interpro_ac
      order by x.dbprimary_acc");
  $sth->execute();
  open O, ">$conf->{'directory'}/Domain.txt";
  my $old_acc     = '';
  my $IDS         = '';
  my $description = '';
  my $counter     = 0;
  my ($acc, $id, $desc, $old_desc, $example  );
  while( ($acc, $id, $desc ) = $sth->fetchrow_array()){
    if($acc eq $old_acc) {
      $IDS         .= " $id";
      $description .= ", $id";
      $counter++;
    }
    else {
      $example = $t_examples{$old_acc};
      print O &domainLine($conf->{'species'}, $old_acc, $IDS, $old_desc, $counter, $description, $example );
      $description = $id;
      $IDS         = $id;
      $old_acc     = $acc;
      $old_desc    = $desc;
      $counter     = 1;
    }
  }
  print O &domainLine( $conf->{'species'}, $old_acc, $IDS, $old_desc, $counter, $description, $example );
  close O;
}

sub domainLine {
  my($species, $did, $IDS, $desc, $counter, $description, $example) = @_;
  return if $did eq '';
  return unless $example;
  return join "\t",
    (INC_SPECIES?"$species\t":"").qq(Interpro domain),    ## Type
    qq($did),               ## ID
    qq(/$species/Transcript/Domains/Genes?domain=$did;t=$example), ## URL
    qq($did $IDS $desc),     ## Index locations
    qq(InterPro domain $did [$desc] has $counter associated external database identifiers: $description.\n);   ## Description text

}
########################################################################## Families

sub dumpFamily {
  my $conf = shift;
  my $FAMDB = $conf->{'dbs'}->{'DATABASE_COMPARA'};
  my $CORE  = $conf->{'dbs'}->{'DATABASE_CORE'};
  my $t_sth = $conf->{'dbh'}->prepare(
    "select meta_value from $CORE.meta where meta_key='species.taxonomy_id'"
  );
  $t_sth->execute;
  my $taxon_id = ($t_sth->fetchrow);
  return unless $taxon_id;

 ( my $species = $conf->{'species'} ) =~ s/_/ /g;

  my $sth = $conf->{'dbh_compara'}->prepare( "
select f.stable_id,
       f.description,
       count(*) as N,
       sum( (source_name = 'ENSEMBLGENE') and (m.genome_db_id = gd.genome_db_id) ) as ensembl_genes_species,
       sum( (source_name = 'ENSEMBLPEP' ) and (m.genome_db_id = gd.genome_db_id) ) as ensembl_peptides_species,
       sum(  source_name = 'ENSEMBLGENE'                                         ) as ensembl_genes,
       sum(  source_name = 'ENSEMBLPEP'                                          ) as ensembl_peptides,
       sum( (source_name = 'Uniprot/SPTREMBL' ) and (m.taxon_id = gd.taxon_id)   ) as uniprot_sptrembl_species,
       sum( (source_name = 'Uniprot/SWISSPROT') and (m.taxon_id = gd.taxon_id)   ) as uniprot_swissprot_species,
       sum(  source_name = 'Uniprot/SPTREMBL'                                    ) as uniprot_sptrembl,
       sum(  source_name = 'Uniprot/SWISSPROT'                                   ) as uniprot_swissprot
  from family as f, family_member as fm, member as m, genome_db as gd
 where f.family_id=fm.family_id and fm.member_id=m.member_id and
       gd.name = '$species'
 group by f.family_id 
having ensembl_genes_species > 0"
  );
  $sth->execute();
  open O, ">$conf->{'directory'}/Family.txt";
  my $X = $conf->{'authority'} || 'Ensembl';
  while( my(
    $fid, $desc, $total, 
    $ensembl_genes_species, $ensembl_peptides_species, $ensembl_genes, $ensembl_peptides,
    $uniprot_sptrembl_species, $uniprot_swissprot_species,
    $uniprot_sptrembl, $uniprot_swissprot
  ) = $sth->fetchrow_array()) {
    print O join "\t",
(INC_SPECIES?"$species\t":"").qq(Ensembl protein family),    ## Type
        qq($fid),               ## ID
        qq(/$conf->{'species'}/Gene/Family/Genes?family=$fid), ## URL,
        qq($fid $desc), ## keywords...
        qq(Ensembl protein family $fid [$desc] has $total members: $ensembl_genes $X genes ($ensembl_genes_species in $species); $ensembl_peptides $X proteins ($ensembl_peptides_species in $species); $uniprot_swissprot UniProtKB/Swiss-Prot proteins ($uniprot_swissprot_species in $species); $uniprot_sptrembl UniProtUK/TrEMBL proteins ($uniprot_sptrembl_species in $species).\n); ## Description text
  }
  close O;
}

sub familyLine {
    my($species, $fid, $IDS, $desc, $counter, $description) = @_;
    return if $fid eq '';
    return join "\t",
        (INC_SPECIES?"$species\t":"").qq(Ensembl protein family),    ## Type
        qq($fid),               ## ID
        qq(/$species/familyview?family=$fid), ## URL
        qq($fid $IDS $desc),     ## Index locations
        qq(Ensembl protein family $fid [$desc] has $counter members: $description.\n);   ## Description text
}
 
########################################################################## Genes

sub dumpGene {
  use Data::Dumper;
  my $conf = shift;
  my $COREDB = $conf->{'dbs'}->{'DATABASE_CORE'};
  my $SANGDB = $conf->{'dbs'}->{'DATABASE_VEGA'};
  my $ESTGENEDB = $conf->{'dbs'}->{'DATABASE_OTHERFEATURES'};
  my %DBS = ( 'core' => $COREDB );
  $DBS{'vega'}          = $SANGDB    if $SANGDB;
  $DBS{'otherfeatures'} = $ESTGENEDB if $ESTGENEDB;
  open O, ">$conf->{'directory'}/Gene.txt";
  my $core_xrefs;
 DB:
  foreach my $DB ( sort keys %DBS ) {
    my $gene_count = 0;
    warn "STARTING... $DB";
    my $DBNAME = $DBS{$DB};
    my $extra = $DB ne 'core' ? ";db=$DB" : '';
    my %xrefs = ();
    my %xrefs_desc = ();
    foreach my $type( qw(Gene Transcript Translation) ) {
      my $T = $conf->{'dbh'}->selectall_arrayref(
        "select ox.ensembl_id,
                x.display_label, x.dbprimary_acc, ed.db_display_name, es.synonym, x.description
           from ($DBNAME.object_xref as ox, $DBNAME.xref as x, $DBNAME.external_db as ed) left join $DBNAME.external_synonym as es on es.xref_id = x.xref_id
          where ox.ensembl_object_type = '$type' and ox.xref_id = x.xref_id and x.external_db_id = ed.external_db_id"
      );
      foreach ( @$T ) {
        $xrefs{$type}{$_->[0]}{$_->[3]}{$_->[1]} =1 if $_->[1];
        $xrefs{$type}{$_->[0]}{$_->[3]}{$_->[2]} =1 if $_->[2];
        $xrefs{$type}{$_->[0]}{$_->[3]}{$_->[4]} =1 if $_->[4];
        $xrefs_desc{$type}{$_->[0]}{$_->[5]}      =1 if $_->[5];
      }
      warn "XREF $type query done";
    }
    my %exons = ();
    my $T = $conf->{'dbh'}->selectall_arrayref(
      "select distinct t.gene_id, esi.stable_id
         from $DBNAME.transcript as t, $DBNAME.exon_transcript as et, $DBNAME.exon_stable_id as esi
        where t.transcript_id = et.transcript_id and et.exon_id = esi.exon_id"
    );
    foreach( @$T ) {
      $exons{$_->[0]}{$_->[1]}=1;
    }
    my $gene_info = $conf->{'dbh'}->selectall_arrayref("
      select gsi.gene_id, tsi.transcript_id, trsi.translation_id,
             gsi.stable_id as gsid, tsi.stable_id as tsid, trsi.stable_id as trsid,
             g.description, ed.db_display_name, x.dbprimary_acc,x.display_label, ad.display_label, ad.description, g.source, g.status, g.biotype
        from (((( $DBNAME.gene_stable_id as gsi, $DBNAME.gene as g,
             $DBNAME.transcript_stable_id as tsi,
             $DBNAME.analysis_description as ad,
             $DBNAME.transcript as t) left join
             $DBNAME.translation as tr on t.transcript_id = tr.transcript_id) left join
             $DBNAME.translation_stable_id as trsi on tr.translation_id = trsi.translation_id) left join
             $DBNAME.xref as x on g.display_xref_id = x.xref_id) left join
             $DBNAME.external_db as ed on ed.external_db_id = x.external_db_id
       where t.gene_id = gsi.gene_id and t.transcript_id = tsi.transcript_id and t.gene_id = g.gene_id and g.analysis_id = ad.analysis_id
       order by gsi.stable_id, tsi.stable_id
    ");
    warn "Gene info query done";
    my $old;
    foreach my $row (@$gene_info) {
      my($g,$t,$tr,$gs,$ts,$trs,$d,$ddb,$dpa,$dn,$a,$ad,$s,$st,$bt) = @$row;
      if ($DB eq 'core') {
	$core_xrefs->{$dn}{'display_xref'} = $ddb;
      }
      if( $old->{'g'} != $g ) {
        if( $old->{'g'} ) {
          print O &geneLine( $conf->{'species'},
			     $old->{'ex'},
			     $old->{'s'}.' '.$old->{'bt'},
			     $old->{'gs'},
			     $old->{'alt'},
			     $extra,
			     join( ' ', grep{$_}keys %{$old->{'i'}}),
			     $old->{'t'},
			     $old->{'tr'},
			     $old->{'e'},
			     $old->{'d'} );
	  $gene_count++;
        }
        $old = {
          'g'   => $g,
          'gs'  => $gs,
          'd'   => $d,
          'tr'  => {$trs?($trs=>1):()},
          't'   => {$ts ?($ts=>1) :()},
          'ex'  => {},
          'e'   => {},
          'i'   => {$gs=>1,$ts=>1,$trs=>1}, 
          'alt' => ($DB ne 'vega' && $dn) ? "($ddb: $dn)" : $dn ? "($dn)" : "(novel gene)",
          'a'   => $a,
          'ad'  => $ad,
          's'   => ucfirst($s),
          'st'  => $st,
          'bt'  => $bt,
	  'dn'  => $dn,
        };
	if (   ($DB ne 'vega')
	    || ($core_xrefs->{$dn}{'display_xref'})
            || ($core_xrefs->{$dn}{'display_xref'} !~ /'Clone_based'/) ) {
	  $old->{'i'}->{$d}=1;
	  $old->{'i'}->{$dpa}=1;
	  $old->{'i'}->{$dn}=1;
	}
        $old->{'s'}=~s/base/Base/;
        $old->{'ex'} = $exons{$g};
        foreach my $K (keys %{$exons{$g}}) { $old->{'i'}{$K} = 1; }
        foreach my $db( keys %{$xrefs{'Gene'}{$g}||{}} ) {
          foreach my $K( keys %{$xrefs{'Gene'}{$g}{$db}} ) {
	    $old->{'e'}{$db}{$K}=1;	
	    &check_and_store($DB,$dn,$K,$core_xrefs,$old,'xrefs');
	  }
        }
        foreach my $db( keys %{$xrefs{'Transcript'}{$t}||{}} ) {
          foreach my $K( keys %{$xrefs{'Transcript'}{$t}{$db}} ) {
	    $old->{'e'}{$db}{$K}=1;	
	    &check_and_store($DB,$dn,$K,$core_xrefs,$old,'xrefs');
	  }
        }
        foreach my $db( keys %{$xrefs{'Translation'}{$tr}||{}} ) {
          foreach my $K( keys %{$xrefs{'Translation'}{$tr}{$db}} ) {
	    $old->{'e'}{$db}{$K}=1;	
	    &check_and_store($DB,$dn,$K,$core_xrefs,$old,'xrefs');
	  }
        }
	foreach my $K( keys %{$xrefs_desc{'Translation'}{$tr}} ) {
	  &check_and_store($DB,$dn,$K,$core_xrefs,$old,'xref_desc');
	}
	foreach my $K( keys %{$xrefs_desc{'Transcript' }{$t }} ) {
	  &check_and_store($DB,$dn,$K,$core_xrefs,$old,'xref_desc');
	}
	foreach my $K( keys %{$xrefs_desc{'Gene'       }{$g }} ) {
	  &check_and_store($DB,$dn,$K,$core_xrefs,$old,'xref_desc');
	}
      } else {
        $old->{'t'}{$ts}=1;
        $old->{'tr'}{$trs}=1;
        $old->{'i'}{$ts}=1;
        $old->{'i'}{$trs}=1;
	foreach my $db( keys %{$xrefs{'Transcript'}{$t}||{}} ) {
          foreach my $K( keys %{$xrefs{'Transcript'}{$t}{$db}} ) {
	    $old->{'e'}{$db}{$K}=1;	
	    &check_and_store($DB,$dn,$K,$core_xrefs,$old,'xrefs');
	  }
        }
        foreach my $db( keys %{$xrefs{'Translation'}{$tr}||{}} ) {
          foreach my $K( keys %{$xrefs{'Translation'}{$tr}{$db}} ) {
	    $old->{'e'}{$db}{$K}=1;	
	    &check_and_store($DB,$dn,$K,$core_xrefs,$old,'xrefs');
	  }
        }
	foreach my $K( keys %{$xrefs_desc{'Translation'}{$tr}} ) {
	  &check_and_store($DB,$dn,$K,$core_xrefs,$old,'xref_desc');
	}
	foreach my $K( keys %{$xrefs_desc{'Transcript' }{$t }} ) {
	  &check_and_store($DB,$dn,$K,$core_xrefs,$old,'xref_desc');
	}
      }
    }
    print O &geneLine( $conf->{'species'},
		       $old->{'ex'},
		       $old->{'s'}.' '.$old->{'bt'},
		       $old->{'gs'},
		       $old->{'alt'},
		       $extra,
		       join( ' ', grep{$_}keys %{$old->{'i'}}),
		       $old->{'t'},
		       $old->{'tr'},
		       $old->{'e'},
		       $old->{'d'} );
    $gene_count++;
    print STDOUT "$gene_count $DB genes indexed\n";
  }

#  warn Dumper($core_xrefs->{'ARSE'});
  my $other_count = 0;
  my %current_stable_ids =();
  foreach my $type (qw(gene transcript translation)) {
    $current_stable_ids{$type}  = {map {@$_} @{$conf->{'dbh'}->selectall_arrayref( "select stable_id,1 from $COREDB.".$type."_stable_id" )}};
  }
  my $species = $conf->{'species'};
  my $sth = $conf->{'dbh'}->prepare( qq(
    select sie.type, sie.old_stable_id, if(isnull(sie.new_stable_id),'NULL',sie.new_stable_id), ms.old_release*1.0 as X, ms.new_release*1.0 as Y
      from $COREDB.mapping_session as ms, $COREDB.stable_id_event as sie
     where ms.mapping_session_id = sie.mapping_session_id and ( old_stable_id != new_stable_id or isnull(new_stable_id) )
     order by Y desc, X desc
  ));

  $sth->execute();
  my %mapping = ();
  while( my($type,$osi,$nsi) = $sth->fetchrow_array() ) {
    next if $current_stable_ids{$type}{$osi}; ## Don't need to cope with current IDS already searchable...
    $mapping{$type}{$osi}{$nsi}=1;
    if($mapping{$type}{$nsi}) {
      foreach( keys %{$mapping{$type}{$nsi}} ) {
        $mapping{$type}{$osi}{$_}=1;
      }
    }
  }
  foreach my $type ( keys %mapping ) {
    my $url = $type eq 'gene' ? 'Gene/Idhistory?g'
	    : $type eq 'transcript' ? 'Transcript/Idhistory?t'
	    : 'Transcript/Idhistory/Protein?protein';
    foreach my $osi ( keys %{$mapping{$type}} ) {
      my @current_sis = ();
      my @deprecated_sis = ();
      foreach ( keys %{$mapping{$type}{$osi}} ) {
	next if $osi eq $_;
        if( $current_stable_ids{$_} ) {
          push @current_sis,$_;
        } elsif( $_ ne 'NULL' ) {
          push @deprecated_sis,$_;
        }
      }
      if( @current_sis ) {
	$other_count++;
        print O join( "\t",
          (INC_SPECIES?"$species\t":"").qq(Ensembl $type),
          qq($osi),
          qq(/$species/$url=$osi),
          join( ' ', $osi, @current_sis, @deprecated_sis ),
          qq($type $osi is no longer in the Ensembl database but it has been mapped to the following current identifiers: @current_sis).
          ( @deprecated_sis ? "; and the following deprecated identifiers: @deprecated_sis" : '').
          ".\n"
        );
      } elsif( @deprecated_sis ) {
	$other_count++;
        print O join( "\t",
          (INC_SPECIES?"$species\t":"").qq(Ensembl $type),
          qq($osi),
          qq(/$species/$url=$osi),
          join( ' ', $osi, @deprecated_sis ),
          qq($type $osi is no longer in the Ensembl database but it has been mapped to the following identifiers: @deprecated_sis\n)
        );
      } else {
	$other_count++;
        print O join( "\t",
          (INC_SPECIES?"$species\t":"").qq(Ensembl $type),
          qq($osi),
          qq(/$species/$url=$osi),
          qq($osi),
          qq($type $osi is no longer in the Ensembl database and it has not been mapped to any newer identifiers\n)
        );
      }
    }
  }
  print STDOUT "$other_count other stable IDS indexed\n";
  $other_count = 0;
  my %unmapped_queries = (
    'None' => qq(
      select a.logic_name, e.db_display_name,
             uo.identifier, ur.summary_description,
             'Not mapped'
        from $COREDB.analysis as a, $COREDB.external_db as e, $COREDB.unmapped_object as uo,
             $COREDB.unmapped_reason as ur
       where a.analysis_id = uo.analysis_id and 
             uo.external_db_id = e.external_db_id and
             uo.unmapped_reason_id = ur.unmapped_reason_id and
               uo.ensembl_id = 0
    ),
    'Transcript' => qq(
      select a.logic_name, e.db_display_name,
             uo.identifier, ur.summary_description,
             concat( 'Transcript: ', tsi.stable_id, '; Gene: ',gsi.stable_id )
        from $COREDB.analysis as a, $COREDB.external_db as e, $COREDB.unmapped_object as uo,
             $COREDB.unmapped_reason as ur, $COREDB.transcript_stable_id as tsi,
             $COREDB.transcript as t, $COREDB.gene_stable_id as gsi
       where a.analysis_id = uo.analysis_id and 
             uo.external_db_id = e.external_db_id and
             uo.unmapped_reason_id = ur.unmapped_reason_id and
             uo.ensembl_id = t.transcript_id and
             uo.ensembl_object_type = 'Transcript' and
             t.transcript_id = tsi.transcript_id and
             t.gene_id       = gsi.gene_id
    ),
    'Translation' => qq(
      select a.logic_name, e.db_display_name, uo.identifier, ur.summary_description,
             concat( 'Protein: ',trsi.stable_id,'; Transcript: ', tsi.stable_id, '; Gene: ',gsi.stable_id )
        from $COREDB.analysis as a, $COREDB.external_db as e, $COREDB.unmapped_object as uo,
             $COREDB.unmapped_reason as ur, $COREDB.transcript_stable_id as tsi,
             $COREDB.translation as tr, $COREDB.translation_stable_id as trsi,
             $COREDB.transcript as t, $COREDB.gene_stable_id as gsi
       where a.analysis_id = uo.analysis_id and 
             uo.external_db_id = e.external_db_id and
             uo.unmapped_reason_id = ur.unmapped_reason_id and
             uo.ensembl_id = tr.translation_id and 
             tr.transcript_id = t.transcript_id and
             trsi.translation_id = tr.translation_id and
             uo.ensembl_object_type = 'Translation' and
             t.transcript_id = tsi.transcript_id and
             t.gene_id       = gsi.gene_id
    )
  );

  %unmapped_queries = (); #don't do these for now

  foreach my $FLAG (keys %unmapped_queries) {
    my $SQL = $unmapped_queries{$FLAG};
    my $sth = $conf->{'dbh'}->prepare($SQL);
    $sth->execute;
    while( my $T = $sth->fetchrow_arrayref() ) {
      print O join "\t",
        (INC_SPECIES?"$conf->{'species'}\t":"").qq(Unmapped feature),
        "$T->[1] $T->[2]",
        "/$conf->{'species'}/Location/Genome?ftype=Gene;id=$T->[2]",
        "$T->[2] $T->[4]",
        "$T->[3]; $T->[4]\n";
    }
  }
  close O;
}


sub check_and_store {
  my ($DB,$dn,$K,$core_xrefs,$old,$rec_type) = @_;
  if ($DB eq 'core') {
    $old->{'i'}{$K}=1;
    push @{$core_xrefs->{$dn}{$rec_type}}, $K;
  }

#enable filtering here
  elsif (0) {
#  elsif ($DB eq 'vega' ) {
    if (   ($core_xrefs->{$dn}{'display_xref'} !~ /'Clone_based'/)
        || (! grep {$_ eq $K} @{$core_xrefs->{$dn}{$rec_type}})
        || ($K =~ /OTT|ENS/)) {
      $old->{'i'}{$K}=1;
    }
  }
  else { $old->{'i'}{$K}=1; }
}

sub geneLine {
  my ($species, $exons, $X, $gid, $altid, $extra, $IDX, $transcripts, $peptides, $external_identifiers, $description )=@_;
  return if $gid eq '';
  my $T = scalar (keys %$transcripts);
  my $P = scalar (keys %$peptides);
  my $E = scalar (keys %$exons);
  my $EX = scalar (keys %$external_identifiers);
  $IDX =~ s/\n/ /g;
#  if ($gid =~ /ENSG00000157399|OTTHUMG00000137358/) {
#    warn "indexing $gid with ",Data::Dumper::Dumper($IDX);
#  }
#  $EX =~ s/\n/ /g;
  return join( "\t",
    (INC_SPECIES?"$species\t":"").qq($X Gene),
    qq($gid $altid),
    qq(/$species/Gene/Summary?g=$gid$extra),
    qq($IDX),
    qq($X gene $gid has $T transcript).($T==1?'':'s').qq(: ).join(', ',sort keys(%$transcripts)).
    ( $P > 0 ? 
      qq(, associated peptide).($P==1?'':'s').qq(: ).join(', ',sort keys(%$peptides)) : '').
    qq( and $E exon).($E==1?'':'s').qq(: ).join(', ',sort keys(%$exons)). 
    qq(<br />$description).( $EX>0 ?
      (
        qq(<br />The gene has the following external identifiers mapped to it:<br />).
        ( join '<br />',
          map { s/translation:/protein:/i; s/\n/ /g; $_ }
		  map { "$_: ".(join ", ", keys %{$external_identifiers->{$_}}) }
          sort { lc($a) cmp lc($b) } keys %$external_identifiers
        )
      ) : ''
    ).qq(\n)
  );
}

########################################################################## Sequences

sub dumpSequence {
  my $conf = shift;
  my $sanger = sanger_project_names( $conf );
  my %config = (
    "Homo_sapiens" => [
      [ 'Clone',      'tilepath,cloneset_1mb,cloneset_30k,cloneset_32k', 'name,well_name,clone_name,synonym,embl_acc,sanger_project,alt_well_name,bacend_well_name' ],
      [ 'NT Contig',  'ntctgs',                  'name' ],
      [ 'Encode region', 'encode', 'name,synonym,description' ],
    ],
    "Mus_musculus" => [
      [ 'BAC',        'cloneset_0_5mb,cloneset_1mb,bac_map,tilingpath_cloneset', 'embl_acc,name,clone_name,well_name,synonym,alt_embl_acc' ],
      [ 'Fosmid',     'fosmid_map', 'name,clone_name' ],
      [ 'Supercontig','superctgs', 'name' ],
    ],
    "Anopheles_gambiae" => [
      [ 'BAC' ,       'bacs',        'name,synonym,clone_name' ],
      [ 'BAC band' ,  'bacs_bands',  'name,synonym,clone_name' ],
    ],
    "Gallus_gallus" => [
      [ 'BAC', 'bac_map', 'name,synonym,clone_name' ],
      [ 'BAC ends', 'bacends', 'name,synonym,clone_name', 'otherfeatures' ]
    ]
  );
  
  my $COREDB   = $conf->{'dbs'}->{'DATABASE_CORE'};
  my $ESTDB    = $conf->{'dbs'}->{'DATABASE_OTHERFEATURES'};
  open O, ">$conf->{'directory'}/Sequence.txt";
  my @types = @{$config{$conf->{'species'}}||[]};
  foreach my $arrayref ( @types ) {
    my( $TYPE, $mapsets, $annotationtypes,$DB ) = @$arrayref;
    my $DB = $DB eq 'otherfeatures' ? $ESTDB : $COREDB;
    my @temp         = split (',',$mapsets);
    my @mapsets;
    foreach my $X ( @temp ) {
       my $ID = $conf->{'dbh'}->selectrow_array( "select misc_set_id from $DB.misc_set where code = ?", {}, $X );
      push @mapsets, $ID if($ID);
    }
    next unless @mapsets;
    @temp = split (',',$annotationtypes);
    my @mapannotationtypes;
    foreach my $X ( @temp ) {
      my $ID = $conf->{'dbh'}->selectrow_array( "select attrib_type_id from $DB.attrib_type where code = ?", {}, $X );
      push @mapannotationtypes, $ID if($ID);
    }
    next unless @mapannotationtypes;
    my $Z = " ma.value";
    my $MAPSETS = join ',',@mapsets;
    my $sth = $conf->{'dbh'}->prepare(
      "select mf.misc_feature_id, sr.name, mf.seq_region_start, mf.seq_region_end,
              ma.value, mf.seq_region_end-mf.seq_region_start+1 as len, 
              at.code
         from $DB.misc_feature_misc_set as ms, 
              $DB.misc_feature as mf,
              seq_region   as sr,
              $DB.misc_attrib  as ma,
              $DB.attrib_type  as at 
        where mf.seq_region_id = sr.seq_region_id and mf.misc_feature_id = ms.misc_feature_id and ms.misc_set_id in ($MAPSETS) and
              mf.misc_feature_id = ma.misc_feature_id and ma.attrib_type_id = at.attrib_type_id
        order by mf.misc_feature_id, at.code"
    );
    $sth->execute();
    my ($oldtype,$old_ID,$oldchr,$old_start,$old_end,$emblaccs,$oldlen,$synonyms, $NAME );
    while( my($ID,$chr,$start,$end,$val,$len,$type) = $sth->fetchrow_array() ) {
      if($ID == $old_ID) {
        $NAME = $val if $type eq 'well_name' || $type eq 'clone_name' || $type eq 'name' || $type eq 'non_ref';
        $NAME = $val if !$NAME && $type eq 'embl_acc';
        $NAME = $val if !$NAME && $type eq 'synonym';
        $NAME = $val if !$NAME && $type eq 'sanger_project';
        $emblaccs.=", $val" if $val;
      } else {
        print O &seqLine( $conf->{'species'},$TYPE,$NAME,$oldchr,$old_start,$old_end,$emblaccs,$oldlen,$sanger) if $old_ID;
        $NAME = undef;
        $NAME = $val if $type eq 'well_name' || $type eq 'clone_name' || $type eq 'name' || $type eq 'non_ref';
        $NAME = $val if !$NAME && $type eq 'embl_acc';
        $NAME = $val if !$NAME && $type eq 'synonym';
        $NAME = $val if !$NAME && $type eq 'sanger_project';
        ($old_ID,$oldchr,$old_start,$old_end,$emblaccs,$oldlen) = ($ID,$chr,$start,$end,$val,$len);
      }
    }
    print O &seqLine( $conf->{'species'},$TYPE,$NAME,$oldchr,$old_start,$old_end,$emblaccs,$oldlen,$sanger) if $old_ID;
  }

  my $sth = $conf->{'dbh'}->prepare(
    "select c.name, c.length, cs.name
       from seq_region as c, coord_system as cs
      where c.coord_system_id = cs.coord_system_id" );
  $sth->execute();
  while( my($name,$length,$type) = $sth->fetchrow_array() ) {
    my $extra_IDS = ''; my $extra_desc = '';
    if( %{$sanger->{$name}||{}} ) {
      $extra_IDS  = join ' ', '',sort keys %{$sanger->{$name}};
      $extra_desc = " and corresponds to the following Sanger projects: ".join( ', ',sort keys %{$sanger->{$name}});
    }
    my $r = "$name:1-$length";
    print O join "\t",
      (INC_SPECIES?"$conf->{'species'}\t":"").ucfirst($type),       $name,
      ($type eq 'chromosome' && length( $name ) < 5) ?
        "/$conf->{'species'}/Location/Chromosome?r=$r" :
        ($length > 0.5e6 ? "/$conf->{'species'}/Location/Overview?r=$r" :
              "/$conf->{'species'}/Location/View?r=$r" ),
      "$name$extra_IDS", "$name is a @{[ucfirst($type)]} (of length $length)$extra_desc\n";
  }
  close O;
}

sub seqLine {
  my($species,$type,$name,$chr,$start,$end,$val,$len,$sanger) = @_;
  my $Q = $val; $Q=~s/,//g;
  my $SCRIPT = $len > 0.5e6 ? 'Location/Overview' : 'Location/View';
  my $r = "$chr:$start-$end";
  my $extra_IDS = '';
  my $extra_desc = '';
  my %HASH;
  foreach ( split / +/,"$name $val" ) {
    foreach( keys %{$sanger->{$name}||{}} ) {
      $HASH{$_}=1;
    }
  }
  if( %HASH ) {
    $extra_IDS  = join ' ', '',sort keys %HASH;
    $extra_desc = " and corresponds to the following Sanger projects: ".join( ', ',sort keys %HASH );
  }

  return join "\t",
    (INC_SPECIES?"$species\t":"").$type,
    $name, "/$species/$SCRIPT?r=$r",
    "$name $Q$extra_IDS",
    "$type $name is mapped to Chromosome $chr, and has". (($val &&  ($val ne "")) ? " EMBL accession(s)/synonyms $val and " : "").
    " length $len bps$extra_desc\n";
}

########################################################################## Sanger Projects

sub sanger_project_names {
  my $conf = shift;
  my %SPECIES = qw(
    Homo_sapiens Human Mus_musculus Mouse Danio_rerio Zebrafish
    Drosophila_melanogaster Drosophila Rattus_norvegicus Rat
  );
  my $sanger_species_name = $SPECIES{$conf->{'species'}};
  return {} unless $sanger_species_name;
  my $clones = {};
  my $dbh = DBI->connect("DBI:mysql:host=otterlive;port=3301;database=submissions", 'ottro', undef, {RaiseError => 1});
  unless( $dbh ) {
    warn "Can't connect to submissions database as 'read_only' ", DBI::errstr();
    return $clones;
  }
  my $sth = $dbh->prepare(
    "SELECT distinct a.project_name, a.accession 
       FROM project_acc a, project_dump d,
            sequence s, species_chromosome c
      WHERE a.sanger_id = d.sanger_id AND d.seq_id = s.seq_id
        AND s.chromosome_id = c.chromosome_id 
        AND c.species_name = '$sanger_species_name' AND a.accession != 'UNKNOWN'"
  );
  $sth->execute(  );
  while( my ($proj, $acc) = $sth->fetchrow() ) {
    $clones->{$acc}{$proj}=1;
  }
  return $clones;
}
