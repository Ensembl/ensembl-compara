#!/usr/local/bin/perl

package textview;

use strict;
use constant MAXDOCS_MULTI   => 5;
use constant MULTI_PER_PAGE  => 20;
use constant MAXDOCS_SINGLE  => 1000;

use EnsEMBL::Web::Document::Dynamic;
use EnsEMBL::Web::Document::Renderer::Apache;
use EnsEMBL::Web::RegObj;
our $SD = $ENSEMBL_WEB_REGISTRY->species_defs;
use EnsEMBL::Web::Factory::Search::AVIndexUtils;
use CGI;

use AltaVista::PerlSDK qw(
  AVS_OK avs_create_options avs_search avs_getsearchresults avs_search_getdata
  avs_errmsg avs_search_close
);

my $AVINDEXROOT = $SD->ENSEMBL_ALTAVISTA_INDEX_PATH;
my $MODE = 'r';
my $q    = new CGI();

if( $SD->ENSEMBL_SEARCH ne 'textview' ) {
  CGI::redirect( sprintf( "/%s/%s?%s", $ENV{'ENSEMBL_SPECIES'}, $SD->ENSEMBL_SEARCH, $ENV{'QUERY_STRING'} ) );
  exit;
}

my $rend     = new EnsEMBL::Web::Document::Renderer::Apache( );
my $document = new EnsEMBL::Web::Document::Dynamic( $rend,undef, $SD);

CGI::header;

$document->_initialize_HTML();

my( $parameters, $idx_hash, $idx_list, $idx_list2 ) = munge_parameters( $q );

$document->javascript->add_script(
  javascript_idx_hash( $idx_hash, $idx_list )
);
$document->add_body_attr(
  'onload' => "setSelectOptions( document.forms['IndexForm'].elements['idx'], document.forms['IndexForm'].elements['species'], speciesConf ); return true;"
);

my $content = '';
my $ERROR = '';
my $T;

$content .= print_form( $parameters, $idx_hash );
   if( $parameters->{'query'} eq "" ){ $ERROR = qq( No search string specified! ); }
elsif( ! @$idx_list ) { $ERROR = qq( You have not chosen a valid index! ); }
elsif( $parameters->{'query'} =~ /^\w{1,2}[\*\?\.]+/ ){ $ERROR = qq( Search string must have at least 3 characters before a wildcard! ); }
 else { ($ERROR,$T) = &do_search( $AVINDEXROOT, $idx_list2, $parameters, $idx_hash ); $content.=$T; }

if($ERROR) {
  $content .= qq( <p><strong>$ERROR</strong><p>\n );
  $content .= print_syntax();
}

my $panel = new EnsEMBL::Web::Document::Panel(
  'caption' => 'Ensembl text search',
  'content' => $content
);
$document->content->add_panel($panel);
$document->render();

############# Functions #############

#####################################################
#### Munge parameters
#####################################################

sub javascript_idx_hash {
    my $idx_hash = shift;
    my $idx_list = shift;
    my %id_hash;
    foreach( @$idx_list ) {
        my($k,$v) = split(/\//,$_,2);
        push @{$id_hash{$k}}, $v;
    }
    my $js = "  speciesConf = new Array();\n";
    $js.= "    speciesConf['All'] = new Array('". join( "','",'All',sort keys %{$idx_hash} )."');\n";
    foreach my $S ( keys %id_hash ) {
        $js .= "    speciesConf['$S'] = new Array('". join( "','",'All',sort @{$id_hash{$S}} )."');\n";
    }    
     return qq(
$js
function setSelectOptions( selectGrp, speciesDD, conf ){
  
  // Get the selected value from the options
  var optSelected;
  var X = speciesDD.options[speciesDD.selectedIndex].value;
  optValues  = optLabels = conf[ X ];
  optDefault = 'All';
  for( var i=0; i<selectGrp.options.length; i++ ){
    if( selectGrp.options[i].selected == true ){
      optSelected = selectGrp.options[i].value;
    }
  }  
  if( optSelected == undefined ){ optSelected = optDefault }

  // Delete existing select options
  while( selectGrp.options.length > 0 ){
    selectGrp.options[0] = null;
  }

  // Check for options
  if( optValues.length == 0 ){ 
    optValues[0] = 0;
    optLabels[0] = \"---Unavailable---\";
  }

  // Assign new options
  for( var i=0; i<optValues.length; i++ ){
    thisOption = new Option( optLabels[i],optValues[i],false,false );
    if( optValues[i] == optSelected ){thisOption.selected = true }
    thisIndex  = selectGrp.options.length;
    selectGrp.options[thisIndex] = thisOption;
  }
}
);
}

sub munge_parameters {
  my $q = shift;

  my $species = $q->param( 'species' ) || $ENV{'ENSEMBL_SPECIES'};
  if( ! $SD->valid_species( $species ) ){
    $species = 'ALL'
  }

  my $parameters = {
    'query'  => lc($q->param('q')),     'number' => $q->param('num') || 0,
    'format' => $q->param('fmt')||'s',  'index'  => $q->param('idx') || 'ALL',
    'species'=> $species,
    'page'   => $q->param('page'),
  };
  if(defined $q->param('type')) {            # we came from the top search menu
    ( $parameters->{'index'} = ucfirst($q->param('type')) ) =~ s/Sangerproject/SangerProject/;
  }
  $parameters->{'query'} =~ s/^\s+//; # Trim off leading/trailing whitespace;
  $parameters->{'query'} =~ s/\s+$//;
  $parameters->{'query'} =~ s/^\*+(.*)/$1/; # Trim off leading *'s
  $parameters->{'query'} =~ s/^(.*?)\*+$/$1\*\*/; # convert trailing stars to two "**"s
  $parameters->{'safe_query'} = CGI::escapeHTML($parameters->{'query'});

    #convert non word characters (with exceptions) to '_'

  $parameters->{'query'} =~ s/[^\w\s\(\)\*\?\+\-\[\]\\\/]/\_/g; 
  $parameters->{'query'} =~ s/(\s)\+/\_/g;
  $parameters->{'query'} =~ s/(\s)\-/\_/g;

  my @idx_list;
  foreach my $S ( @{$SD->ENSEMBL_SPECIES} ) {
    push @idx_list, map { "$S/$_" } @{ $SD->other_species($S,'ENSEMBL_SEARCH_IDXS')||[] };
  }
  my %idx_hash = map { /\/(.*?)$/ ? ($1,1) : ()} @idx_list;
  my @idx_list2 = @idx_list;
  @idx_list2 = grep { /^$parameters->{'species'}\// } @idx_list2 if uc($parameters->{'species'}) ne 'ALL';

  my $idx = $parameters->{'index'};
  @idx_list2 = grep { /$idx/ } @idx_list2 if uc($idx) ne 'ALL';
  return( $parameters, \%idx_hash, \@idx_list, \@idx_list2 );
}


#####################################################
## Search the index
## Returns 1 else -1 on error
#####################################################
sub do_search {
    my ($IDXROOT, $idx_list, $parameters, $idx_hash ) = @_;
    my $KEY = $SD->ENSEMBL_ALTAVISTA_KEY;
    my ($options, $found, $returned, $termcount, $search, $status, $day, $month, $year);

    my ($total_documents, $documents, $total_matches, $matches ) = 0;
    my %weight = ( 'Gene' => 100, 'Peptide' => 200 );
    
    my $SINGLE_INDEX = @$idx_list == 1 ? 1: 0;
    my $maxdocs;
    if($SINGLE_INDEX) {
         $maxdocs = $parameters->{'number'} > 0 ? $parameters->{'number'} : MAXDOCS_SINGLE;
    } else {
         $maxdocs = MAXDOCS_MULTI;
    }
    my $timeout = 100;
    $options = avs_create_options( $maxdocs,$timeout,1);
    my $output = '';
    foreach my $idx (
      map { $_->[1] }
      sort { $a->[0] cmp $b->[0] }
      map { my @T = split /\//; [sprintf('%03d:%-100.100s:%-100.100s', $weight{$T[1]}||500,$T[1],$T[0]),$_]; }
      @$idx_list
    ) {
        my $matches=0;
        my $IDX_HANDLE;
        eval{
            $IDX_HANDLE = ens_avs_open("$IDXROOT/$idx.idx",$KEY) || warn( "Fatal: cannot open index: $idx\n" );
            $status = avs_search( $IDX_HANDLE, "**", "", $options, $documents, $returned, $termcount, $search);
            if ($parameters->{'query'} =~ /AND|NOT|OR|NEAR|WITHIN|BEFORE|AFTER|WITHIN|ATLEAST/oi){
                $status = avs_search( $IDX_HANDLE, "", $parameters->{'query'}, $options, $matches, $returned, $termcount, $search);
            } else{
                $status = avs_search( $IDX_HANDLE, $parameters->{'query'}, "", $options, $matches, $returned, $termcount, $search);
            }
        };
        if($@) { 
            print STDERR "ERROR: cannot search AV index $idx ($@)\n" if ($@);
        } elsif($status>0) {
            return ( "Unable to perform search - the query string is invalid", "" );
        } else {
            $total_documents += $documents;
            $total_matches   += $matches;
            if ($matches > 0) {
                if($SINGLE_INDEX) {
                    $output .= &single_index( $idx, $matches, $documents, $parameters, $IDX_HANDLE, $search ) ;
                } else {
                    $output .= &multi_index(  $idx, $matches, $documents, $parameters, $IDX_HANDLE, $search ) ;
                }
            }
            ens_avs_close($IDX_HANDLE);
        }
    }
    if( $total_matches == 0 ) {
        if($SINGLE_INDEX) {
            return( "", &single_index_no_results( $total_documents ) );
        } else {
            return( "", &multi_index_no_results(  $total_documents ) );
        }
    } 
#    &archive_search if($total_matches == 0);
    return( "", $output );
}

sub single_index {
 my $ret = '';
    my( $idx, $matches, $documents, $parameters, $IDX_HANDLE, $search ) = @_;
    my( $species, $index ) = split(/\//,$idx);
    $index=~s/\.idx$//;
    $ret .= qq(<p><strong>$matches</strong> documents match your query <small><em>(Documents searched: $documents)</em></small><p>\n);
    my $maxdocs = $parameters->{'number'} > 0 ? $parameters->{'number'} : MAXDOCS_SINGLE;
    $maxdocs = $matches if $matches < $maxdocs;
    my $max_page  = int( ( $maxdocs - 1 ) /MULTI_PER_PAGE) + 1;
    $parameters->{'page'} = $max_page - 1 if $parameters->{'page'} >= $max_page;
    my $end = ($parameters->{'page'} + 1) * MULTI_PER_PAGE;
    $end = $matches if $end > $matches;
    $ret .= &show_results( 
	'species'    => $species,
        'index'      => $index,
        'matches'    => $matches,
        'documents'  => $documents,
        'query'      => $parameters->{'query'},
        'format'     => $parameters->{'format'},
        'start'      => $parameters->{'page'} * MULTI_PER_PAGE + 1,
        'end'        => $end,
        'handle'     => $IDX_HANDLE,
        'search'     => $search
    ) ;
    ### Produce paging bits....
    if( $matches > MULTI_PER_PAGE ) {
       my $URL = qq(/$species/textview?idx=$index&q=).
		CGI::escape($parameters->{'query'}).
		qq(&fmt=$parameters->{'format'}&num=$parameters->{'number'});
       my $page = $parameters->{'page'};
       $ret .= qq(<div align="center">);
       if( $page > 0 ) { $ret .= qq([<a href="$URL&page=).($page-1).qq(">&lt;&lt; Prev</a>] ); }
       foreach my $i (0..($max_page-1)) {
           my $p = $i+1;
           if($i == $page) {
	       $ret .= qq([<b>$p</b>] ); 
           } else {
	       $ret .= qq([<a href="$URL&page=$i">$p</a>] );
           }
       }
       if( $page < $max_page-1 ) { $ret .= qq([<a href="$URL&page=).($page+1).qq(">Next &gt;&gt;</a>] ); }
       $ret .= qq(</div>);
    }
    return $ret;
}

sub multi_index {
 my $ret = '';
    my( $idx, $matches, $documents, $parameters, $IDX_HANDLE, $search ) = @_;
    my( $species, $index ) = split(/\//,$idx);
    $index=~s/\.idx$//;
    ( my $S = $species ) =~ s/_/ /g;
    $ret .= qq(<h3>$matches matches in the <i>$S</i> $index index [first ).MAXDOCS_MULTI.q( matches shown]:</h3>);
    $ret .= &show_results( 
	'species'    => $species,
        'index'      => $index,
        'matches'    => $matches,
        'documents'  => $documents,
        'query'      => $parameters->{'query'},
        'format'     => $parameters->{'format'},
        'start'      => 1,
        'end'        => $matches > 5 ? 5 : $matches,
        'handle'     => $IDX_HANDLE,
        'search'     => $search
    ) ;
    if( $matches > MAXDOCS_MULTI ) {
        my $URL = qq(/$species/textview?idx=$index&q=).
		CGI::escape($parameters->{'query'}).
		qq(&fmt=$parameters->{'format'});
        $ret .= qq(<blockquote><a href="$URL">[View more matches.... ]</a></blockquote>);
    }
  return $ret;
}

sub single_index_no_results {
  my( $documents ) = @_;
  return qq(<p><strong>Your query found no matches</strong> <small><em>(Documents searched: $documents)</em></small></p>\n);
}

sub multi_index_no_results {
  my( $documents ) = @_;
  return qq(<p><strong>Your query found no matches</strong> <small><em>(Documents searched: $documents)</em></small></p>\n);
}

###############################################################################

sub show_results {
    my %parameters = @_;
  my $ret = '';
    my $AI = '<img width="12" height="12" border="0" src="/img/avshit.gif" alt="" />';
    foreach my $i ( $parameters{'start'}..$parameters{'end'} ) {
        my $status = avs_getsearchresults($parameters{'search'},$i-1);
        if ($status eq AVS_OK){
            my $header_info = avs_search_getdata($parameters{'search'});
            my %XML_tags = parse_XML_header($header_info);
            $XML_tags{'ABSTRACT'} = highlight_matches($XML_tags{'ABSTRACT'},$parameters{'query'});
            $XML_tags{'ABSLEN'}   = '&lt;1' if $XML_tags{'ABSLEN'} == 0;

            $ret .= qq(<blockquote><b>$i. $XML_tags{'TITLE'}: </B><A HREF="$XML_tags{'URL'}">$XML_tags{'NAME'}</A>);
            unless ($parameters{'format'} eq "c"){ # want compact results so omit summary
                $ret .= qq(<br /><font size="-1" face="helvetica">$XML_tags{'ABSTRACT'}</font>);
            }
            $ret .= qq(<br />$AI&nbsp;\n);
                if( (my $URL = $XML_tags{'URL'})=~s/\/contigview/\/cytoview/ ) {
                    $ret .= qq(Contigview: <font size="-1"><A HREF="$XML_tags{'URL'}">http://$ENV{'SERVER_NAME'}$XML_tags{'URL'}</A></font><br />);
                    $ret .= qq($AI&nbsp;\nCytoview: <font size="-1"><A HREF="$URL">http://$ENV{'SERVER_NAME'}$URL</A></font>);
                } elsif( (my $URL = $XML_tags{'URL'})=~s/\/(gene|marker|trans|prot)view/\/contigview/ ) {
                    $ret .= ucfirst($1).qq(view: <font size="-1"><A HREF="$XML_tags{'URL'}">http://$ENV{'SERVER_NAME'}$XML_tags{'URL'}</A></font><br />);
                    $ret .= qq($AI&nbsp;\nContigView: <font size="-1"><A HREF="$URL">http://$ENV{'SERVER_NAME'}$URL</A></font>);
                } else {
                    $ret .= qq(<font size="-1"><A HREF="$XML_tags{'URL'}">http://$ENV{'SERVER_NAME'}$XML_tags{'URL'}</A></font>);
                }
            #print qq(<font size="-1" face="helvetica"> - Last Modified: <B>$XML_tags{'LASTMOD'}</B> - \n);
            #print qq(Size: <B>$XML_tags{'ABSLEN'}K</B></font></P>);
            $ret .= qq(</blockquote>);
        } else {
            my $error = avs_errmsg($status);
            $ret .= "Search error: cannot get search results: $error\n";
            return (-1);
        }
    } # end of for..
  return $ret;
}

# ########################################################################### #
# The XML is so small we might as well parse it ourselves...

sub parse_XML_header {
    my ($XML_string) = @_;
    $XML_string =~ s/<\/?AV_IDX_HDR>//g;
    my %fields = ();
    $XML_string =~ s/<(.*?)>(.*?)<\/(.*?)>/$fields{$1}=$2/ieg;
    $fields{'ABSTRACT'} =~ s/ \*FIELD\* //g;
    $fields{'ABSTRACT'} =~ s/\*RECORD\*//g;
    return (%fields);
}

# ########################################################################### #
sub highlight_matches {
    my ($string, $query) = @_;
    my $color = "red";
    $query =~ s/WITHIN \d+//ig; # This removes (eg) "WITHIN 5" clause from a search wordlist
    $query =~ s/ATLEAST \d+//ig; # This removes (eg) "WITHIN 5" clause from a search wordlist
    $query =~ s/AND|NOT|OR|NEAR|BEFORE|AFTER|\(|\)|\*|\?|\"|\+//ig; # remove AV-specific terms$
    my %words = map { ($_,1) } split /\s+/, $query;
    
    my $search = '('.join( '|', map { quotemeta( $_ ) } keys %words ).')';
    $string =~ s/$search/<font color=\"$color\">\1<\/font>/gi;
    return ($string);
} # end of sub
                
####################################3
sub print_syntax {

#print Vega help

if ($SD->ENSEMBL_SITETYPE eq 'Vega') {
	return qq(
<table align="center" width="600" border="0" cellspacing="0">
  <tr valign="top">
    <th class="yellow2">Search Indices</th>
  </tr>
  <tr valign="top">
    <td class="yellow1">
      <p>
        The VEGA free-text search index facilitates finding clones, genes, transcripts and proteins from the 
VEGA database. In addition it allows searching for EMBL ESTs and mRNAs, and for SwissProt entries used during the annotation process.
      </p>
      <p> <ul>
       <li> The <strong>"Gene"</strong> search index allows searching for the GeneView fields 'Curated Locus', 'Locus ID', 'Alternative Symbols', 'Description', 'Database Matches' and also 'Vega Transcript ID'.
       <li> The <strong>"Transcript"</strong> search index allows searching for TransView fields 'Transcript', 'Vega Transcript ID' and 'Description'.
       <li> The <strong>"Peptide"</strong> search index allows searching for ProteinView fields 'Vega Translation ID' and 'Peptide'.
       <li> The <strong>"Domain"</strong> search index allows searching for Interpro domains that are represented in at least one Vega transcript.
       <li> The <strong>"SNP"</strong> search index allows searching for identifiers for SNPs from the Glovar database that are present in Vega. 
       <li> The <strong>"Marker"</strong> search index allows searching for markers downloaded from dbSTS (Danio only).
       <li> The <strong>"Sequence"</strong> search index allows searching for Ensembl contigs present in the genome assembly. This can be queried using either the EMBL accession numbers for the Ensembl clones used during the genome sequencing (eg AL034548), or with the Ensembl contig identifiers themselves (eg AL034548.25.1.153170). The <strong>"SangerProject"</strong> search index can be searched for clone names used by the Sanger Institute during the manual annotation process and can be queried with the EMBL accession number for an Ensembl clone.
       <li> The <strong>"EST"</strong> and <strong>"MRNA"</strong> search indices can be searched for EMBL ESTs and mRNAs respectively - they are not used for VEGA transcripts. Similarly the <strong>"Protein"</strong> index is used for SwissProt entries and not for VEGA peptides.
</ul>
    </td>
  </tr>
  <tr>
    <td>&nbsp;</td>
  </tr>

 <tr valign="top">
    <th class="yellow2">Use of wildcards</th>
  </tr>
  <tr valign="top">
    <td class="yellow1">
      <p>
	Wildcards are allowed after any 3 alphanumerics:
	<ul><li><strong>?</strong> matches any trailing single characters
        <li><strong>**</strong> matches unlimited trailing characters, eg: <strong>ser**ip?t*</strong> could match serendipity
      </p>
    </td>
  </tr>
  <tr>
    <td>&nbsp;</td>
  </tr>

  <tr valign="top">
    <th class="yellow2">
      General Query Syntax
    </th>
  </tr>
  <tr valign="top">
    <td class="yellow1"><ul>
    <li>+ATP (also -ATP)<br />
    <li>ATP <strong>AND</strong> cassette<br />
    <li>ATP <strong>AND NOT</strong> cassette<br />
    <li>(ATP <strong>OR</strong> ADP) <strong>AND</strong> cassette<br />
    <li>ATP <strong>NEAR</strong> cassette<br />
    <li>ATP <strong>WITHIN 2</strong> cassette<br /></ul>
    </td>
  </tr>
  <tr><td>&nbsp;</td></tr>

  <tr valign="top">
    <th class="yellow2">
      Exact Matches
    </th>
  </tr>
  <tr valign="top">
    <td class="yellow1"><ul>
    <li>"Find this exact phrase"<br /></ul>
    </td>
  </tr>
</table>
</center>
<br />
);
}

# print Ensembl Help

else {
  return qq(
<h3>Quick Guide to Query Syntax</h3>
<p>
  The Ensembl free-text search index contains database abstracts from OMIM, Swissprot and Interpro.
</p>
<p>
<dl>
  <dt>wildcards are allowed after any 3 alphanumerics:</dt>
  <dd><strong>?</strong> matches any trailing single characters</dd>
  <dd><strong>**</strong> matches unlimited trailing characters.</dd>
  <dt>
  eg: <strong>ser*ip?t*</strong> could match serendipity
  </dt>
</dl>

<h3>General Query Syntax</h3>
<pre>    +clathrin (also -clathrin)
    clathrin AND vesicles
    clathrin AND NOT vesicles
    (clathin OR protein) AND vesicles
    clathrin NEAR vesicles
    clathrin WITHIN 2 vesicles</pre>
<h3>Exact Matches</h3>
<pre>    "Find this exact phrase"</pre>
);
}	

}

####################################3
sub print_form {
  my ( $parameters, $idx_hash )     = @_;
  my $ret = qq(
    <form name="IndexForm" method="get" action="/$ENV{'ENSEMBL_SPECIES'}/textview">
      <table border="0" cellpadding=0 cellspacing=0 width="545" align="center">
        <tr>
          <td colspan="3" bgcolor="#aaaaaa" width="545"><img src="/img/blank.gif" height="1" width="1" border="0" /></td>
        </tr>
        <tr>
          <td bgcolor="#aaaaaa" width="2"><img src="/img/blank.gif" height="1" width="1" border="0" /></td>
          <td>
            <table border="0" class="yellow2" cellspacing="4" cellpadding="4" width="100%">
                <tr valign="top">
                  <td class="yellow2">
                    &nbsp;Search 
                      <select name="species" onChange="setSelectOptions( document.forms['IndexForm'].elements['idx'], document.forms['IndexForm'].elements['species'], speciesConf )">
);

foreach ( 'All', @{$SD->ENSEMBL_SPECIES} ){
    (my $spec2 = $_) =~s/_/ /g;
    $ret.= qq(<option value="$_" ).(lc($_) eq lc($parameters->{'species'}) ? 'selected':'').qq(>$spec2</option>);
}

$ret .= qq(
                      </select>&nbsp;<select name="idx">
);

foreach ( 'All', sort keys %{$idx_hash} ){
    $ret .= qq(<option value="$_" ).($_ eq $parameters->{'index'} ? 'selected':'').qq(>$_</option>);
}

$ret .=  qq(
                      </select> indexes for:<br />
                      <div align="center"><input name="q" size="35" style="width: 90%" maxlength="800" value="$parameters->{'safe_query'}" /></div>
                  </td>
                </tr>
                <tr valign="top">
                  <td width="100%">
                    &nbsp;&nbsp;<font size="-1" face="arial, helvetica">Display up to 
                      <select name="num">
);
$ret .= join '', map { qq(<option value="$_" ). ($parameters->{'number'} == $_ ? 'selected' : '').qq(>$_</option>\n) } qw(20 40 60 100 500 1000);
$ret .= qq(             </select>results in
    <select name="fmt">
);
$ret .= join '', map { qq(<option value=").substr($_,0,1).qq(" ). ($parameters->{'format'} eq substr($_,0,1) ? 'selected' : '').qq(>$_</option>\n) } qw(standard compact);

$ret .= qq(
                      </select>format
                    </font>
                  </td>
                </tr>
                <tr>
                  <td align="center" style="text-align: center">
                    <img src="/img/altavista_icon.gif" alt="Powered By AltaVista" border="0" /> &nbsp;
                    <input type="submit" class="red-button" value="Search" name="search" />
                  </td>
                </tr>
            </table>
          </td>
          <td bgcolor="#aaaaaa" width="1"><img src="/img/blank.gif" height="1" width="1" border="0" /></td>
        </tr>
        <tr>
          <td colspan="3" bgcolor="#aaaaaa" width="545"><img src="/img/blank.gif" height="1" width="1" border="0" /></td>
        </tr>
      </table>
    </form>
);
  return $ret;
}
